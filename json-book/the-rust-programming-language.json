{
    "New item": {
        "chapters": [
            {
                "chapter_id": 1,
                "chapter_name": "GETTING STARTED",
                "chapter_path": "./screenshots-images-2/chapter_1",
                "sections": [
                    {
                        "section_id": 1.1,
                        "section_name": "Installation",
                        "section_path": "./screenshots-images-2/chapter_1/section_1",
                        "images": [
                            "./screenshots-images-2/chapter_1/section_1/965eff56-5930-4031-8ed4-ecd0c8ede5cb.png",
                            "./screenshots-images-2/chapter_1/section_1/6c6412de-8ede-46d7-a758-093b9658509a.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Installation\n\nThe first step is to install Rust. We'll download Rust through rustup, a\ncommand line tool for managing Rust versions and associated tools.\nYou'll need an internet connection for the download.\n\nIf you prefer not to use rustup for some reason, please see the Rust installation page at\nhttps://www.rust-lang.org/tools/install/ for other options.\n\nThe following steps install the latest stable version of the Rust compiler.\nRust\u2019s stability guarantees ensure that all the examples in the book that\ncompile will continue to compile with newer Rust versions. The output\nmight differ slightly between versions, because Rust often improves error\nmessages and warnings. In other words, any newer, stable version of Rust\nyou install using these steps should work as expected with the content of\n\nthis book.\n\nCOMMAND LINE NOTATION\n\nIn this chapter and throughout the book, we'll show some commands used\nin the terminal. Lines that you should enter in a terminal all start with $. You\n\ndon't need to type in the $ character; it indicates the start of each command.\nLines that don't start with $ typically show the output of the previous command.\nAdditionally, PowerShell-specific examples will use > rather than $.\n\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 1.2,
                        "section_name": "Installing rustup on Linux or macOS",
                        "section_path": "./screenshots-images-2/chapter_1/section_2",
                        "images": [
                            "./screenshots-images-2/chapter_1/section_2/0f3f0ca1-dc10-42a6-bffe-90a0df1e33f3.png",
                            "./screenshots-images-2/chapter_1/section_2/64ed5f34-6ecf-4d90-83e2-bf3072976853.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Installing rustup on Linux or macOS\n\nIf you're using Linux or macOS, open a terminal and enter the following\ncommand:\n\n$ curl https://sh.rustup.rs -sSf | sh\n\nThe command downloads a script and starts the installation of the\nrustup tool, which installs the latest stable version of Rust. You might be\nprompted for your password. If the install is successful, the following line\nwill appear:\n\nRust is installed now. Great!\n\nIf you prefer, feel free to download the script and inspect it before run-\nning it.\n\nThe installation script automatically adds Rust to your system PATH\nafter your next login. If you want to start using Rust right away instead of\nrestarting your terminal, run the following command in your shell to add\nRust to your system PATH manually:\n\n$ source $HOME/.cargo/env\n\nAlternatively, you can add the following line to your ~/.bash_profile:\n\n$ export PATH=\"$HOME/.cargo/bin:$PATH\"\n\nAdditionally, you'll need a linker of some kind. It\u2019s likely one is already\ninstalled, but when you try to compile a Rust program and get errors indi-\ncating that a linker could not execute, that means a linker isn\u2019t installed on\n\nyour system and you'll need to install one manually. C compilers usually\ncome with the correct linker. Check your platform's documentation for\nhow to install a C compiler. Also, some common Rust packages depend on\n\nC code and will need a C compiler. Therefore, it might be worth installing\none now.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 1.3,
                        "section_name": "Installing rustup on Windows",
                        "section_path": "./screenshots-images-2/chapter_1/section_3",
                        "images": [
                            "./screenshots-images-2/chapter_1/section_3/32b7caf7-aec5-4fa5-83b7-2c8e8e85d887.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Installing rustup on Windows\n\nOn Windows, go to Attps://www.rust-lang.org/tools/install/ and follow the\ninstructions for installing Rust. At some point in the installation, you'll\nreceive a message explaining that you'll also need the C++ build tools for\nVisual Studio 2013 or later. The easiest way to acquire the build tools is to\ninstall Build Tools for Visual Studio 2019 at https://www.visualstudio.com/\ndownloads/#build-tools-for-visual-studio-2019. The tools are in the Other Tools\nand Frameworks section.\n\nThe rest of this book uses commands that work in both cmd.exe and\nPowerShell. If there are specific differences, we'll explain which to use.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 1.4,
                        "section_name": "Updating and Uninstalling",
                        "section_path": "./screenshots-images-2/chapter_1/section_4",
                        "images": [
                            "./screenshots-images-2/chapter_1/section_4/fb162943-1e8e-4ad5-b488-784f6ecfd5b3.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Updating and Uninstalling\n\nAfter you've installed Rust via rustup, updating to the latest version is easy.\nFrom your shell, run the following update script:\n\n$ rustup update\n\nTo uninstall Rust and rustup, run the following uninstall script from\nyour shell:\n\n$ rustup self uninstall\n\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 1.5,
                        "section_name": "Troubleshooting",
                        "section_path": "./screenshots-images-2/chapter_1/section_5",
                        "images": [
                            "./screenshots-images-2/chapter_1/section_5/39a16e68-bed8-4797-b2e8-1be010d24559.png",
                            "./screenshots-images-2/chapter_1/section_5/fa17ada3-e449-4144-a1d0-91231bc3ee53.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Troubleshooting\n\nTo check whether you have Rust installed correctly, open a shell and enter\nthis line:\n\n$ ruste --version\n\nYou should see the version number, commit hash, and commit date for\nthe latest stable version that has been released in the following format:\n\nrustc x.y.z (abcabcabe yyyy-mm-dd)\n\nIf you see this information, you have installed Rust successfully! If you\ndon\u2019t see this information and you're on Windows, check that Rust is in your\nXPATH% system variable. If that\u2019s all correct and Rust still isn\u2019t working, there\nare a number of places you can get help. The easiest is the #beginners chan-\nnel on the official Rust Discord at Attps://discord.gg/rust-lang. There, you can\n\nchat with other Rustaceans (a silly nickname we call ourselves) who can help\nyou out. Other great resources include the Users forum at Attps://users.rust\n-lang.org/ and Stack Overflow at hitp://stackoverflow.com/questions/tagged/rust/.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 1.6,
                        "section_name": "Local Documentation",
                        "section_path": "./screenshots-images-2/chapter_1/section_6",
                        "images": [
                            "./screenshots-images-2/chapter_1/section_6/83964a44-bd54-4b1d-9d1b-ad1927cd9708.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Local Documentation\n\nThe installer also includes a copy of the documentation locally, so you can\nread it offline. Run rustup doc to open the local documentation in your\nbrowser.\n\nAny time a type or function is provided by the standard library and\nyou're not sure what it does or how to use it, use the application program-\nming interface (API) documentation to find out!\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 1.7,
                        "section_name": "Hello, World!",
                        "section_path": "./screenshots-images-2/chapter_1/section_7",
                        "images": [
                            "./screenshots-images-2/chapter_1/section_7/04d26b82-e182-4e59-ae74-a7682d92bf35.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Hello, World!\n\nNow that you've installed Rust, let's write your first Rust program. It\u2019s trad-\nitional when learning a new language to write a little program that prints\nthe text Hello, world! to the screen, so we'll do the same here!\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 1.8,
                        "section_name": "Geating a Project Directory",
                        "section_path": "./screenshots-images-2/chapter_1/section_8",
                        "images": [
                            "./screenshots-images-2/chapter_1/section_8/52ef7970-5d32-4a2b-8100-5f8414c563a5.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Creating a Project Directory\n\nYou'll start by making a directory to store your Rust code. It doesn\u2019t matter\nto Rust where your code lives, but for the exercises and projects in this book,\nwe suggest making a projects directory in your home directory and keeping all\nyour projects there.\n\nOpen a terminal and enter the following commands to make a projects\ndirectory and a directory for the Hello, world! project within the projects\ndirectory.\n\nFor Linux, macOS, and PowerShell on Windows, enter this:\n\n$ mkdir ~/projects\n$ cd ~/projects\n$ mkdir hello _world\n$ cd hello_world\n\nFor Windows CMD, enter this:\n\n> mkdir \"XUSERPROFILE%\\projects\u201d\n> cd /d \"ZUSERPROFILE%\\projects\"\n> mkdir hello_world\n\n> ed hello world\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 1.9,
                        "section_name": "Writing and Running a Rust Program",
                        "section_path": "./screenshots-images-2/chapter_1/section_9",
                        "images": [
                            "./screenshots-images-2/chapter_1/section_9/6fb526b5-7c89-4e43-a16f-fa3e3aa71335.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Writing and Running a Rust Program\n\nNext, make a new source file and call it main.rs. Rust files always end with\nthe .rs extension. If you're using more than one word in your filename, use\nan underscore to separate them. For example, use hello_world.rs rather than\nhelloworld.rs.\n\nNow open the main.rs file you just created and enter the code in Listing 1-1.\n\nfn main() {\nprintln!(\"Hello, world!\");\n\nListing 1-1: A program that prints Hello, world!\n\nSave the file and go back to your terminal window. On Linux or macOS,\nenter the following commands to compile and run the file:\n\n$ rustc main.rs\n$ ./main\nHello, world!\n\nOn Windows, enter the command .\\main.exe instead of ./main:\n\n> rustc main.rs\n> \u00ab\\main.exe\nHello, world!\n\nRegardless of your operating system, the string Hello, world! should print\nto the terminal. If you don\u2019t see this output, refer to \u201cTroubleshooting\u201d on\npage 3 for ways to get help.\n\nIfHello, world! did print, congratulations! You've officially written a\nRust program. That makes you a Rust programmer\u2014welcome!\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 1.1,
                        "section_name": "Anatomy of a Rust Program",
                        "section_path": "./screenshots-images-2/chapter_1/section_10",
                        "images": [
                            "./screenshots-images-2/chapter_1/section_10/17afadef-5e08-4bed-871c-7d916a81ec67.png",
                            "./screenshots-images-2/chapter_1/section_10/f1552b4c-7e4b-4081-883c-c52df7abce9a.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Anatomy of a Rust Program\n\nLet\u2019s review in detail what just happened in your Hello, world! program.\nHere\u2019s the first piece of the puzzle:\n\nfn main() {\n\n}\n\nThese lines define a function in Rust. The main function is special: it is\nalways the first code that runs in every executable Rust program. The first\nline declares a function named main that has no parameters and returns\nnothing. If there were parameters, they would go inside the parentheses, ().\n\nAlso, note that the function body is wrapped in curly brackets, {}. Rust\nrequires these around all function bodies. It\u2019s good style to place the open-\ning curly bracket on the same line as the function declaration, adding one\nspace in between.\n\nAt the time of this writing, an automatic formatter tool called rust fmt is\nunder development. If you want to stick to a standard style across Rust proj-\nects, rustfmt will format your code in a particular style. The Rust team plans\nto eventually include this tool with the standard Rust distribution, like rustc.\nSo depending on when you read this book, it might already be installed on\nyour computer! Check the online documentation for more details.\n\nInside the main function is the following code:\n\nprintln!(\"Hello, world!\"\n\nThis line does all the work in this little program: it prints text to the\nscreen. There are four important details to notice here. First, Rust style is\nto indent with four spaces, not a tab.\n\nSecond, println! calls a Rust macro. If it called a function instead, it\nwould be entered as print1n (without the !). We'll discuss Rust macros in\nmore detail in Chapter 19. For now, you just need to know that using a !\nmeans that you're calling a macro instead of a normal function.\n\nThird, you see the \"Hello, world!\" string. We pass this string as an argu-\nment to println!, and the string is printed to the screen.\n\nFourth, we end the line with a semicolon (;), which indicates that this\nexpression is over and the next one is ready to begin. Most lines of Rust\ncode end with a semicolon.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 1.11,
                        "section_name": "Compiling and Running Are Separate Steps",
                        "section_path": "./screenshots-images-2/chapter_1/section_11",
                        "images": [
                            "./screenshots-images-2/chapter_1/section_11/9ce0b63f-1aab-45cd-9607-684f872689c2.png",
                            "./screenshots-images-2/chapter_1/section_11/fb3ea915-7551-407f-b637-a90e3fb84a49.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Compiling and Running Are Separate Steps\n\nYou've just run a newly created program, so let\u2019s examine each step in the\nprocess.\n\nBefore running a Rust program, you must compile it using the Rust\ncompiler by entering the rustc command and passing it the name of your\nsource file, like this:\n\n$ rustc main.rs\n\nIf you have a C or C++ background, you'll notice that this is similar to\ngcc or clang. After compiling successfully, Rust outputs a binary executable.\n\nOn Linux, macOS, and PowerShell on Windows, you can see the exe-\ncutable by entering the 1s command in your shell. On Linux and macOS,\nyou'll see two files. With PowerShell on Windows, you'll see the same three\nfiles that you would see using CMD.\n\n$ 1s\nmain main.rs\n\nWith CMD on Windows, you would enter the following:\n\n> dir /B %= the /B option says to only show the file names =%\nmain.exe\nmain. pdb\nmain.rs\n\nThis shows the source code file with the .rs extension, the executable\nfile (main.exe on Windows but main on all other platforms), and, when using\nWindows, a file containing debugging information with the .pdb extension.\nFrom here, you run the main or main.exe file, like this:\n\n$ ./main # or .\\main.exe on Windows\n\nIf main.rs was your Hello, world! program, this line would print Hello,\nworld! to your terminal.\n\nIf you're more familiar with a dynamic language, such as Ruby, Python,\nor JavaScript, you might not be used to compiling and running a program\nas separate steps. Rust is an ahead-of-time compiled language, meaning you can\ncompile a program and give the executable to someone else, and they can\nrun it even without having Rust installed. If you give someone a .rb, .py, or js\nfile, they need to have a Ruby, Python, or JavaScript implementation installed\n(respectively). But in those languages, you need only one command to com-\npile and run your program. Everything is a trade-off in language design.\n\nJust compiling with rustc is fine for simple programs, but as your project\ngrows, you'll want to manage all the options and make it easy to share your\ncode. Next, we'll introduce you to the Cargo tool, which will help you write\nreal-world Rust programs.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 1.12,
                        "section_name": "Hello, Cargo!",
                        "section_path": "./screenshots-images-2/chapter_1/section_12",
                        "images": [
                            "./screenshots-images-2/chapter_1/section_12/4a6810fb-657c-407e-b3c1-0dfc8fd05017.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Hello, Cargo!\n\nCargo is Rust\u2019s build system and package manager. Most Rustaceans use\nthis tool to manage their Rust projects because Cargo handles a lot of tasks\nfor you, such as building your code, downloading the libraries your code\ndepends on, and building those libraries. (We call libraries your code needs\ndependencies.)\n\nThe simplest Rust programs, like the one we've written so far, don\u2019t have\nany dependencies. So if we had built the Hello, world! project with Cargo, it\nwould only use the part of Cargo that handles building your code. As you\nwrite more complex Rust programs, you'll add dependencies, and if you start\na project using Cargo, adding dependencies will be much easier to do.\n\nBecause the vast majority of Rust projects use Cargo, the rest of\nthis book assumes that you're using Cargo, too. Cargo comes installed\nwith Rust if you used the official installers discussed in \u201cInstallation\u201d\non page 1. If you installed Rust through some other means, check\nwhether Cargo is installed by entering the following into your terminal:\n\n$ cargo --version\n\nIf you see a version number, you have it! If you see an error, such as\ncommand not found, look at the documentation for your method of installa-\ntion to determine how to install Cargo separately.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 1.13,
                        "section_name": "Geating a Project with Cargo",
                        "section_path": "./screenshots-images-2/chapter_1/section_13",
                        "images": [
                            "./screenshots-images-2/chapter_1/section_13/2b33b20e-6315-4627-83b2-b0d36f50b9b9.png",
                            "./screenshots-images-2/chapter_1/section_13/c7c89453-11b4-4bf0-81c6-21cb75256409.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Cargo.toml\n\nGeating a Project with Cargo\n\nLet\u2019s create a new project using Cargo and look at how it differs from our\noriginal Hello, world! project. Navigate back to your projects directory (or\n\nwherever you decided to store your code). Then, on any operating system,\nrun the following:\n\n$ cargo new hello_cargo\n$ cd hello_cargo\n\nThe first command creates a new directory called hello_cargo. We've\nnamed our project hello_cargo, and Cargo creates its files in a directory of\nthe same name.\n\nGo into the hello_cargo directory and list the files. You'll see that Cargo\nhas generated two files and one directory for us: a Cargo.toml file and a src\ndirectory with a main.rs file inside. It has also initialized a new Git repository\nalong with a .gitignore file.\n\nGit is a common version control system. You can change cargo new to use a different\nversion control system or no version control system by using the --vcs flag. Run cargo\nnew --help to see the available options.\n\nOpen Cargo.toml in your text editor of choice. It should look similar to\nthe code in Listing 1-2.\n\n[package]\nname = \u201chello cargo\"\nversion = \"0.1.0\"\n\nauthors = [\"Your Name <you@example.com>\"]\nedition = \"2018\"\n[dependencies]\n\nListing 1-2: Contents of Cargo.toml generated by cargo new\n\nThis file is in the TOML (Tom's Obvious, Minimal Language) format,\nwhich is Cargo\u2019s configuration format.\n\nThe first line, [package], is a section heading that indicates that the fol-\nlowing statements are configuring a package. As we add more information\nto this file, we'll add other sections.\n\nThe next four lines set the configuration information Cargo needs to\ncompile your program: the name, the version, who wrote it, and the edition\nof Rust to use. Cargo gets your name and email information from your envi-\nronment, so if that information is not correct, fix the information now and\nthen save the file. We'll talk about the edition key in Appendix E.\n\nThe last line, [dependencies], is the start of a section for you to list any\nof your project's dependencies. In Rust, packages of code are referred to as\ncrates. We won't need any other crates for this project, but we will in the first\nproject in Chapter 2, so we'll use this dependencies section then.\n\nsrc/main.rs\n\nNow open src/main.rs and take a look:\n\nfn main() {\nprintln!(\"Hello, world!\");\n}\n\nCargo has generated a Hello, world! program for you, just like the one\nwe wrote in Listing 1-1! So far, the differences between our previous project\nand the project Cargo generates are that Cargo placed the code in the sre\ndirectory and we have a Cargo.toml configuration file in the top directory.\n\nCargo expects your source files to live inside the src directory. The top-\nlevel project directory is just for README files, license information, config-\nuration files, and anything else not related to your code. Using Cargo helps\nyou organize your projects. There\u2019s a place for everything, and everything is\nin its place.\n\nIf you started a project that doesn\u2019t use Cargo, as we did with the Hello,\nworld! project, you can convert it to a project that does use Cargo. Move the\nproject code into the src directory and create an appropriate Cargo.tom! file.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 1.14,
                        "section_name": "Building and Running a Cargo Project",
                        "section_path": "./screenshots-images-2/chapter_1/section_14",
                        "images": [
                            "./screenshots-images-2/chapter_1/section_14/4602b0ca-ab25-4885-97a9-24659e52c0a6.png",
                            "./screenshots-images-2/chapter_1/section_14/53cb950f-f4a6-493c-b403-6b6385800632.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Building and Running a Cargo Project\n\nNow let\u2019s look at what's different when we build and run the Hello, world!\nprogram with Cargo! From your hello_cargo directory, build your project by\nentering the following command:\n\n$ cargo build\nCompiling hello_cargo v0.1.0 (file:///projects/hello_cargo)\nFinished dev [unoptimized + debuginfo] target(s) in 2.85 secs\n\nThis command creates an executable file in target/debug/hello_cargo (or\ntarget\\debug\\hello_cargo.exe on Windows) rather than in your current direc-\ntory. You can run the executable with this command:\n\n$ ./target/debug/hello_ cargo # or .\\target\\debug\\hello_cargo.exe on Windows\nHello, world!\n\nIf all goes well, Hello, world! should print to the terminal. Running\ncargo build for the first time also causes Cargo to create a new file at the top\nlevel: Cargo.lock. This file keeps track of the exact versions of dependencies\nin your project. This project doesn\u2019t have dependencies, so the file is a bit\nsparse. You won't ever need to change this file manually; Cargo manages its\ncontents for you.\n\nWe just built a project with cargo build and ran it with ./target/debug/\nhello_cargo, but we can also use cargo run to compile the code and then run\nthe resulting executable all in one command:\n\n$ cargo run\nFinished dev [unoptimized + debuginfo] target(s) in 0.0 secs\nRunning \u201ctarget/debug/hello_ cargo\u201d\n\nHello, world!\n\nNotice that this time we didn\u2019t see output indicating that Cargo was\ncompiling hello_cargo. Cargo figured out that the files hadn't changed, so it\njust ran the binary. If you had modified your source code, Cargo would have\nrebuilt the project before running it, and you would have seen this output:\n\n$ cargo run\nCompiling hello cargo v0.1.0 (file:///projects/hello_cargo)\nFinished dev [unoptimized + debuginfo] target(s) in 0.33 secs\nRunning ~target/debug/hello_cargo\u201d\nHello, world!\n\nCargo also provides a command called cargo check. This command\nquickly checks your code to make sure it compiles but doesn\u2019t produce\nan executable:\n\n$ cargo check\nChecking hello cargo v0.1.0 (file:///projects/hello_cargo)\nFinished dev [unoptimized + debuginfo] target(s) in 0.32 secs\n\nWhy would you not want an executable? Often, cargo check is much\nfaster than cargo build, because it skips the step of producing an executable.\nIf you're continually checking your work while writing the code, using cargo\ncheck will speed up the process! As such, many Rustaceans run cargo check\nperiodically as they write their program to make sure it compiles. Then\nthey run cargo build when they're ready to use the executable.\n\nLet\u2019s recap what we've learned so far about Cargo:\n\ne We can build a project using cargo build or cargo check.\ne We can build and run a project in one step using cargo run.\n\ne Instead of saving the result of the build in the same directory as our\ncode, Cargo stores it in the target/debug directory.\n\nAn additional advantage of using Cargo is that the commands are the\nsame no matter which operating system you're working on. So, at this point,\nwe'll no longer provide specific instructions for Linux and macOS versus\nWindows.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 1.15,
                        "section_name": "Building for Release",
                        "section_path": "./screenshots-images-2/chapter_1/section_15",
                        "images": [
                            "./screenshots-images-2/chapter_1/section_15/befb6aad-6399-4480-b773-4ce73f5def16.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Building for Release\n\nWhen your project is finally ready for release, you can use cargo build --release\nto compile it with optimizations. This command will create an executable in\ntarget/release instead of target/debug. The optimizations make your Rust code\nrun faster, but turning them on lengthens the time it takes for your program\nto compile. This is why there are two different profiles: one for development,\nwhen you want to rebuild quickly and often, and another for building the\nfinal program you'll give to a user that won't be rebuilt repeatedly and that\nwill run as fast as possible. If you're benchmarking your code\u2019s running time,\nbe sure to run cargo build --release and benchmark with the executable in\ntarget/release.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 1.16,
                        "section_name": "Cargo as Convention",
                        "section_path": "./screenshots-images-2/chapter_1/section_16",
                        "images": [
                            "./screenshots-images-2/chapter_1/section_16/51aabb6f-74e0-4d76-9ca4-6584798846af.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Cargo as Convention\n\nWith simple projects, Cargo doesn\u2019t provide a lot of value over just using\nrustc, but it will prove its worth as your programs become more intricate.\nWith complex projects composed of multiple crates, it\u2019s much easier to let\nCargo coordinate the build.\n\nEven though the hello_cargo project is simple, it now uses much of the\nreal tooling you'll use in the rest of your Rust career. In fact, to work on\nany existing projects, you can use the following commands to check out the\ncode using Git, change to that project\u2019s directory, and build:\n\n$ git clone someurl.com/someproject\n$ cd someproject\n$ cargo build\n\nFor more information about Cargo, check out its documentation at\nAttps://doc.rust-lang.org/cargo/.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 1.17,
                        "section_name": "Summary",
                        "section_path": "./screenshots-images-2/chapter_1/section_17",
                        "images": [
                            "./screenshots-images-2/chapter_1/section_17/926826b2-b8f1-4296-a795-a719ce00ef73.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Summary\n\nYou're already off to a great start on your Rust journey! In this chapter,\nyou've learned how to:\n\nInstall the latest stable version of Rust using rustup\n\nUpdate to a newer Rust version\n\nOpen locally installed documentation\n\nWrite and run a Hello, world! program using rustc directly\n\nCreate and run a new project using the conventions of Cargo\n\nThis is a great time to build a more substantial program to get used\n\nto reading and writing Rust code. So, in Chapter 2, we'll build a guess-\ning game program. If you would rather start by learning how common\nprogramming concepts work in Rust, see Chapter 3 and then return to\nChapter 2.\n",
                        "extracted-code": ""
                    }
                ]
            },
            {
                "chapter_id": 2,
                "chapter_name": "PROGRAMMING A\nGUESSING GAME",
                "chapter_path": "./screenshots-images-2/chapter_2",
                "sections": [
                    {
                        "section_id": 2.1,
                        "section_name": "PROGRAMMING A\nGUESSING GAME",
                        "section_path": "./screenshots-images-2/chapter_2/section_1",
                        "images": [
                            "./screenshots-images-2/chapter_2/section_1/5131a995-2acf-4940-a7e4-ea464faaf7ec.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Let\u2019s jump into Rust by working through\n\na hands-on project together! This chap-\nter introduces you to a few common Rust\n\nconcepts by showing you how to use them in a\n\nreal program. You'll learn about let, match, methods,\nassociated functions, using external crates, and more!\nThe following chapters will explore these ideas\nin more detail. In this chapter, you'll practice the\nfundamentals.\n\nWe'll implement a classic beginner programming problem: a guessing\ngame. Here\u2019s how it works: the program will generate a random integer\nbetween 1 and 100. It will then prompt the player to enter a guess. After a\nguess is entered, the program will indicate whether the guess is too low or\ntoo high. If the guess is correct, the game will print a congratulatory message\nand exit.\n\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 2.2,
                        "section_name": "Setting Up a New Project",
                        "section_path": "./screenshots-images-2/chapter_2/section_2",
                        "images": [
                            "./screenshots-images-2/chapter_2/section_2/b6b78a42-dc3b-421a-9b7f-7e7ef1683402.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Setting Up a New Project\n\nCargo.tom!\n\nsrc/main.rs\n\nTo set up a new project, go to the projects directory that you created in\nChapter 1 and make a new project using Cargo, like so:\n\n$ cargo new guessing game\n$ cd guessing game\n\nThe first command, cargo new, takes the name of the project (guessing\n_game) as the first argument. The second command changes to the new\nproject's directory.\n\nLook at the generated Cargo.tomi file:\n\n[package]\n\nname = \u201cguessing game\"\n\nversion = \"0.1.0\"\n\nauthors = [\"Your Name <you\u00aeexample.com>\"]\nedition = \"2018\"\n\n[dependencies]\n\nIf the author information that Cargo obtained from your environment\nis not correct, fix that in the file and save it again.\n\nAs you saw in Chapter 1, cargo new generates a \u201cHello, world!\u201d program\nfor you. Check out the sr\u00a2/main.rs file:\n\nfn main() {\nprintln!(\"Hello, world!\");\n}\n\nNow let\u2019s compile this \u201cHello, world!\u201d program and run it in the same\nstep using the cargo run command:\n\n$ cargo run\nCompiling guessing game v0.1.0 (file:///projects/guessing game)\nFinished dev [unoptimized + debuginfo] target(s) in 1.50 secs\nRunning \u201ctarget/debug/guessing game\nHello, world!\n\nThe run command comes in handy when you need to rapidly iterate on a\nproject, as we'll do in this game, quickly testing each iteration before moving\non to the next one.\n\nReopen the src/main.rs file. You'll be writing all the code in this file.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 2.3,
                        "section_name": "Processing a Guess",
                        "section_path": "./screenshots-images-2/chapter_2/section_3",
                        "images": [
                            "./screenshots-images-2/chapter_2/section_3/07afe88e-015c-4445-8fed-0691ad57356e.png",
                            "./screenshots-images-2/chapter_2/section_3/047d033b-24e2-4619-9efd-2555c4c62119.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Processing a Guess\n\nThe first part of the guessing game program will ask for user input, process\nthat input, and check that the input is in the expected form. To start, we'll\nallow the player to input a guess. Enter the code in Listing 2-1 into sr\u00a2/main.rs.\n\nsrc/main.rs\n\nuse std::io;\n\nfn main() {\nprintln!(\"Guess the number!\");\n\nprintln!(\"Please input your guess.\");\nlet mut guess = String: :new();\n\nio::stdin().read_line(&mut guess)\n-expect(\"Failed to read line\");\n\nprintln!(\"You guessed: {}\", guess);\n}\n\nListing 2-1: Code that gets a guess from the user and prints it\n\nThis code contains a lot of information, so let's go over it line by line.\nTo obtain user input and then print the result as output, we need to bring\nthe io (input/output) library into scope. The io library comes from the\nstandard library (which is known as std):\n\nuse std::io;\n\nBy default, Rust brings only a few types into the scope of every program\nin the prelude. If a type you want to use isn\u2019t in the prelude, you have to bring\nthat type into scope explicitly with a use statement. Using the std: :io library\nprovides you with a number of useful features, including the ability to accept\nuser input.\n\nAs you saw in Chapter 1, the main function is the entry point into the\nprogram:\n\nfn main() {\n\nThe fn syntax declares a new function, the parentheses, (), indicate there\nare no parameters, and the curly bracket, {, starts the body of the function.\n\nAs you also learned in Chapter 1, println! is a macro that prints a string\nto the screen:\n\nprintln!(\"Guess the number!\");\n\nprintln!(\"Please input your guess.\");\n\nThis code is printing a prompt stating what the game is and requesting\ninput from the user.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 2.4,
                        "section_name": "Storing Values with Variables",
                        "section_path": "./screenshots-images-2/chapter_2/section_4",
                        "images": [
                            "./screenshots-images-2/chapter_2/section_4/7095ed83-e24a-4840-90dd-50152705578c.png",
                            "./screenshots-images-2/chapter_2/section_4/76967b8a-0ff7-49da-b641-1af76040709c.png",
                            "./screenshots-images-2/chapter_2/section_4/5a0dd8fe-99f1-4880-aebc-86eb3afb2502.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Storing Values with Variables\n\nNext, we'll create a place to store the user input, like this:\n\nlet mut guess = String: :new();\n\nNow the program is getting interesting! There\u2019s a lot going on in this\nlittle line. Notice that this is a let statement, which is used to create a variable.\nHere\u2019s another example:\n\nlet foo = bar;\n\nThis line creates a new variable named foo and binds it to the value of\nthe bar variable. In Rust, variables are immutable by default. We'll discuss\nthis concept in detail in \u201cVariables and Mutability\u201d on page 32. The fol-\nlowing example shows how to use mut before the variable name to make a\nvariable mutable:\n\nlet foo = 5; // immutable\nlet mut bar = 5; // mutable\n\nThe // syntax starts a comment that continues until the end of the line. Rust ignores\neverything in comments, which are discussed in more detail in Chapter 3.\n\nLet\u2019s return to the guessing game program. You now know that let mut\nguess will introduce a mutable variable named guess. On the other side of\nthe equal sign (=) is the value that guess is bound to, which is the result of\ncalling String: :new, a function that returns a new instance of a String. String\nis a string type provided by the standard library that is a growable, UTF-8\nencoded bit of text.\n\nThe :: syntax in the ::new line indicates that new is an associated function\nof the String type. An associated function is implemented on a type, in this\ncase String, rather than on a particular instance of a String. Some languages\ncall this a static method.\n\nThis new function creates a new, empty string. You'll find a new function\non many types, because it\u2019s a common name for a function that makes a\nnew value of some kind.\n\nTo summarize, the let mut guess = String: :new(); line has created a\nmutable variable that is currently bound to a new, empty instance of a\nString. Whew!\n\nRecall that we included the input/output functionality from the stan-\ndard library with use std::io; on the first line of the program. Now we'll\ncall the stdin function from the io module:\n\nio::stdin().read_line(&mut guess)\n-expect(\"Failed to read line\");\n\nIf we hadn't listed the use std::io line at the beginning of the program,\nwe could have written this function call as std::io::stdin. The stdin function\nreturns an instance of std::io::Stdin, which is a type that represents a handle\nto the standard input for your terminal.\n\nThe next part of the code, .read_line(&mut guess), calls the read_line\nmethod on the standard input handle to get input from the user. We\u2019re\nalso passing one argument to read_line: &mut guess.\n\nThe job of read_line is to take whatever the user types into standard\ninput and place that into a string, so it takes that string as an argument.\nThe string argument needs to be mutable so the method can change the\nstring\u2019s content by adding the user input.\n\nThe & indicates that this argument is a reference, which gives you a way to\nlet multiple parts of your code access one piece of data without needing to\ncopy that data into memory multiple times. References are a complex fea-\nture, and one of Rust\u2019s major advantages is how safe and easy it is to use ref-\nerences. You don\u2019t need to know a lot of those details to finish this program.\nFor now, all you need to know is that like variables, references are immu-\ntable by default. Hence, you need to write &mut guess rather than &guess to\nmake it mutable. (Chapter 4 will explain references more thoroughly.)\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 2.5,
                        "section_name": "Handling Potential Failure with the Result Type",
                        "section_path": "./screenshots-images-2/chapter_2/section_5",
                        "images": [
                            "./screenshots-images-2/chapter_2/section_5/a63df250-818b-4012-8d17-d990b36e352e.png",
                            "./screenshots-images-2/chapter_2/section_5/9b00b501-5c95-448e-8107-a239eae5b586.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Handling Potential Failure with the Result Type\n\nWe're not quite done with this line of code. Although what we've discussed\nso far is a single line of text, it\u2019s only the first part of the single logical line of\ncode. The second part is this method:\n\n-expect(\"Failed to read line\");\n\nWhen you call a method with the .foo() syntax, it\u2019s often wise to intro-\nduce a newline and other whitespace to help break up long lines. We could\nhave written this code as:\n\nio::stdin().read_line(&mut guess).expect(\"Failed to read line\");\n\nHowever, one long line is difficult to read, so it\u2019s best to divide it: two\nlines for two method calls. Now let\u2019s discuss what this line does.\n\nAs mentioned earlier, read_line puts what the user types into the string\nwe're passing it, but it also returns a value\u2014in this case, an io: :Result. Rust\nhas a number of types named Result in its standard library: a generic Result\nas well as specific versions for submodules, such as io: :Result.\n\nThe Result types are enumerations, often referred to as enums. An\nenumeration is a type that can have a fixed set of values, and those values\nare called the enum\u2019s variants. Chapter 6 will cover enums in more detail.\n\nFor Result, the variants are Ok or Err. The Ok variant indicates the opera-\ntion was successful, and inside 0k is the successfully generated value. The\nErr variant means the operation failed, and Err contains information about\nhow or why the operation failed.\n\nThe purpose of these Result types is to encode error-handling informa-\ntion. Values of the Result type, like values of any type, have methods defined\non them. An instance of io: :Result has an expect method that you can call.\nIf this instance of io: :Result is an Err value, expect will cause the program to\ncrash and display the message that you passed as an argument to expect. If\nthe read_line method returns an Err, it would likely be the result of an error\ncoming from the underlying operating system. If this instance of io::Result\n\nis an 0k value, expect will take the return value that 0k is holding and return\njust that value to you so you can use it. In this case, that value is the number\nof bytes in what the user entered into standard input.\n\nIf you don\u2019t call expect, the program will compile, but you'll get a warning:\n\n$ cargo build\n\nCompiling guessing game v0.1.0 (file:///projects/guessing game)\nwarning: unused ~std::result::Result\u201d which must be used\n\n--> src/main.rs:10:5\n\n|\n10 | io::stdin().read_line(&mut guess);\n\n| AR ARARAARAARARAAAAARARAARAARAAAAAA\n\n|\n= note: #[warn(unused_must_use)] on by default\n\nRust warns that you haven't used the Result value returned from\nread_line, indicating that the program hasn't handled a possible error.\n\nThe right way to suppress the warning is to actually write error handling,\nbut because you just want to crash this program when a problem occurs, you\ncan use expect. You'll learn about recovering from errors in Chapter 9.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 2.6,
                        "section_name": "Printing Values with println! Placeholders",
                        "section_path": "./screenshots-images-2/chapter_2/section_6",
                        "images": [
                            "./screenshots-images-2/chapter_2/section_6/22238586-d9d8-4fb9-901a-e2e45c5aa0b5.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Printing Values with println! Placeholders\n\nAside from the closing curly brackets, there\u2019s only one more line to discuss\nin the code added so far, which is the following:\n\nprintln!(\"You guessed: {}\", guess);\n\nThis line prints the string we saved the user\u2019s input in. The set of curly\nbrackets, {}, is a placeholder: think of {} as little crab pincers that hold a\nvalue in place. You can print more than one value using curly brackets: the\nfirst set of curly brackets holds the first value listed after the format string,\nthe second set holds the second value, and so on. Printing multiple values\nin one call to println! would look like this:\n\nlet x\nlet y\n\n53\n10;\n\nprintln!(\"x = {} and y = {}\", x, y);\n\nThis code would print x = 5 and y = 10.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 2.7,
                        "section_name": "Testing the First Part",
                        "section_path": "./screenshots-images-2/chapter_2/section_7",
                        "images": [
                            "./screenshots-images-2/chapter_2/section_7/7badad79-d450-4d2b-a388-dba546ea6721.png",
                            "./screenshots-images-2/chapter_2/section_7/b47eef7a-a9bb-4de2-89d5-4d9d2a8d66ed.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Testing the First Part\n\nLet\u2019s test the first part of the guessing game. Run it using cargo run:\n\n$ cargo run\nCompiling guessing game v0.1.0 (file:///projects/guessing game)\n\nFinished dev [unoptimized + debuginfo] target(s) in 1.50 secs\nRunning \u201ctarget/debug/guessing game\nGuess the number!\n\nPlease input your guess.\n6\nYou guessed: 6\n\nAt this point, the first part of the game is done: we're getting input\nfrom the keyboard and then printing it.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 2.8,
                        "section_name": "Generating a Secret Number",
                        "section_path": "./screenshots-images-2/chapter_2/section_8",
                        "images": [
                            "./screenshots-images-2/chapter_2/section_8/bf738ea3-30f0-47e6-b01e-40c7a9ff52b6.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Generating a Secret Number\n\nNext, we need to generate a secret number that the user will try to guess.\nThe secret number should be different every time so the game is fun to\nplay more than once. Let\u2019s use a random number between | and 100 so\nthe game isn\u2019t too difficult. Rust doesn\u2019t yet include random number func-\ntionality in its standard library. However, the Rust team does provide a rand\ncrate at https://crates.io/crates/rand/.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 2.9,
                        "section_name": "Using a Crate to Get More Functionality",
                        "section_path": "./screenshots-images-2/chapter_2/section_9",
                        "images": [
                            "./screenshots-images-2/chapter_2/section_9/9aec9f81-0d9b-441c-a41c-c1b17aa292e4.png",
                            "./screenshots-images-2/chapter_2/section_9/0f7492f1-83be-4303-9f6b-19d173c86af1.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Using a Crate to Get More Functionality\n\nRemember that a crate is a collection of Rust source code files. The project\nwe've been building is a binary crate, which is an executable. The rand crate is\na library crate, which contains code intended to be used in other programs.\n\nCargo\u2019s use of external crates is where it really shines. Before we can\nwrite code that uses rand, we need to modify the Cargo.toml file to include\nthe rand crate as a dependency. Open that file now and add the following\nline to the bottom beneath the [dependencies] section header that Cargo\ncreated for you:\n\n[dependencies]\n\nrand = \"0.3.14\"\n\nIn the Cargo.toml file, everything that follows a header is part of a section\nthat continues until another section starts. The [dependencies] section is where\nyou tell Cargo which external crates your project depends on and which ver-\nsions of those crates you require. In this case, we'll specify the rand crate with\nthe semantic version specifier 0.3.14. Cargo understands Semantic Versioning\n(sometimes called SemVer), which is a standard for writing version numbers.\nThe number 0.3.14 is actually shorthand for \u20180.3.14, which means \u201cany ver-\nsion that has a public API compatible with version 0.3.14.\u201d\n\nNow, without changing any of the code, let\u2019s build the project, as shown\nin Listing 2-2.\n\n$ cargo build\n\nUpdating registry \u201chttps://github.com/rust-lang/crates.io-index~\nDownloading rand v0.3.14\nDownloading libe v0.2.14\n\nCompiling libe vo.2.14\n\nCompiling rand vo.3.14\n\nCompiling guessing game v0.1.0 (file:///projects/guessing game)\nFinished dev [unoptimized + debuginfo] target(s) in 1.50 secs\n\nListing 2-2: The output from running cargo build after adding the rand crate as a\ndependency\n\nYou may see different version numbers (but they will all be compatible\nwith the code, thanks to SemVer!), and the lines may be in a different order.\n\nNow that we have an external dependency, Cargo fetches the latest ver-\nsions of everything from the registry, which is a copy of data from Attps://\ncrates.io/. Crates.io is where people in the Rust ecosystem post their open\nsource Rust projects for others to use.\n\nAfter updating the registry, Cargo checks the [dependencies] section\nand downloads any crates you don\u2019t have yet. In this case, although we only\nlisted rand as a dependency, Cargo also grabbed a copy of libc, because rand\ndepends on libc to work. After downloading the crates, Rust compiles them\nand then compiles the project with the dependencies available.\n\nIf you immediately run cargo build again without making any changes,\nyou won't get any output aside from the Finished line. Cargo knows it has\nalready downloaded and compiled the dependencies, and you haven't\nchanged anything about them in your Cargo.tom file. Cargo also knows that\nyou haven't changed anything about your code, so it doesn\u2019t recompile that\neither. With nothing to do, it simply exits.\n\nIf you open the src/main.rs file, make a trivial change, and then save it\nand build again, you'll only see two lines of output:\n\n$ cargo build\nCompiling guessing game v0.1.0 (file:///projects/guessing game)\nFinished dev [unoptimized + debuginfo] target(s) in 1.50 secs\n\nThese lines show Cargo only updates the build with your tiny change\nto the src/main.rs file. Your dependencies haven't changed, so Cargo knows\nit can reuse what it has already downloaded and compiled for those. It just\nrebuilds your part of the code.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 2.1,
                        "section_name": "Ensuring Reproducible Builds with the Cargo.lock File",
                        "section_path": "./screenshots-images-2/chapter_2/section_10",
                        "images": [
                            "./screenshots-images-2/chapter_2/section_10/aa5dca8c-d19e-4b29-92da-caf5bc0a7a64.png",
                            "./screenshots-images-2/chapter_2/section_10/61696adc-4002-47f8-b8b1-1ef00b6e651e.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Ensuring Reproducible Builds with the Cargo.lock File\n\nCargo has a mechanism that ensures you can rebuild the same artifact\nevery time you or anyone else builds your code: Cargo will use only the ver-\nsions of the dependencies you specified until you indicate otherwise. For\nexample, what happens if next week version 0.3.15 of the rand crate comes\nout and contains an important bug fix but also contains a regression that\nwill break your code?\n\nThe answer to this problem is the Cargo.lock file, which was created the\nfirst time you ran cargo build and is now in your guessing_game directory.\nWhen you build a project for the first time, Cargo figures out all the ver-\nsions of the dependencies that fit the criteria and then writes them to the\nCargo.lock file. When you build your project in the future, Cargo will see\nthat the Cargo.lock file exists and use the versions specified there rather\n\nthan doing all the work of figuring out versions again. This lets you have a\nreproducible build automatically. In other words, your project will remain\nat 0.3.14 until you explicitly upgrade, thanks to the Cargo.lock file.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 2.11,
                        "section_name": "Updating a Crate to Get a New Version",
                        "section_path": "./screenshots-images-2/chapter_2/section_11",
                        "images": [
                            "./screenshots-images-2/chapter_2/section_11/4dfac659-cb02-472b-ab00-12fff3641291.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Cargo.tom!\n\nUpdating a Crate to Get a New Version\n\nWhen you do want to update a crate, Cargo provides another command,\nupdate, which will ignore the Cargo.lock file and figure out all the latest ver-\nsions that fit your specifications in Cargo.toml. If that works, Cargo will write\nthose versions to the Cargo.lock file.\n\nBut by default, Cargo will only look for versions greater than 0.3.0 and\nless than 0.4.0. If the rand crate has released two new versions, 0.3.15 and\n0.4.0, you would see the following if you ran cargo update:\n\n$ cargo update\nUpdating registry \u201chttps: //github.com/rust-lang/crates.io-index\u201d\nUpdating rand vO.3.14 -> vO.3.15\n\nAt this point, you would also notice a change in your Cargo.lock file noting\nthat the version of the rand crate you are now using is 0.3.15.\n\nIf you wanted to use rand version 0.4.0 or any version in the 0.4.x series,\nyou'd have to update the Cargo.toml file to look like this instead:\n\n[dependencies]\n\nrand = \"0.4.0\"\n\nThe next time you run cargo build, Cargo will update the registry of\ncrates available and reevaluate your rand requirements according to the\nnew version you have specified.\n\nThere's a lot more to say about Cargo and its ecosystem which we'll dis-\ncuss in Chapter 14, but for now, that\u2019s all you need to know. Cargo makes it\nvery easy to reuse libraries, so Rustaceans are able to write smaller projects\nthat are assembled from a number of packages.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 2.12,
                        "section_name": "Generating a Random Number",
                        "section_path": "./screenshots-images-2/chapter_2/section_12",
                        "images": [
                            "./screenshots-images-2/chapter_2/section_12/2adfeea6-68da-42e0-9aeb-380ad715096d.png",
                            "./screenshots-images-2/chapter_2/section_12/93d6ea70-4e3d-4390-ae6a-e98b131f4461.png",
                            "./screenshots-images-2/chapter_2/section_12/4a3555ec-80d2-4340-bab6-4319c6f7bfe2.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Generating a Random Number\n\nNow that you've added the rand crate to Cargo.toml, let\u2019s start using rand. The\nnext step is to update src/main.rs, as shown in Listing 2-3.\n\n@ use rand: :Rng;\nrintir Guess he number\n\u00a9 let secret_number = rand::thread_rng().gen_range(1, 101);\nprintln!(\"The secret number is: {}\", secret_number) ;\n\nprintin lease input\n\nListing 2-3: Adding code to generate a random number\n\nFirst, we add a use line: use rand: :Rng \u00ae. The Rng trait defines methods\nthat random number generators implement, and this trait must be in scope\nfor us to use those methods. Chapter 10 will cover traits in detail.\n\nNext, we're adding two more lines in the middle @. The rand: :thread_rng\nfunction will give us the particular random number generator that we're\ngoing to use: one that is local to the current thread of execution and seeded\nby the operating system. Then we call the gen_range method on the random\nnumber generator. This method is defined by the Rng trait that we brought\ninto scope with the use rand: :Rng statement. The gen_range method takes two\nnumbers as arguments and generates a random number between them. It\u2019s\ninclusive on the lower bound but exclusive on the upper bound, so we need\nto specify 1 and 101 to request a number between 1 and 100.\n\nYou won't just know which traits to use and which functions and methods to call\nfrom a crate. Instructions for using a crate are in each crate\u2019s documentation.\nAnother neat feature of Cargo is that you can run the cargo doc --open command,\nwhich will build documentation provided by all of your dependencies locally and\nopen it in your browser. If you're interested in other functionality in the rand crate,\nfor example, run cargo doc --open and click rand in the sidebar on the left.\n\nThe second line that we added to the middle of the code prints the\nsecret number. This is useful while we're developing the program to be able\nto test it, but we'll delete it from the final version. It\u2019s not much of a game if\nthe program prints the answer as soon as it starts!\n\nTry running the program a few times:\n\n$ cargo run\nCompiling guessing game v0.1.0 (file:///projects/guessing game)\nFinished dev [unoptimized + debuginfo] target(s) in 1.50 secs\nRunning ~target/debug/guessing game~\nGuess the number!\nThe secret number is: 7\nPlease input your guess.\n4\nYou guessed: 4\n$ cargo run\nRunning \u201ctarget/debug/guessing_game~\nGuess the number!\nThe secret number is: 83\n\nPlease input your guess.\n5\nYou guessed: 5\n\nYou should get different random numbers, and they should all be num-\nbers between 1 and 100. Great job!\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 2.13,
                        "section_name": "Comparing the Guess to the Secret Number",
                        "section_path": "./screenshots-images-2/chapter_2/section_13",
                        "images": [
                            "./screenshots-images-2/chapter_2/section_13/95d7ccd9-ba10-4307-a353-85c053a938e1.png",
                            "./screenshots-images-2/chapter_2/section_13/542768bd-aafd-45da-a2fe-04b0c37ec0be.png",
                            "./screenshots-images-2/chapter_2/section_13/e5ed7366-6d1f-4702-93b3-d953a179914c.png",
                            "./screenshots-images-2/chapter_2/section_13/b566cfb7-8538-4894-97b6-1ece4e7d6996.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Comparing the Guess to the Secret Number\n\nNow that we have user input and a random number, we can compare them.\nThat step is shown in Listing 2-4. Note that this code won't compile quite\nyet, as we will explain.\n\nsrc/main.rs ise std 0;\n\u00a9 use std::cmp::Ordering;\n\nise rand: :Rng;\n\nmatch\u00ae guess.cmp(&secret_number)\u00ae {\nOrdering::Less => println!(\"Too small!\"),\n\ni ireater => println!(\"Too big!\"),\n\nOrdering: :Equal => println!(\"You win!\"),\n\nListing 2-4: Handling the possible return values of comparing two numbers\n\nThe first new bit here is another use statement \u00ae, bringing a type called\nstd::cmp::Ordering into scope from the standard library. Like Result, Ordering\nis another enum, but the variants for Ordering are Less, Greater, and Equal.\nThese are the three outcomes that are possible when you compare two\nvalues.\n\nThen we add five new lines at the bottom that use the Ordering type. The\ncmp method \u00ae compares two values and can be called on anything that can\nbe compared. It takes a reference to whatever you want to compare with: here\nit\u2019s comparing the guess to the secret_number. Then it returns a variant of the\nOrdering enum we brought into scope with the use statement. We use a match\nexpression \u00ae to decide what to do next based on which variant of Ordering\nwas returned from the call to cmp with the values in guess and secret_number.\n\nA match expression is made up of arms. An arm consists of a pattern\nand the code that should be run if the value given to the beginning of\nthe match expression fits that arm\u2019s pattern. Rust takes the value given to\nmatch and looks through each arm\u2019s pattern in turn. The match construct\nand patterns are powerful features in Rust that let you express a variety\n\nsrc/main.rs\n\nof situations your code might encounter and make sure that you handle\nthem all. These features will be covered in detail in Chapter 6 and\nChapter 18, respectively.\n\nLet\u2019s walk through an example of what would happen with the match\nexpression used here. Say that the user has guessed 50 and the randomly\ngenerated secret number this time is 38. When the code compares 50 to 38,\nthe cmp method will return Ordering: :Greater, because 50 is greater than 38.\nThe match expression gets the Ordering: :Greater value and starts checking\neach arm\u2019s pattern. It looks at the first arm\u2019s pattern, Ordering: :Less, and sees\nthat the value Ordering: :Greater does not match Ordering: : Less, so it ignores\nthe code in that arm and moves to the next arm. The next arm\u2019s pattern,\nOrdering: :Greater, does match Ordering: :Greater! The associated code in that\narm will execute and print Too big! to the screen. The match expression ends\nbecause it has no need to look at the last arm in this scenario.\n\nHowever, the code in Listing 2-4 won't compile yet. Let\u2019s try it:\n\n$ cargo build\nCompiling guessing game v0.1.0 (file:///projects/guessing game)\nerror[E0308]: mismatched types\n--> src/main.rs:23:21\n|\n23 | match guess.cmp(&secret_number) {\nAAAAAAAAABAAAN expected struct \u201cstd::string: :String\u2019,\nfound integral variable\n|\n= note: expected type \u201c&std::string: :String\u2122\nnote: found type ~&{integer}~\n\nerror: aborting due to previous error\nCould not compile \u201cguessing game.\n\nThe core of the error states that there are mismatched types. Rust has\na strong, static type system. However, it also has type inference. When we\nwrote let mut guess = String: :new(), Rust was able to infer that guess should\nbe a String and didn\u2019t make us write the type. The secret_number, on the other\nhand, is a number type. A few number types can have a value between 1 and\n100: 132, a 32-bit number; u32, an unsigned 32-bit number; i64, a 64-bit num-\nber; as well as others. Rust defaults to an i32, which is the type of secret_number\nunless you add type information elsewhere that would cause Rust to infer a\ndifferent numerical type. The reason for the error here is that Rust cannot\ncompare a string and a number type.\n\nUltimately, we want to convert the String the program reads as input\ninto a real number type so we can compare it numerically to the secret\nnumber. We can do that by adding the following two lines to the main\nfunction body:\n\nio: :stdir ad_line(&mut gue\n\n) read line\")\n\nlet guess: u32 = guess.trim().parse()\n-expect(\"Please type a number!\");\n\nWe create a variable named guess. But wait, doesn\u2019t the program\nalready have a variable named guess? It does, but Rust allows us to shadow\nthe previous value of guess with a new one. This feature is often used in\nsituations in which you want to convert a value from one type to another\ntype. Shadowing lets us reuse the guess variable name rather than forcing\nus to create two unique variables, such as guess_str and guess for example.\n(Chapter 3 covers shadowing in more detail.)\n\nWe bind guess to the expression guess.trim().parse(). The guess in the\nexpression refers to the original guess that was a String with the input in it.\nThe trim method on a String instance will eliminate any whitespace at the\nbeginning and end. Although u32 can contain only numerical characters,\nthe user must press ENTER to satisfy read_line. When the user presses ENTER,\na newline character is added to the string. For example, if the user types 5\nand presses ENTER, guess looks like this: 5\\n. The \\n represents \u201cnewline,\u201d the\nresult of pressing ENTER. The trim method eliminates \\n, resulting in just 5.\n\nThe parse method on strings parses a string into some kind of number.\nBecause this method can parse a variety of number types, we need to tell\nRust the exact number type we want by using let guess: u32. The colon (:)\nafter guess tells Rust we'll annotate the variable\u2019s type. Rust has a few built-\nin number types; the u32 seen here is an unsigned, 32-bit integer. It\u2019s a good\ndefault choice for a small positive number. You'll learn about other number\ntypes in Chapter 3. Additionally, the u32 annotation in this example pro-\ngram and the comparison with secret_number mean that Rust will infer that\nsecret_number should be a u32 type as well. So now the comparison will be\nbetween two values of the same type!\n\nThe call to parse could easily cause an error. If, for example, the string\ncontained A%%, there would be no way to convert that to a number. Because\nit might fail, the parse method returns a Result type, much as the read_line\nmethod does (discussed in \u201cHandling Potential Failure with the Result\nType\u201d on page 17). We'll treat this Result the same way by using the expect\nmethod again. If parse returns an Err Result variant because it couldn't cre-\nate a number from the string, the expect call will crash the game and print\nthe message we give it. If parse can successfully convert the string to a num-\nber, it will return the 0k variant of Result, and expect will return the number\nthat we want from the 0k value.\n\nLet\u2019s run the program now!\n\n$ cargo run\nCompiling guessing game v0.1.0 (file:///projects/guessing game)\nFinished dev[unoptimized + debuginfo] target(s) in 1.50 secs\nRunning \u201ctarget/debug/guessing game\u201d\nGuess the number!\nThe secret number is: 58\nPlease input your guess.\n76\nYou guessed: 76\nToo big!\n\nNice! Even though spaces were added before the guess, the program still\nfigured out that the user guessed 76. Run the program a few times to verify\nthe different behavior with different kinds of input: guess the number cor-\nrectly, guess a number that is too high, and guess a number that is too low.\n\nWe have most of the game working now, but the user can make only\none guess. Let\u2019s change that by adding a loop!\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 2.14,
                        "section_name": "Allowing Multiple Guesses with Looping",
                        "section_path": "./screenshots-images-2/chapter_2/section_14",
                        "images": [
                            "./screenshots-images-2/chapter_2/section_14/5192c44f-587b-4849-8a14-5e2a45686a1a.png",
                            "./screenshots-images-2/chapter_2/section_14/eab8818f-0bb5-4132-bc87-8efabef15333.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Allowing Multiple Guesses with Looping\n\nThe loop keyword creates an infinite loop. We'll add that now to give users\nmore chances at guessing the number:\n\nsre/main.rs t\n\nAs you can see, we've moved everything into a loop from the guess input\nprompt onward. Be sure to indent the lines inside the loop another four\nspaces each and run the program again. Notice that there is a new problem\nbecause the program is doing exactly what we told it to do: ask for another\nguess forever! It doesn\u2019t seem like the user can quit!\n\nThe user could always interrupt the program by using the keyboard\nshortcut CTRL-C, But there\u2019s another way to escape this insatiable monster,\nas mentioned in the parse discussion in \u201cComparing the Guess to the Secret\n\nNumber\u201d on page 23: if the user enters a non-number answer, the pro-\ngram will crash. The user can take advantage of that in order to quit, as\nshown here:\n\n$ cargo run\nCompiling guessing game v0.1.0 (file:///projects/guessing game)\nFinished dev [unoptimized + debuginfo] target(s) in 1.50 secs\n\nRunning \u201ctarget/debug/guessing game\u201d\n\nGuess the number!\n\nThe secret number is: 59\n\nPlease input your guess.\n\n45\n\nYou guessed: 45\n\nToo small!\n\nPlease input your guess.\n\nYou guessed: 60\n\nToo big!\n\nPlease input your guess.\n\n59\n\nYou guessed: 59\n\nYou win!\n\nPlease input your guess.\n\nquit\n\nthread 'main' panicked at \u2018Please type a number!: ParseIntError { kind:\nInvalidDigit }', src/libcore/result.rs:785\n\nnote: Run with ~RUST_BACKTRACE=1\u00b0 for a backtrace.\n\nTyping quit actually quits the game, but so will any other non-number\ninput. However, this is suboptimal to say the least. We want the game to\nautomatically stop when the correct number is guessed.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 2.15,
                        "section_name": "Quitting After a Correct Guess",
                        "section_path": "./screenshots-images-2/chapter_2/section_15",
                        "images": [
                            "./screenshots-images-2/chapter_2/section_15/d591e1b2-1b4b-49bc-beac-b72ea92773bd.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Quitting After a Correct Guess\n\nLet's program the game to quit when the user wins by adding a break\nstatement:\n\nsrc/main.rs\n\n\\rdering: :Les rintln! (\"Toc all!\")\n\nOrdering: :Greater pr\n\nOrdering: :Equal => {\nprintln!(\"You win!\");\nbreak;\n\nAdding the break line after You win! makes the program exit the loop\nwhen the user guesses the secret number correctly. Exiting the loop also\nmeans exiting the program, because the loop is the last part of main.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 2.16,
                        "section_name": "Handling Invalid Input",
                        "section_path": "./screenshots-images-2/chapter_2/section_16",
                        "images": [
                            "./screenshots-images-2/chapter_2/section_16/97aac79b-a7bc-4d1f-898e-c72ee2da88c7.png",
                            "./screenshots-images-2/chapter_2/section_16/145a4580-1ab0-4a9f-b664-e5d9879eb731.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nHandling Invalid Input\n\nTo further refine the game\u2019s behavior, rather than crashing the program\nwhen the user inputs a non-number, let\u2019s make the game ignore a non-\nnumber so the user can continue guessing. We can do that by altering the\nline where guess is converted from a String to a u32, as shown in Listing 2-5.\n\nio: :stdin(\n\nlet guess: u32 = match guess.trim().parse() {\nOk(num) => num,\nErr(_) => continue,\n\nA\n\nListing 2-5: Ignoring a non-number guess and asking for another guess instead of crash-\ning the program\n\nSwitching from an expect call to a match expression is how you generally\nmove from crashing on an error to handling the error. Remember that parse\nreturns a Result type and Result is an enum that has the variants Ok or Err.\nWe're using a match expression here, as we did with the Ordering result of the\ncmp method.\n\nIf parse is able to successfully turn the string into a number, it will\nreturn an 0k value that contains the resulting number. That 0k value will\nmatch the first arm's pattern, and the match expression will just return the\nnum value that parse produced and put inside the 0k value. That number will\nend up right where we want it in the new guess variable we're creating.\n\nIf parse is not able to turn the string into a number, it will return an Err\nvalue that contains more information about the error. The Err value does\nnot match the 0k(num) pattern in the first match arm, but it does match the\nErr(_) pattern in the second arm. The underscore, _, is a catchall value; in\nthis example, we're saying we want to match all Err values, no matter what\ninformation they have inside them. So the program will execute the second\narm\u2019s code, continue, which tells the program to go to the next iteration of\nthe loop and ask for another guess. So, effectively, the program ignores all\nerrors that parse might encounter!\n\nNow everything in the program should work as expected. Let's try it:\n\n$ cargo run\nCompiling guessing game v0.1.0 (file:///projects/guessing game)\nFinished dev [unoptimized + debuginfo] target(s) in 1.50 secs\nRunning \u201ctarget/debug/guessing game\u201d\nGuess the number!\nThe secret number is: 61\nPlease input your guess.\n\nsrc/main.rs\n\n10\n\nYou guessed: 10\n\nToo small!\n\nPlease input your guess.\n99\n\nYou guessed: 99\n\nToo big!\n\nPlease input your guess.\nfoo\n\nPlease input your guess.\n61\n\nYou guessed: 61\n\nYou win!\n\nAwesome! With one tiny final tweak, we will finish the guessing game.\nRecall that the program is still printing the secret number. That worked\nwell for testing, but it ruins the game. Let's delete the print1n! that outputs\n\nthe secret number. Listing 2-6 shows the final code.\n\nuse std::io;\nuse std::cmp: :Ordering;\nuse rand: :Rng;\n\nfn main() {\nprintln!(\"Guess the number!\");\n\nlet secret_number = rand::thread_rng().gen_range(1, 101);\n\nloop {\nprintln!(\"Please input your guess.\");\n\nlet mut guess = String: :new();\n\nio::stdin().read_line(&mut guess)\n-expect(\"Failed to read line\");\n\nlet guess: u32 = match guess.trim().parse() {\nOk(num) => num,\nErr(_) => continue,\n\nds\nprintln!(\"You guessed: {}\", guess);\n\nmatch guess.cmp(&secret_number) {\nOrdering::Less => println!(\"Too small!\"),\nOrdering: :Greater => println! (\"Too big!\"),\nOrdering: :Equal => {\nprintln!(\"You win!\");\nbreak;\n\n}\nListing 2-6: Complete guessing game code\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 2.17,
                        "section_name": "Summary",
                        "section_path": "./screenshots-images-2/chapter_2/section_17",
                        "images": [
                            "./screenshots-images-2/chapter_2/section_17/8dd6a8aa-d12e-4981-8549-d9aea6004da3.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Summary\n\nAt this point, you've successfully built the guessing game. Congratulations!\n\nThis project was a hands-on way to introduce you to many new Rust\nconcepts: let, match, methods, associated functions, the use of external\ncrates, and more. In the next few chapters, you'll learn about these concepts\nin more detail. Chapter 3 covers concepts that most programming languages\nhave, such as variables, data types, and functions, and shows how to use them\nin Rust. Chapter 4 explores ownership, a feature that makes Rust different\nfrom other languages. Chapter 5 discusses structs and method syntax, and\nChapter 6 explains how enums work.\n",
                        "extracted-code": ""
                    }
                ]
            },
            {
                "chapter_id": 3,
                "chapter_name": "COMMON PROGRAMMING\nCONCEPTS",
                "chapter_path": "./screenshots-images-2/chapter_3",
                "sections": [
                    {
                        "section_id": 3.1,
                        "section_name": "COMMON PROGRAMMING\nCONCEPTS",
                        "section_path": "./screenshots-images-2/chapter_3/section_1",
                        "images": [
                            "./screenshots-images-2/chapter_3/section_1/8571780a-01f3-4ae8-a08e-863b8a1ed94d.png",
                            "./screenshots-images-2/chapter_3/section_1/0b049138-8d73-417e-b53c-f66a94803032.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "This chapter covers concepts that appear in\nalmost every programming language and\nhow they work in Rust. Many programming\nlanguages have much in common at their core.\nNone of the concepts presented in this chapter are\nunique to Rust, but we\u2019ll discuss them in the context\nof Rust and explain the conventions around using\n\nthese concepts.\n\nSpecifically, you'll learn about variables, basic types, functions, com-\nments, and control flow. These foundations will be in every Rust program,\nand learning them early will give you a strong core to start from.\n\n\nKEYWORDS\n\nThe Rust language has a set of keywords that are reserved for use by the lan-\nguage only, much as in other languages. Keep in mind that you cannot use\nthese words as names of variables or functions. Most of the keywords have\n\nspecial meanings, and you'll be using them to do various tasks in your Rust\nprograms; a few have no current functionality associated with them but have\nbeen reserved for functionality that might be added to Rust in the future. You\ncan find a list of the keywords in Appendix A.\n\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 3.2,
                        "section_name": "Variables and Mutability",
                        "section_path": "./screenshots-images-2/chapter_3/section_2",
                        "images": [
                            "./screenshots-images-2/chapter_3/section_2/6ab5b100-d62a-4708-965a-fb545922a865.png",
                            "./screenshots-images-2/chapter_3/section_2/297ca8a3-4b29-4593-88bf-b701cc3e3d83.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Variables and Mutability\n\nsrc/main.rs\n\nAs mentioned in Chapter 2, by default variables are immutable. This is\none of many nudges Rust gives you to write your code in a way that takes\nadvantage of the safety and easy concurrency that Rust offers. However,\nyou still have the option to make your variables mutable. Let's explore how\nand why Rust encourages you to favor immutability and why sometimes you\nmight want to opt out.\n\nWhen a variable is immutable, once a value is bound to a name, you\ncan\u2019t change that value. To illustrate this, let\u2019s generate a new project\ncalled variables in your projects directory by using cargo new variables.\n\nThen, in your new variables directory, open src/main.rs and replace its\ncode with the following code that won't compile just yet:\n\nfn main() {\nlet x = 5;\nprintln!(\"The value of x is: {}\", x);\nx = 65\nprintln!(\"The value of x is: {}\", x);\n\nSave and run the program using cargo run. You should receive an error\nmessage, as shown in this output:\n\nerror[E0384]: cannot assign twice to immutable variable \u201cx\n--> src/main.rs:4:5\n\n2/ let x = 5;\n\n| - first assignment to ~x\n3 | println!(\"The value of x is: {}\", x);\n4| x = 6;\n\n|\n\n3\nasa cannot assign twice to immutable variable\n\nThis example shows how the compiler helps you find errors in your\nprograms. Even though compiler errors can be frustrating, they only mean\n\nsrc/main.rs\n\nyour program isn\u2019t safely doing what you want it to do yet; they do not\nmean that you're not a good programmer! Experienced Rustaceans still\nget compiler errors.\n\nThe error message indicates that the cause of the error is that you\ncannot assign twice to immutable variable x, because you tried to assign a\nsecond value to the immutable x variable.\n\nIt\u2019s important that we get compile-time errors when we attempt to change\na value that we previously designated as immutable because this very situation\ncan lead to bugs. If one part of our code operates on the assumption that a\nvalue will never change and another part of our code changes that value, it\u2019s\npossible that the first part of the code won't do what it was designed to do.\nThe cause of this kind of bug can be difficult to track down after the fact,\nespecially when the second piece of code changes the value only sometimes.\n\nIn Rust, the compiler guarantees that when you state that a value won't\nchange, it really won\u2019t change. That means that when you're reading and\nwriting code, you don\u2019t have to keep track of how and where a value might\nchange. Your code is thus easier to reason through.\n\nBut mutability can be very useful. Variables are immutable only by\ndefault; as you did in Chapter 2, you can make them mutable by adding\nmut in front of the variable name. In addition to allowing this value to\nchange, mut conveys intent to future readers of the code by indicating\nthat other parts of the code will be changing this variable value.\n\nFor example, let\u2019s change sr\u00a2/main.rs to the following:\n\nfn main() {\nlet mut x = 5;\n\nprintln!(\"The value of x is: {}\", x)\n\nWhen we run the program now, we get this:\n\n$ cargo run\nCompiling variables v0.1.0 (file:///projects/variables)\nFinished dev [unoptimized + debuginfo] target(s) in 1.50 secs\nRunning ~target/debug/variables~\nThe value of x is: 5\nThe value of x is: 6\n\nWe're allowed to change the value that x binds to from 5 to 6 when mut is\nused. In some cases, you'll want to make a variable mutable because it makes\nthe code more convenient to write than if it had only immutable variables.\n\nThere are multiple trade-offs to consider in addition to the prevention\nof bugs. For example, in cases where you're using large data structures,\nmutating an instance in place may be faster than copying and returning\nnewly allocated instances. With smaller data structures, creating new\ninstances and writing in a more functional programming style may be\neasier to think through, so lower performance might be a worthwhile\npenalty for gaining that clarity.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 3.3,
                        "section_name": "Differences Between Variables and Constants",
                        "section_path": "./screenshots-images-2/chapter_3/section_3",
                        "images": [
                            "./screenshots-images-2/chapter_3/section_3/24cfe480-1e17-4381-bf69-8039c17204b8.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Differences Between Variables and Constants\n\nBeing unable to change the value of a variable might have reminded you of\nanother programming concept that most other languages have: constants.\nLike immutable variables, constants are values that are bound to a name and\nare not allowed to change, but there are a few differences between constants\nand variables.\n\nFirst, you aren't allowed to use mut with constants. Constants aren\u2019t just\nimmutable by default\u2014they\u2019re always immutable.\n\nYou declare constants using the const keyword instead of the let keyword,\nand the type of the value must be annotated. We're about to cover types and\ntype annotations in \u201cData Types\u201d on page 36, so don\u2019t worry about the\ndetails right now. Just know that you must always annotate the type.\n\nConstants can be declared in any scope, including the global scope,\nwhich makes them useful for values that many parts of the code need to\nknow about.\n\nThe last difference is that constants may be set only to a constant expres-\nsion, not to the result of a function call or any other value that could only be\ncomputed at runtime.\n\nHere\u2019s an example of a constant declaration where the constant\u2019s name\nis MAX_POINTS and its value is set to 100,000. (Rust\u2019s naming convention for\nconstants is to use all uppercase with underscores between words, and\nunderscores can be inserted in numeric literals to improve readability):\n\nconst MAX_POINTS: u32 = 100 000;\n\nConstants are valid for the entire time a program runs, within the\nscope they were declared in, making them a useful choice for values in\nyour application domain that multiple parts of the program might need\nto know about, such as the maximum number of points any player of a\ngame is allowed to earn or the speed of light.\n\nNaming hardcoded values used throughout your program as constants\nis useful in conveying the meaning of that value to future maintainers of\nthe code. It also helps to have only one place in your code you would need\nto change if the hardcoded value needed to be updated in the future.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 3.4,
                        "section_name": "Shadowing",
                        "section_path": "./screenshots-images-2/chapter_3/section_4",
                        "images": [
                            "./screenshots-images-2/chapter_3/section_4/ba43c90c-5d48-4859-ba9c-10a6f6ca34b6.png",
                            "./screenshots-images-2/chapter_3/section_4/0b823d70-c76a-4955-a627-ea26d73a732e.png",
                            "./screenshots-images-2/chapter_3/section_4/5dadd9c2-907b-4c11-8452-1433a0f7444e.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nShadowing\n\nAs you saw in the guessing game tutorial in \u201cComparing the Guess to the\nSecret Number\u201d on page 23, you can declare a new variable with the same\nname as a previous variable, and the new variable shadows the previous vari-\nable. Rustaceans say that the first variable is shadowed by the second, which\nmeans that the second variable\u2019s value is what appears when the variable\n\nis used. We can shadow a variable by using the same variable\u2019s name and\nrepeating the use of the let keyword as follows:\n\nfn main() {\n\nlet x = 5;\n\nlet x\n\nx +1;\nlet x = x * 2;\n\nprintln!(\"The value of x is: {}\", x);\n\nThis program first binds x to a value of 5. Then it shadows x by repeating\nlet x =, taking the original value and adding 1 so the value of x is then 6. The\nthird let statement also shadows x, multiplying the previous value by 2 to give\nxa final value of 12. When we run this program, it will output the following:\n\n$ cargo run\nCompiling variables v0.1.0 (file:///projects/variables)\nFinished dev [unoptimized + debuginfo] target(s) in 1.50 secs\nRunning \u201ctarget/debug/variables~\nThe value of x is: 12\n\nShadowing is different from marking a variable as mut, because we'll get\na compile-time error if we accidentally try to reassign to this variable without\nusing the let keyword. By using let, we can perform a few transformations on\na value but have the variable be immutable after those transformations have\nbeen completed.\n\nThe other difference between mut and shadowing is that because we're\neffectively creating a new variable when we use the let keyword again, we\ncan change the type of the value but reuse the same name. For example, say\nour program asks a user to show how many spaces they want between some\ntext by inputting space characters, but we really want to store that input as a\nnumber:\nlet spaces =\" \";\nlet spaces\n\n;\nspaces. len();\n\nThis construct is allowed because the first spaces variable is a string type\nand the second spaces variable, which is a brand-new variable that happens\nto have the same name as the first one, is a number type. Shadowing thus\nspares us from having to come up with different names, such as spaces_str\nand spaces_num; instead, we can reuse the simpler spaces name. However, if\nwe try to use mut for this, as shown here, we'll get a compile-time error:\n\nlet mut spaces = 3\nspaces = spaces. len();\n\nThe error says we're not allowed to mutate a variable\u2019s type:\n\nerror[E\u00a30308]: mismatched types\n--> src/main.rs:3:14\n\n|\nspaces = spaces. len();\n\n3 |\n| AAMAADMAAOAK expected &str, found usize\n|\n\n= note: expected type ~astr\nfound type \u201cusize\n\nNow that we've explored how variables work, let's look at more data\ntypes they can have.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 3.5,
                        "section_name": "Data Types",
                        "section_path": "./screenshots-images-2/chapter_3/section_5",
                        "images": [
                            "./screenshots-images-2/chapter_3/section_5/b21d7250-5638-4445-afe6-0a672d1d91c0.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Data Types\n\nEvery value in Rust is of a certain data type, which tells Rust what kind of\ndata is being specified so it knows how to work with that data. We'll look at\ntwo data type subsets: scalar and compound.\n\nKeep in mind that Rust is a statically typed language, which means\nthat it must know the types of all variables at compile time. The compiler\ncan usually infer what type we want to use based on the value and how we\nuse it. In cases when many types are possible, such as when we converted a\nString to a numeric type using parse in \u201cComparing the Guess to the Secret\nNumber\u201d on page 23, we must add a type annotation, like this:\n\nlet guess: u32 = \"42\".parse().expect(\"Not a number!\");\n\nIf we don\u2019t add the type annotation here, Rust will display the following\nerror, which means the compiler needs more information from us to know\nwhich type we want to use:\n\nerror[E0282]: type annotations needed\n--> src/main.rs:2:9\n\n2 let guess = \"42\".parse().expect(\"Not a number!\");\n\n|\n\n| AAAAA\n\n| |\n\n| cannot infer type for ~_~\n\n| consider giving \u201cguess\u201d a type\n\nYou'll see different type annotations for other data types.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 3.6,
                        "section_name": "Scalar Types",
                        "section_path": "./screenshots-images-2/chapter_3/section_6",
                        "images": [
                            "./screenshots-images-2/chapter_3/section_6/4a1c37c1-5226-4f62-a67a-7e0d049d9ce9.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Scalar Types\n\nA scalar type represents a single value. Rust has four primary scalar types:\nintegers, floating-point numbers, Booleans, and characters. You may recog-\nnize these from other programming languages. Let\u2019s jump into how they\nwork in Rust.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 3.7,
                        "section_name": "Integer Types",
                        "section_path": "./screenshots-images-2/chapter_3/section_7",
                        "images": [
                            "./screenshots-images-2/chapter_3/section_7/504c800b-acfe-46b1-935b-b12d202d6fd0.png",
                            "./screenshots-images-2/chapter_3/section_7/8c2883e1-458e-4ad4-ad32-31bc05f677d4.png",
                            "./screenshots-images-2/chapter_3/section_7/a25e013a-e9d0-4fe3-872a-a99a7554841a.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Integer Types\n\nAn integer is a number without a fractional component. We used one integer\ntype in Chapter 2, the u32 type. This type declaration indicates that the value\nit\u2019s associated with should be an unsigned integer (signed integer types start\n\nwith i, instead of u) that takes up 32 bits of space. Table 3-1 shows the built-in\ninteger types in Rust. Each variant in the Signed and Unsigned columns (for\nexample, i16) can be used to declare the type of an integer value.\n\nTable 3-1: Integer Types in Rust\n\nLength Signed Unsigned\n\n8-bit i8 us\n16-bit i16 u16\n32-bit 132 u32\n64-bit 164 u64\n128-bit i128 u128\narch isize usize\n\nEach variant can be either signed or unsigned and has an explicit\nsize. Signed and unsigned refer to whether it\u2019s possible for the number to be\nnegative or positive\u2014in other words, whether the number needs to have a\nsign with it (signed) or whether it will only ever be positive and can therefore\nbe represented without a sign (unsigned). It\u2019s like writing numbers on paper:\nwhen the sign matters, a number is shown with a plus sign or a minus sign;\nhowever, when it\u2019s safe to assume the number is positive, it\u2019s shown with no\nsign. Signed numbers are stored using two's complement representation (if\nyou're unsure what this is, you can search for it online; an explanation is\noutside the scope of this book).\n\nEach signed variant can store numbers from =(2\"\u2014 B) to 2\"! - 1 inclu-\nsive, where n is the number of bits that variant uses. So an i8 can store num-\nbers from = -(2\u201d ) to 2\u2019- 1, which equals -128 to 127. Unsigned variants can\nstore numbers from 0 to 2\u201d ~ 1, so a u8 can store numbers from 0 to 2\u00b0 = 1,\nwhich equals 0 to 255.\n\nAdditionally, the isize and usize types depend on the kind of computer\nyour program is running on: 64 bits if you're on a 64-bit architecture and\n32 bits if you\u2019re on a 32-bit architecture.\n\nYou can write integer literals in any of the forms shown in Table 3-2. Note\nthat all number literals except the byte literal allow a type suffix, such as 57u8,\nand _ as a visual separator, such as 1_000.\n\nTable 3-2: Integer Literals in Rust\nNumber literals Example\n\nDecimal 98_222\n\nHex Oxff\n\nOctal 0077\n\nBinary 0b1111_0000\n\nByte (u8 only) b'A\u2019\n\nSo how do you know which type of integer to use? If you're unsure, Rust\u2019s\ndefaults are generally good choices, and integer types default to 32: this type\nis generally the fastest, even on 64-bit systems. The primary situation in which\nyou'd use isize or usize is when indexing some sort of collection.\n\nINTEGER OVERFLOW\n\nLet's say you have a variable of type u8 that can hold values between 0 and\n255. If you try to change the variable to a value outside of that range, such\nas 256, integer overflow will occur. Rust has some interesting rules involving\nthis behavior. When you're compiling in debug mode, Rust includes checks\nfor integer overflow that cause your program to panic at runtime if this behav-\nior occurs. Rust uses the term panicking when a program exits with an error;\nwe'll discuss panics in more depth in \u201cUnrecoverable Errors with panic!\u201d on\npage 152.\n\nWhen you're compiling in release mode with the --release flag, Rust does\nnot include checks for integer overflow that cause panics. Instead, if overflow\noccurs, Rust performs two's complement wrapping. In short, values greater than\nthe maximum value the type can hold \u201cwrap around\u201d to the minimum of the\nvalues the type can hold. In the case of a u8, 256 becomes 0, 257 becomes 1,\nand so on. The program won't panic, but the variable will have a value that\nprobably isn\u2019t what you were expecting it to have. Relying on integer overflows\nwrapping behavior is considered an error. If you want to wrap explicitly, you\ncan use the standard library type Wrapping.\n\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 3.8,
                        "section_name": "Floating-Point Types",
                        "section_path": "./screenshots-images-2/chapter_3/section_8",
                        "images": [
                            "./screenshots-images-2/chapter_3/section_8/07847643-2495-410d-b6ec-eeac66d496f1.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nFloating-Point Types\nRust also has two primitive types for floating-point numbers, which are\nnumbers with decimal points. Rust\u2019s floating-point types are f32 and f64,\nwhich are 32 bits and 64 bits in size, respectively. The default type is f64\nbecause on modern CPUs it\u2019s roughly the same speed as \u00a332 but is capable\nof more precision.\n\nHere\u2019s an example that shows floating-point numbers in action:\n\nfn main() {\n\nlet x = 2.0; // f64\n\nlet y: \u00a332 = 3.0; // 32\n\nFloating-point numbers are represented according to the IEEE-754 stan-\ndard. The \u00a332 type is a single-precision float, and f64 has double precision.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 3.9,
                        "section_name": "Numeric Operations",
                        "section_path": "./screenshots-images-2/chapter_3/section_9",
                        "images": [
                            "./screenshots-images-2/chapter_3/section_9/bbca6e73-3cc8-46a2-865c-a187abf3f926.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nNumeric Operations\n\nRust supports the basic mathematical operations you'd expect for all of the\nnumber types: addition, subtraction, multiplication, division, and remainder.\nThe following code shows how you'd use each one in a let statement:\n\nfn main() {\n// addition\nlet sum = 5 + 10;\n\n// subtraction\nlet difference = 95.5 - 4.3;\n\n// multiplication\nlet product = 4 * 30;\n\n// division\nlet quotient = 56.7 / 32.2;\n\n// remainder\nlet remainder = 43 % 5;\n\nEach expression in these statements uses a mathematical operator and\nevaluates to a single value, which is then bound to a variable. Appendix B\ncontains a list of all operators that Rust provides.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 3.1,
                        "section_name": "The Boolean Type",
                        "section_path": "./screenshots-images-2/chapter_3/section_10",
                        "images": [
                            "./screenshots-images-2/chapter_3/section_10/860876fa-de90-4a4c-9add-ea7bb9e82740.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "The Boolean Type\n\nAs in most other programming languages, a Boolean type in Rust has two\npossible values: true and false. Booleans are one byte in size. The Boolean\ntype in Rust is specified using bool. For example:\n\nsrc/main.rs fn main() {\nlet t = true;\n\nlet f: bool = false; // with explicit type annotation\n\nThe main way to use Boolean values is through conditionals, such as an\nif expression. We'll cover how if expressions work in Rust in \u201cControl Flow\u201d\non page 49.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 3.11,
                        "section_name": "The Character Type",
                        "section_path": "./screenshots-images-2/chapter_3/section_11",
                        "images": [
                            "./screenshots-images-2/chapter_3/section_11/3f77f516-1ebe-490e-99bc-f6b30ed868ac.png",
                            "./screenshots-images-2/chapter_3/section_11/c7eea11c-e831-4e78-8d8a-7790c63148de.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "The Character Type\n\nSo far we've worked only with numbers, but Rust supports letters too. Rust\u2019s\nchar type is the language\u2019s most primitive alphabetic type, and the follow-\ning code shows one way to use it. (Note that char literals are specified with\nsingle quotes, as opposed to string literals, which use double quotes.)\n\nsrc/main.rs fn main() {\n\nlet c = '2';\nlet z = '2';\nlet heart_eyed_cat = '&';\n\nRust\u2019s char type is four bytes in size and represents a Unicode Scalar\nValue, which means it can represent a lot more than just ASCII. Accented\nletters; Chinese, Japanese, and Korean characters; emoji; and zero-width\nspaces are all valid char values in Rust. Unicode Scalar Values range from\nU+0000 to U+D7FF and U+E000 to U+10FFFF inclusive. However, a \u201ccharacter\u201d isn\u2019t\nreally a concept in Unicode, so your human intuition for what a \u201ccharacter\u201d\nis may not match up with what a char is in Rust. We'll discuss this topic in\ndetail in \u201cStoring UTF-8 Encoded Text with Strings\u201d on page 137.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 3.12,
                        "section_name": "Compound Types",
                        "section_path": "./screenshots-images-2/chapter_3/section_12",
                        "images": [
                            "./screenshots-images-2/chapter_3/section_12/1d4747d6-abeb-4d43-901a-ad783c80a1b2.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Compound Types\n\nCompound types can group multiple values into one type. Rust has two\nprimitive compound types: tuples and arrays.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 3.13,
                        "section_name": "The Tuple Type",
                        "section_path": "./screenshots-images-2/chapter_3/section_13",
                        "images": [
                            "./screenshots-images-2/chapter_3/section_13/d1d0076f-f396-4a83-b1fd-e4592766df4f.png",
                            "./screenshots-images-2/chapter_3/section_13/f3da1651-9bc2-410a-9d06-8516a869f2a4.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nsrc/main.rs\n\nThe Tuple Type\n\nA tuple is a general way of grouping together some number of other values\nwith a variety of types into one compound type. Tuples have a fixed length:\nonce declared, they cannot grow or shrink in size.\n\nWe create a tuple by writing a comma-separated list of values inside\nparentheses. Each position in the tuple has a type, and the types of the dif-\nferent values in the tuple don\u2019t have to be the same. We've added optional\ntype annotations in this example:\n\nfn main() {\nlet tup: (132, f64, u8) = (500, 6.4, 1);\n\nThe variable tup binds to the entire tuple, because a tuple is considered\na single compound element. To get the individual values out of a tuple, we\ncan use pattern matching to destructure a tuple value, like this:\n\nfn main() {\nlet tup = (500, 6.4, 1);\n\nlet (x, yy 2) = tup;\n\nprintln!(\"The value of y is: {}\", y);\n\nThis program first creates a tuple and binds it to the variable tup. It then\nuses a pattern with let to take tup and turn it into three separate variables,\n\nx, y, and z. This is called destructuring, because it breaks the single tuple into\nthree parts. Finally, the program prints the value of y, which is 6.4.\n\nIn addition to destructuring through pattern matching, we can access\na tuple element directly by using a period (.) followed by the index of the\nvalue we want to access. For example:\n\nsrc/main.rs fn main() {\nlet x: (132, \u00a364, u8) = (S00, 6.4, 1);\n\nlet five_hundred = x.0;\nlet six_point_four = x.1;\n\nlet one = x.2;\n\nThis program creates a tuple, x, and then makes new variables for each\nelement by using their index. As with most programming languages, the\nfirst index in a tuple is 0.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 3.14,
                        "section_name": "The Array Type",
                        "section_path": "./screenshots-images-2/chapter_3/section_14",
                        "images": [
                            "./screenshots-images-2/chapter_3/section_14/8cf36879-58b0-4c68-ba2d-8b7c2ed34f2c.png",
                            "./screenshots-images-2/chapter_3/section_14/34993391-7a92-483f-903c-8f0f33893d1b.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nThe Array Type\n\nAnother way to have a collection of multiple values is with an array. Unlike a\ntuple, every element of an array must have the same type. Arrays in Rust are\ndifferent from arrays in some other languages because arrays in Rust have a\nfixed length, like tuples.\n\nIn Rust, the values going into an array are written as a comma-separated\nlist inside square brackets:\n\nfn main() {\n\nlet a = [1, 2, 3, 4, 5];\n}\n\nArrays are useful when you want your data allocated on the stack rather\nthan the heap (we will discuss the stack and the heap more in Chapter 4)\nor when you want to ensure you always have a fixed number of elements.\nAn array isn\u2019t as flexible as the vector type, though. A vector is a similar\ncollection type provided by the standard library that is allowed to grow\nor shrink in size. If you\u2019re unsure whether to use an array or a vector, you\nshould probably use a vector. Chapter 8 discusses vectors in more detail.\n\nAn example of when you might want to use an array rather than a\nvector is in a program that needs to know the names of the months of the\nyear. It\u2019s very unlikely that such a program will need to add or remove\nmonths, so you can use an array because you know it will always contain\n12 items:\n\nlet months = [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\",\n\"August\", \"September\", \"October\", \"November\", \"December\"];\n\n\nYou would write an array\u2019s type by using square brackets, and within\nthe brackets include the type of each element, a semicolon, and then the\nnumber of elements in the array, like so:\n\nlet a: [132; 5] = [1, 2, 3, 4, 5];\n\nHere, i32 is the type of each element. After the semicolon, the number\n5 indicates the element contains five items.\n\nWriting an array\u2019s type this way looks similar to an alternative syntax for\ninitializing an array: if you want to create an array that contains the same\nvalue for each element, you can specify the initial value, followed by a semi-\ncolon, and then the length of the array in square brackets, as shown here:\n\nlet a = [35 5];\nThe array named a will contain 5 elements that will all be set to the\n\nvalue 3 initially. This is the same as writing let a = [3, 3, 3, 3, 3]; butina\nmore concise way.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 3.15,
                        "section_name": "Accessing Array Elements",
                        "section_path": "./screenshots-images-2/chapter_3/section_15",
                        "images": [
                            "./screenshots-images-2/chapter_3/section_15/72071719-a001-420e-b8b8-30eea754c36d.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "stc/main.rs\n\nAccessing Array Elements\nAn array is a single chunk of memory allocated on the stack. You can access\n\nelements of an array using indexing, like this:\n\nfn main() {\nlet a = [1, 2, 3, 4, 5];\n\nlet first = a[0];\nlet second = a[1];\n\nIn this example, the variable named first will get the value 1, because\nthat is the value at index [0] in the array. The variable named second will get\nthe value 2 from index [1] in the array.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 3.16,
                        "section_name": "Invalid Array Element Access",
                        "section_path": "./screenshots-images-2/chapter_3/section_16",
                        "images": [
                            "./screenshots-images-2/chapter_3/section_16/8f0a94c2-fc38-49d6-b1d8-1b7bee677465.png",
                            "./screenshots-images-2/chapter_3/section_16/35afbe31-04ce-4451-9f2a-9521e7d5be97.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Invalid Array Element Access\n\nWhat happens if you try to access an element of an array that is past the end\nof the array? Say you change the example to the following code, which will\ncompile but exit with an error when it runs:\n\nsrc\u00a2/main.rs fn main() {\nlet a = [1, 2, 3, 4, 5]3\nlet index = 10;\nlet element = a[index];\n\nprintln!(\"The value of element is: {}\", element);\n\nRunning this code using cargo run produces the following result:\n\n$ cargo run\nCompiling arrays v0.1.0 (file:///projects/arrays)\nFinished dev [unoptimized + debuginfo] target(s) in 1.50 secs\nRunning \u201ctarget/debug/arrays~\nthread '<main>' panicked at \u2018index out of bounds: the len is 5 but the index\nis 10', src/main.rs:6\nnote: Run with \u201cRUST_BACKTRACE=1\u00b0 for a backtrace.\n\nThe compilation didn\u2019t produce any errors, but the program resulted\nin a runtime error and didn\u2019t exit successfully. When you attempt to access\nan element using indexing, Rust will check that the index you've specified\nis less than the array length. If the index is greater than or equal to the\nlength, Rust will panic.\n\nThis is the first example of Rust\u2019s safety principles in action. In many\nlow-level languages, this kind of check is not done, and when you provide an\nincorrect index, invalid memory can be accessed. Rust protects you against\nthis kind of error by immediately exiting instead of allowing the memory\naccess and continuing. Chapter 9 discusses more of Rust\u2019s error handling.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 3.17,
                        "section_name": "Functions",
                        "section_path": "./screenshots-images-2/chapter_3/section_17",
                        "images": [
                            "./screenshots-images-2/chapter_3/section_17/0ffb554b-c543-41dd-84a8-0f61444ab4f0.png",
                            "./screenshots-images-2/chapter_3/section_17/33c59908-157a-4e91-85e9-a9b09885659b.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Functions\n\nsrc/main.rs\n\nFunctions are pervasive in Rust code. You've already seen one of the most\nimportant functions in the language: the main function, which is the entry\npoint of many programs. You've also seen the fn keyword, which allows you\nto declare new functions.\n\nRust code uses snake case as the conventional style for function and vari-\nable names. In snake case, all letters are lowercase and underscores sepa-\nrate words. Here's a program that contains an example function definition:\n\nfn main() {\nprintln!(\"Hello, world!\");\n\nanother_function();\n\n}\n\nfn another_function() {\nprintln!(\"Another function.\");\n\nFunction definitions in Rust start with fn and have a set of parentheses\nafter the function name. The curly brackets tell the compiler where the\nfunction body begins and ends.\n\nWe can call any function we've defined by entering its name followed\nby a set of parentheses. Because another_function is defined in the program,\nit can be called from inside the main function. Note that we defined another\n\n_function after the main function in the source code; we could have defined it\nbefore as well. Rust doesn\u2019t care where you define your functions, only that\nthey\u2019re defined somewhere.\n\nLet\u2019s start a new binary project named functions to explore functions\nfurther. Place the another_function example in sr\u00a2/main.rs and run it. You\nshould see the following output:\n\n$ cargo run\nCompiling functions v0.1.0 (file:///projects/functions)\nFinished dev [unoptimized + debuginfo] target(s) in 1.50 secs\nRunning ~target/debug/functions~\nHello, world!\nAnother function.\n\nThe lines execute in the order in which they appear in the main function.\nFirst, the \u201cHello, world!\u201d message prints, and then another_function is called\nand its message is printed.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 3.18,
                        "section_name": "Function Parameters",
                        "section_path": "./screenshots-images-2/chapter_3/section_18",
                        "images": [
                            "./screenshots-images-2/chapter_3/section_18/a36a5acd-c658-47e4-9fbd-feb5088c31d1.png",
                            "./screenshots-images-2/chapter_3/section_18/3f8477e5-ac13-451b-bf9b-4413423bc194.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nFunction Parameters\n\nFunctions can also be defined to have parameters, which are special variables\nthat are part of a function\u2019s signature. When a function has parameters, you\ncan provide it with concrete values for those parameters. Technically, the\nconcrete values are called arguments, but in casual conversation, people\ntend to use the words parameter and argument interchangeably for either the\nvariables in a function's definition or the concrete values passed in when\nyou call a function.\n\nThe following rewritten version of another_function shows what param-\neters look like in Rust:\n\nfn main() {\nanother_function(5);\n}\n\nfn another_function(x: i32) {\nprintln!(\"The value of x is: {}\", x);\n}\n\nTry running this program; you should get the following output:\n\n$ cargo run\nCompiling functions v0.1.0 (file:///projects/functions)\nFinished dev [unoptimized + debuginfo] target(s) in 1.50 secs\nRunning ~target/debug/functions\u201d\nThe value of x is: 5\n\nThe declaration of another_function has one parameter named x. The\ntype of x is specified as i32. When 5 is passed to another_function, the println!\nmacro puts 5 where the pair of curly brackets were in the format string.\n\nsrc/main.rs\n\nIn function signatures, you must declare the type of each parameter.\nThis is a deliberate decision in Rust\u2019s design: requiring type annotations\nin function definitions means the compiler almost never needs you to use\nthem elsewhere in the code to figure out what you mean.\n\nWhen you want a function to have multiple parameters, separate the\nparameter declarations with commas, like this:\n\nfn main() {\nanother_function(5, 6);\n}\n\nfn another_function(x: 132, y: 132) {\nprintln!(\"The value of x is: {}\", x);\nprintln!(\"The value of y is: {}\", y);\n}\n\nThis example creates a function with two parameters, both of which\nare i32 types. The function then prints the values in both of its parameters.\nNote that function parameters don\u2019t all need to be the same type; they just\nhappen to be in this example.\n\nLet\u2019s try running this code. Replace the program currently in your\nfunctions project\u2019s src/main.rs file with the preceding example and run it\nusing cargo run:\n\n$ cargo run\nCompiling functions v0.1.0 (file:///projects/functions)\nFinished dev [unoptimized + debuginfo] target(s) in 1.50 secs\nRunning ~target/debug/functions~\nThe value of x is: 5\nThe value of y is: 6\n\nBecause we called the function with 5 as the value for x and 6 is passed\nas the value for y, the two strings are printed with these values.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 3.19,
                        "section_name": "Statements and Expressions in Function Bodies",
                        "section_path": "./screenshots-images-2/chapter_3/section_19",
                        "images": [
                            "./screenshots-images-2/chapter_3/section_19/db49f169-9712-4dbd-ba10-cf74a4c4abae.png",
                            "./screenshots-images-2/chapter_3/section_19/87125fd9-cbfd-4cae-b5ac-e5a7065c41ce.png",
                            "./screenshots-images-2/chapter_3/section_19/461cf326-cece-40c6-a8cb-463e4cb69299.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Statements and Expressions in Function Bodies\n\nFunction bodies are made up of a series of statements optionally ending\n\nin an expression. So far, we've only covered functions without an ending\nexpression, but you have seen an expression as part of a statement. Because\nRust is an expression-based language, this is an important distinction to\nunderstand. Other languages don\u2019t have the same distinctions, so let\u2019s look\nat what statements and expressions are and how their differences affect the\nbodies of functions.\n\nWe've actually already used statements and expressions. Statements are\ninstructions that perform some action and do not return a value. Expressions\nevaluate to a resulting value. Let\u2019s look at some examples.\n\nCreating a variable and assigning a value to it with the let keyword is a\nstatement. In Listing 3-1, let y = 6; is a statement.\n\nsrc/main.rs\n\nsrc/main.rs\n\nsrc/main.rs\n\nfn main() {\nlet y = 6;\n}\n\nListing 3-1: A main function declaration containing one statement\n\nFunction definitions are also statements; the entire preceding example\nis a statement in itself.\n\nStatements do not return values. Therefore, you can\u2019t assign a let state-\nment to another variable, as the following code tries to do; you'll get an error:\n\nfn main() {\n\nlet x = (let y = 6);\n}\n\nWhen you run this program, the error you'll get looks like this:\n\n$ cargo run\n\nCompiling functions v0.1.0 (file:///projects/functions)\nerror: expected expression, found statement (~let>)\n--> src/main.rs:2:14\n\n2 let x = (let y = 6);\n\n|\n\n| AAA\n\n|\n\n= note: variable declaration using \u201clet\u2019 is a statement\n\nThe let y = 6 statement does not return a value, so there isn\u2019t anything\nfor x to bind to. This is different from what happens in other languages, such\nas C and Ruby, where the assignment returns the value of the assignment. In\nthose languages, you can write x = y = 6 and have both x and y contain the\nvalue 6; that is not the case in Rust.\n\nExpressions evaluate to something and make up most of the rest of\nthe code that you'll write in Rust. Consider a simple math operation, such\nas 5 + 6, which is an expression that evaluates to the value 11. Expressions\ncan be part of statements: in Listing 3-1, the 6 in the statement let y = 6; is\nan expression that evaluates to the value 6. Calling a function is an expres-\nsion. Calling a macro is an expression. The block that we use to create new\nscopes, {}, is an expression, for example:\n\nfn main() {\nlet x = 5;\n\n@ lety = {@\nlet x = 3;\n@x+i\nhs\n\nprintln!(\"The value of y is: {}\", y);\n\nThe expression @ is a block that, in this case, evaluates to 4. That\nvalue gets bound to y as part of the let statement @. Note the line without\na semicolon at the end \u00ae, which is unlike most of the lines you've seen so\nfar. Expressions do not include ending semicolons. If you add a semicolon\nto the end of an expression, you turn it into a statement, which will then not\n\nreturn a value. Keep this in mind as you explore function return values and\nexpressions next.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 3.2,
                        "section_name": "Functions with Return Values",
                        "section_path": "./screenshots-images-2/chapter_3/section_20",
                        "images": [
                            "./screenshots-images-2/chapter_3/section_20/fd5b5fdb-4b4a-4da2-a11a-632d067233e0.png",
                            "./screenshots-images-2/chapter_3/section_20/5c932a72-5dbd-4d5e-8e71-0d00d55f260c.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "sr/main.rs\n\nFunctions with Return Values\n\nFunctions can return values to the code that calls them. We don\u2019t name\nreturn values, but we do declare their type after an arrow (->). In Rust,\nthe return value of the function is synonymous with the value of the final\nexpression in the block of the body of a function. You can return early\nfrom a function by using the return keyword and specifying a value, but\nmost functions return the last expression implicitly. Here\u2019s an example of\na function that returns a value:\n\nfn five() -> i32 {\n5\n\n}\nfn main() {\n\nlet x = five();\n\nprintln!(\"The value of x is: {}\", x);\n}\n\nThere are no function calls, macros, or even let statements in the five\nfunction\u2014just the number 5 by itself. That's a perfectly valid function in\nRust. Note that the function's return type is specified too, as -> i32. Try\nrunning this code; the output should look like this:\n\n$ cargo run\nCompiling functions v0.1.0 (file:///projects/functions)\nFinished dev [unoptimized + debuginfo] target(s) in 1.50 secs\nRunning ~target/debug/functions~\nThe value of x is: 5\n\nThe 5 in five is the function\u2019s return value, which is why the return type\nis i132. Let\u2019s examine this in more detail. There are two important bits: first,\nthe line let x = five(); shows that we're using the return value of a function\nto initialize a variable. Because the function five returns a 5, that line is the\nsame as the following:\n\nlet x = 5;\n\nSecond, the five function has no parameters and defines the type of\nthe return value, but the body of the function is a lonely \u00a7 with no semi-\ncolon because it\u2019s an expression whose value we want to return.\n\nsrc/main.rs\n\nsrc/main.rs\n\nLet\u2019s look at another example:\n\nfn main() {\nlet x = plus_one(5);\n\nprintln!(\"The value of x is: {}\", x);\n\n}\n\nfn plus_one(x: 132) -> 132 {\nx+1\n\n}\n\nRunning this code will print The value of x is: 6. But if we place a semi-\ncolon at the end of the line containing x + 1, changing it from an expression\nto a statement, we'll get an error.\n\nfn main() {\nlet x = plus_one(5);\n\nprintln!(\"The value of x is: {}\", x);\n\nfn plus_one(x: 132) -> i32 {\nx +1;\n}\n\nCompiling this code produces an error, as follows:\n\nerror[E0308]: mismatched types\n--> src/main.rs:7:28\n\n}\n\nexpected i32, found ()\n\n7 | fn plus_one(x: 132) -> i32 {\n\n| \u201ca\n8 { | x+1;\n\n| = help: consider removing this semicolon\n9 | |\n\n||\n\n|\n\nnote: expected type ~i32\u00b0\nfound type ~()\u00b0\n\nThe main error message, \u201cmismatched types,\u201d reveals the core issue\nwith this code. The definition of the function plus_one says that it will return\nan 32, but statements don\u2019t evaluate to a value, which is expressed by (), an\nempty tuple. Therefore, nothing is returned, which contradicts the function\ndefinition and results in an error. In this output, Rust provides a message\nto possibly help rectify this issue: it suggests removing the semicolon, which\nwould fix the error.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 3.21,
                        "section_name": "Comments",
                        "section_path": "./screenshots-images-2/chapter_3/section_21",
                        "images": [
                            "./screenshots-images-2/chapter_3/section_21/78e50e2d-368f-49ac-b49d-bf87baf4d8ac.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Comments\n\nsrc/main.rs\n\nsrc/main.rs\n\nAll programmers strive to make their code easy to understand, but some-\ntimes extra explanation is warranted. In these cases, programmers leave\nnotes, or comments, in their source code that the compiler will ignore but\npeople reading the source code may find useful.\n\nHere\u2019s a simple comment:\n\n// hello, world\n\nIn Rust, comments must start with two slashes and continue until the\nend of the line. For comments that extend beyond a single line, you'll need\nto include // on each line, like this:\n\n// So we're doing something complicated here, long enough that we need\n// multiple lines of comments to do it! Whew! Hopefully, this comment will\n// explain what's going on.\n\nComments can also be placed at the end of lines containing code:\n\nfn main() {\nlet lucky_number = 7; // I'm feeling lucky today\n}\n\nBut you'll more often see them used in this format, with the comment\non a separate line above the code it\u2019s annotating:\n\nfn main() {\n// I'm feeling lucky today\nlet lucky_number = 7;\n\n}\n\nRust also has another kind of comment, documentation comments,\nwhich we'll discuss in \u201cPublishing a Crate to Crates.io\u201d on page 293.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 3.22,
                        "section_name": "Control Flow",
                        "section_path": "./screenshots-images-2/chapter_3/section_22",
                        "images": [
                            "./screenshots-images-2/chapter_3/section_22/801b19e4-21dd-4467-bd6c-4ddb87aaa231.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Control Flow\n\nDeciding whether or not to run some code depending on whether a condi-\ntion is true and deciding to run some code repeatedly while a condition is\ntrue are basic building blocks in most programming languages. The most\ncommon constructs that let you control the flow of execution of Rust code\nare if expressions and loops.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 3.23,
                        "section_name": "if Expressions",
                        "section_path": "./screenshots-images-2/chapter_3/section_23",
                        "images": [
                            "./screenshots-images-2/chapter_3/section_23/90df8a85-e133-4abf-bf9c-cdf45558e7b8.png",
                            "./screenshots-images-2/chapter_3/section_23/6641d83a-5a93-4620-aed7-53f245db1e9d.png",
                            "./screenshots-images-2/chapter_3/section_23/829ed79b-a9f6-46eb-b68f-5acc516cf715.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "if Expressions\nAn if expression allows you to branch your code depending on conditions.\n\nYou provide a condition and then state, \u201cIf this condition is met, run this\nblock of code. If the condition is not met, do not run this block of code.\u201d\n\nsrc/main.rs\n\nCreate a new project called branches in your projects directory to explore\nthe if expression. In the sr\u00a2/main.rs file, input the following:\n\nfn main() {\nlet number = 3;\n\nif number < 5 {\n\nprintln! (\"condition was true\");\n} else {\n\nprintln! (\"condition was false\");\n}\n\nAll if expressions start with the keyword if, which is followed by a\ncondition. In this case, the condition checks whether or not the vari-\nable number has a value less than 5. The block of code we want to execute\nif the condition is true is placed immediately after the condition inside\ncurly brackets. Blocks of code associated with the conditions in if expres-\nsions are sometimes called arms, just like the arms in match expressions\nthat we discussed in \u201cComparing the Guess to the Secret Number\u201d on\npage 23.\n\nOptionally, we can also include an else expression, which we chose to\ndo here, to give the program an alternative block of code to execute should\nthe condition evaluate to false. If you don\u2019t provide an else expression\nand the condition is false, the program will just skip the if block and move\non to the next bit of code.\n\nTry running this code; you should see the following output:\n\n$ cargo run\nCompiling branches v0.1.0 (file:///projects/branches)\nFinished dev [unoptimized + debuginfo] target(s) in 1.50 secs\nRunning \u201ctarget/debug/branches\u201d\ncondition was true\n\nLet's try changing the value of number to a value that makes the condi-\ntion false to see what happens:\n\nlet number = 7;\n\nRun the program again, and look at the output:\n\n$ cargo run\nCompiling branches v0.1.0 (file:///projects/branches)\nFinished dev [unoptimized + debuginfo] target(s) in 1.50 secs\nRunning ~target/debug/branches\u201d\ncondition was false\n\nsrc/main.rs\n\nsrc/main.rs\n\nIt\u2019s also worth noting that the condition in this code must be a bool. If\nthe condition isn\u2019t a bool, we'll get an error. For example, try running the\nfollowing code:\n\nfn main() {\nlet number = 3;\n\nif number {\nprintln!(\"number was three\");\n}\n\nThe if condition evaluates to a value of 3 this time, and Rust throws an\nerror:\n\nerror[E0308]: mismatched types\n--> src/main.rs:4:8\n\nif number {\n\n4 |\n| *a440% expected bool, found integral variable\n|\n\nnote: expected type ~bool~\nfound type ~{integer}\u201d\n\nThe error indicates that Rust expected a bool but got an integer. Unlike\nlanguages such as Ruby and JavaScript, Rust will not automatically try to\nconvert non-Boolean types to a Boolean. You must be explicit and always\nprovide if with a Boolean as its condition. If we want the if code block to run\nonly when a number is not equal to 0, for example, we can change the if\nexpression to the following:\n\nfn main() {\nlet number = 3;\n\nif number != 0 {\nprintln!(\"\u201cnumber was something other than zero\");\n}\n\nRunning this code will print number was something other than zero.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 3.24,
                        "section_name": "Handling Multiple Conditions with else if",
                        "section_path": "./screenshots-images-2/chapter_3/section_24",
                        "images": [
                            "./screenshots-images-2/chapter_3/section_24/8219365b-2912-4415-86d8-e0cef7490a09.png",
                            "./screenshots-images-2/chapter_3/section_24/f0ca394f-509d-4371-b441-d09356d3a942.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Handling Multiple Conditions with else if\n\nYou can have multiple conditions by combining if and else in an else if\nexpression. For example:\n\nsrc/main.rs fn main() {\nlet number = 6;\n\nif number % 4 == 0 {\n\nprintln! (\"number is divisible by 4\");\n} else if number % 3 == 0 {\nprintln!(\"number is divisible by 3\");\n} else if number % 2 == 0 {\nprintln!(\"number is divisible by 2\");\n} else {\nprintln!(\"number is not divisible by 4, 3, or 2\");\n\nThis program has four possible paths it can take. After running it, you\nshould see the following output:\n\n$ cargo run\nCompiling branches v0.1.0 (file:///projects/branches)\nFinished dev [unoptimized + debuginfo] target(s) in 1.50 secs\nRunning \u201ctarget/debug/branches\u201d\nnumber is divisible by 3\n\nWhen this program executes, it checks each if expression in turn and\nexecutes the first body for which the condition holds true. Note that even\nthough 6 is divisible by 2, we don\u2019t see the output number is divisible by 2,\nnor do we see the number is not divisible by 4, 3, or 2 text from the else\nblock. That\u2019s because Rust only executes the block for the first true condi-\ntion, and once it finds one, it doesn\u2019t even check the rest.\n\nUsing too many else if expressions can clutter your code, so if you have\nmore than one, you might want to refactor your code. Chapter 6 describes a\npowerful Rust branching construct called match for these cases.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 3.25,
                        "section_name": "Using if in a let Statement",
                        "section_path": "./screenshots-images-2/chapter_3/section_25",
                        "images": [
                            "./screenshots-images-2/chapter_3/section_25/8d160a40-a3b7-4542-a168-196252babd62.png",
                            "./screenshots-images-2/chapter_3/section_25/b593ac40-4da6-4b23-80d7-e8c8650b0a94.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Using if in a let Statement\n\nBecause if is an expression, we can use it on the right side of a let state-\nment, as in Listing 3-2.\n\nsrc\u00a2/main.rs fn main() {\nlet condition = true;\nlet number = if condition {\n5\n} else {\n6\nhs\n\nprintln!(\"The value of number is: {}\", number);\n}\n\nListing 3-2: Assigning the result of an if expression to a variable\n\nThe number variable will be bound to a value based on the outcome of\nthe if expression. Run this code to see what happens:\n\n$ cargo run\nCompiling branches v0.1.0 (file:///projects/branches)\n\nsrc/main.rs\n\nFinished dev [unoptimized + debuginfo] target(s) in 1.50 secs\nRunning \u201ctarget/debug/branches~\nThe value of number is: 5\n\nRemember that blocks of code evaluate to the last expression in them,\nand numbers by themselves are also expressions. In this case, the value of\nthe whole if expression depends on which block of code executes. This\nmeans the values that have the potential to be results from each arm of\nthe if must be the same type; in Listing 3-2, the results of both the if arm\nand the else arm were i32 integers. If the types are mismatched, as in the\nfollowing example, we'll get an error:\n\nfn main() {\nlet condition = true;\n\nlet number = if condition {\n5\n\n} else {\n\"six\"\n\nhs\n\nprintln!(\"The value of number is: {}\", number);\n}\n\nWhen we try to compile this code, we'll get an error. The if and else\narms have value types that are incompatible, and Rust indicates exactly\nwhere to find the problem in the program:\n\nerror[E\u00a30308]: if and else have incompatible types\n--> src/main.rs:4:18\n\n* expected integral variable, found &str\n\n4| let number = if condition {\n| a\n\n5| | 5\n\n6| | } else {\n\n711 \"six\"\n\n8 | | Is\nI |\n|\n\nnote: expected type ~{integer}~\nfound type ~&str\u00b0\n\nThe expression in the if block evaluates to an integer, and the expres-\nsion in the else block evaluates to a string. This won\u2019t work because variables\nmust have a single type. Rust needs to know at compile time what type the\nnumber variable is, definitively, so it can verify at compile time that its type is\nvalid everywhere we use number. Rust wouldn't be able to do that if the type of\nnumber was only determined at runtime; the compiler would be more complex\nand would make fewer guarantees about the code if it had to keep track of\nmultiple hypothetical types for any variable.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 3.26,
                        "section_name": "Repetition with Loops",
                        "section_path": "./screenshots-images-2/chapter_3/section_26",
                        "images": [
                            "./screenshots-images-2/chapter_3/section_26/c8371f08-9cb9-4bd6-b328-d8ce2c3e153f.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Repetition with Loops\n\nIt\u2019s often useful to execute a block of code more than once. For this task,\nRust provides several loops. A loop runs through the code inside the loop\nbody to the end and then starts immediately back at the beginning. To\nexperiment with loops, let\u2019s make a new project called loops.\n\nRust has three kinds of loops: loop, while, and for. Let\u2019s try each one.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 3.27,
                        "section_name": "Repeating Code with loop",
                        "section_path": "./screenshots-images-2/chapter_3/section_27",
                        "images": [
                            "./screenshots-images-2/chapter_3/section_27/9e1f87cf-7e26-479c-8b45-9e7a21778428.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nRepeating Code with loop\nThe loop keyword tells Rust to execute a block of code over and over again\nforever or until you explicitly tell it to stop.\n\nAs an example, change the src/main.rs file in your loops directory to\nlook like this:\n\nfn main() {\nloop {\nprintln!(\"again!\");\n\nWhen we run this program, we'll see again! printed over and over\ncontinuously until we stop the program manually. Most terminals support\na keyboard shortcut, CTRL-C, to interrupt a program that is stuck in a con-\ntinual loop. Give it a try:\n\n$ cargo run\nCompiling loops v0.1.0 (file:///projects/loops)\nFinished dev [unoptimized + debuginfo] target(s) in 1.50 secs\nRunning \u201ctarget/debug/ loops\u201d\nagain!\nagain!\nagain!\nagain!\n*Cagain!\n\nThe symbol *C represents where you pressed CTRL-C. You may or may\nnot see the word again! printed after the *C, depending on where the code\nwas in the loop when it received the halt signal.\n\nFortunately, Rust provides another, more reliable way to break out of a\nloop. You can place the break keyword within the loop to tell the program\nwhen to stop executing the loop. Recall that we did this in the guessing\ngame in \u201cQuitting After a Correct Guess\u201d on page 27 to exit the program\nwhen the user won the game by guessing the correct number.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 3.28,
                        "section_name": "Returning Values from Loops",
                        "section_path": "./screenshots-images-2/chapter_3/section_28",
                        "images": [
                            "./screenshots-images-2/chapter_3/section_28/5796b665-3f4c-4a75-afb3-4a2e24a12f84.png",
                            "./screenshots-images-2/chapter_3/section_28/e887f79a-d880-4759-bef6-fb801382e8a8.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Returning Values from Loops\n\nOne of the uses of a loop is to retry an operation you know might fail, such\nas checking whether a thread has completed its job. However, you might\nneed to pass the result of that operation to the rest of your code. To do this,\n\nyou can add the value you want returned after the break expression you use\nto stop the loop; that value will be returned out of the loop so you can use\nit, as shown here:\n\nfn main() {\nlet mut counter = 0;\n\nlet result = loop {\ncounter += 1;\n\nif counter == 10 {\nbreak counter * 2;\n}\n\ni\n\nprintln!(\"The result is {}\", result);\n\nBefore the loop, we declare a variable named counter and initialize it to 0.\nThen we declare a variable named result to hold the value returned from the\nloop. On every iteration of the loop, we add 1 to the counter variable, and then\ncheck whether the counter is equal to 10. When it is, we use the break keyword\nwith the value counter * 2. After the loop, we use a semicolon to end the state-\nment that assigns the value to result. Finally, we print the value in result,\nwhich in this case is 20.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 3.29,
                        "section_name": "Conditional Loops with while",
                        "section_path": "./screenshots-images-2/chapter_3/section_29",
                        "images": [
                            "./screenshots-images-2/chapter_3/section_29/0c28c4f0-d915-4b59-a584-7f4a326322f4.png",
                            "./screenshots-images-2/chapter_3/section_29/efef2605-8ecf-4079-a7e7-c12c490863b9.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "sre/main.rs\n\nConditional Loops with while\n\nIt\u2019s often useful for a program to evaluate a condition within a loop.\nWhile the condition is true, the loop runs. When the condition ceases to\nbe true, the program calls break, stopping the loop. This loop type could be\nimplemented using a combination of loop, if, else, and break; you could try\nthat now in a program, if you'd like.\n\nHowever, this pattern is so common that Rust has a built-in language\nconstruct for it, called a while loop. Listing 3-3 uses while: the program\nloops three times, counting down each time, and then, after the loop, it\nprints another message and exits.\n\nfn main() {\nlet mut number = 3;\n\nwhile number != 0 {\nprintln!(\"{}!\", number);\n\nnumber = number - 1;\n\n}\nprintln! (\"LIFTOFFI!!\");\n\nListing 3-3: Using a while loop to run code while a condition holds true\n\nThis construct eliminates a lot of nesting that would be necessary if you\nused loop, if, else, and break, and it\u2019s clearer. While a condition holds true,\nthe code runs; otherwise, it exits the loop.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 3.3,
                        "section_name": "Looping Through a Collection with for",
                        "section_path": "./screenshots-images-2/chapter_3/section_30",
                        "images": [
                            "./screenshots-images-2/chapter_3/section_30/6a53666f-2673-447c-8a9e-026c17cf623d.png",
                            "./screenshots-images-2/chapter_3/section_30/e1b1ccc2-806e-4564-9a47-b6831b927a67.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nsrc/main.rs\n\nLooping Through a Collection with for\n\nYou could use the while construct to loop over the elements of a collection,\nsuch as an array. For example, let\u2019s look at Listing 3-4.\n\nfn main() {\nlet a = [10, 20, 30, 40, 50];\nlet mut index = 0;\n\nwhile index < 5 {\nprintln!(\"the value is: {}\", a[index]);\n\nindex = index + 1;\n\n}\n\nListing 3-4: Looping through each element of a collection using a while loop\n\nHere, the code counts up through the elements in the array. It starts at\nindex 0, and then loops until it reaches the final index in the array (that is,\nwhen index < 5 is no longer true). Running this code will print every element\nin the array:\n\n$ cargo run\nCompiling loops v0.1.0 (file:///projects/loops)\nFinished dev [unoptimized + debuginfo] target(s) in 1.50 secs\nRunning ~target/debug/ loops\u201d\nthe value is: 10\nthe value is: 20\nthe value is: 30\nthe value is: 40\nthe value is: 50\n\nAll five array values appear in the terminal, as expected. Even though\nindex will reach a value of 5 at some point, the loop stops executing before\ntrying to fetch a sixth value from the array.\n\nBut this approach is error prone; we could cause the program to panic\nif the index length is incorrect. It\u2019s also slow, because the compiler adds\nruntime code to perform the conditional check on every element on every\niteration through the loop.\n\nAs a more concise alternative, you can use a for loop and execute some\ncode for each item in a collection. A for loop looks like the code in Listing 3-5.\n\nfn main() {\nlet a = [10, 20, 30, 40, 50];\n\nfor element in a.iter() {\n\nsrc/main.rs\n\nprintln!(\"the value is: {}\", element);\n\n}\n\nListing 3-5: Looping through each element of a collection using a for loop\n\nWhen we run this code, we'll see the same output as in Listing 3-4.\nMore importantly, we've now increased the safety of the code and elimi-\nnated the chance of bugs that might result from going beyond the end of\nthe array or not going far enough and missing some items.\n\nFor example, in the code in Listing 3-4, if you removed an item from\nthe a array but forgot to update the condition to while index < 4, the code\nwould panic. Using the for loop, you wouldn't need to remember to change\nany other code if you changed the number of values in the array.\n\nThe safety and conciseness of for loops make them the most commonly\nused loop construct in Rust. Even in situations in which you want to run\nsome code a certain number of times, as in the countdown example that\nused a while loop in Listing 3-3, most Rustaceans would use a for loop. The\nway to do that would be to use a Range, which is a type provided by the stan-\ndard library that generates all numbers in sequence starting from one num-\nber and ending before another number.\n\nHere's what the countdown would look like using a for loop and\nanother method we've not yet talked about, rev, to reverse the range:\n\nfn main() {\nfor number in (1..4).rev() {\nprintln!(\"{}!\", number) ;\n\nprintln! (\"LIFTOFFI!!\");\n\nThis code is a bit nicer, isn\u2019t it?\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 3.31,
                        "section_name": "Summary",
                        "section_path": "./screenshots-images-2/chapter_3/section_31",
                        "images": [
                            "./screenshots-images-2/chapter_3/section_31/3bcd29a4-7d66-46cc-a27c-9e5c0f5c4a85.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Summary\n\nYou made it! That was a sizable chapter: you learned about variables, scalar\nand compound data types, functions, comments, if expressions, and loops!\nIf you want to practice with the concepts discussed in this chapter, try build-\ning programs to do the following:\n\ne Convert temperatures between Fahrenheit and Celsius.\n\ne Generate the nth Fibonacci number.\n\ne Print the lyrics to the Christmas carol \u201cThe Twelve Days of Christmas,\u201d\ntaking advantage of the repetition in the song.\n\nWhen you're ready to move on, we'll talk about a concept in Rust that\ndoesn't commonly exist in other programming languages: ownership.\n",
                        "extracted-code": ""
                    }
                ]
            },
            {
                "chapter_id": 4,
                "chapter_name": "UNDERSTANDING OWNERSHIP",
                "chapter_path": "./screenshots-images-2/chapter_4",
                "sections": [
                    {
                        "section_id": 4.1,
                        "section_name": "UNDERSTANDING OWNERSHIP",
                        "section_path": "./screenshots-images-2/chapter_4/section_1",
                        "images": [
                            "./screenshots-images-2/chapter_4/section_1/ad455cb2-53ce-4135-a77e-7d2330d34b4e.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "UNDERSTANDING OWNERSHIP\n\nOwnership is Rust\u2019s most unique feature,\n\nand it enables Rust to make memory safety\nguarantees without needing a garbage col-\n\nlector. Therefore, it\u2019s important to understand\n\nhow ownership works in Rust. In this chapter, we\u2019ll\ntalk about ownership as well as several related fea-\ntures: borrowing, slices, and how Rust lays data out in\nmemory.\n\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 4.2,
                        "section_name": "What Is Ownership?",
                        "section_path": "./screenshots-images-2/chapter_4/section_2",
                        "images": [
                            "./screenshots-images-2/chapter_4/section_2/15a52dbd-7374-4c37-896a-38b7480c7d47.png",
                            "./screenshots-images-2/chapter_4/section_2/a16be79f-7e0b-4188-bd54-00219d7bed75.png",
                            "./screenshots-images-2/chapter_4/section_2/62583695-8dc0-4af4-ad4c-0ac25c828158.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "What Is Ownership?\n\nRust\u2019s central feature is ownership. Although the feature is straightforward\nto explain, it has deep implications for the rest of the language.\n\nAll programs have to manage the way they use a computer's memory\nwhile running. Some languages have garbage collection that constantly\nlooks for no longer used memory as the program runs; in other languages,\n\nthe programmer must explicitly allocate and free the memory. Rust uses a\nthird approach: memory is managed through a system of ownership with\na set of rules that the compiler checks at compile time. None of the owner-\nship features slow down your program while it\u2019s running.\n\nBecause ownership is a new concept for many programmers, it does take\nsome time to get used to. The good news is that the more experienced you\nbecome with Rust and the rules of the ownership system, the more you'll be\nable to naturally develop code that is safe and efficient. Keep at it!\n\nWhen you understand ownership, you'll have a solid foundation for\nunderstanding the features that make Rust unique. In this chapter, you'll\nlearn ownership by working through some examples that focus on a very\ncommon data structure: strings.\n\nTHE STACK AND THE HEAP\n\nIn many programming languages, you don\u2019t have to think about the stack and\nthe heap very often. But in a systems programming language like Rust, whether\na value is on the stack or the heap has more of an effect on how the language\nbehaves and why you have to make certain decisions. Parts of ownership will\nbe described in relation to the stack and the heap later in this chapter, so here\nis a brief explanation in preparation.\n\nBoth the stack and the heap are parts of memory that are available to your\ncode to use at runtime, but they are structured in different ways. The stack stores\nvalues in the order it gets them and removes the values in the opposite order. This\nis referred to as /ast in, first out. Think of a stack of plates: when you add more\nplates, you put them on top of the pile, and when you need a plate, you take\none off the top. Adding or removing plates from the middle or bottom wouldn't\nwork as well! Adding data is called pushing onto the stack, and removing data\nis called popping off the stack.\n\nAll data stored on the stack must have a known, fixed size. Data with an\nunknown size at compile time or a size that might change must be stored on the\nheap instead. The heap is less organized: when you put data on the heap, you\nrequest a certain amount of space. The operating system finds an empty spot\nin the heap that is big enough, marks it as being in use, and returns a pointer,\nwhich is the address of that location. This process is called allocating on the\nheap and is sometimes abbreviated as just allocating. Pushing values onto the\nstack is not considered allocating. Because the pointer is a known, fixed size,\nyou can store the pointer on the stack, but when you want the actual data, you\nmust follow the pointer.\n\nThink of being seated at a restaurant. When you enter, you state the num-\nber of people in your group, and the staff finds an empty table that fits every-\none and leads you there. If someone in your group comes late, they can ask\nwhere you've been seated to find you.\n\n\nPushing to the stack is faster than allocating on the heap because the oper-\nating system never has to search for a place to store new data; that location\nis always at the top of the stack. Comparatively, allocating space on the heap\nrequires more work, because the operating system must first find a big enough\nspace to hold the data and then perform bookkeeping to prepare for the next\nallocation.\n\nAccessing data in the heap is slower than accessing data on the stack\nbecause you have to follow a pointer to get there. Contemporary processors are\nfaster if they jump around less in memory. Continuing the analogy, consider a\nserver at a restaurant taking orders from many tables. It\u2019s most efficient to get all\nthe orders at one table before moving on to the next table. Taking an order from\ntable A, then an order from table B, then one from A again, and then one from\nB again would be a much slower process. By the same token, a processor can\ndo its job better if it works on data that\u2019s close to other data (as it is on the stack}\nrather than farther away (as it can be on the heap}. Allocating a large amount of\nspace on the heap can also take time.\n\nWhen your code calls a function, the values passed into the function\n(including, potentially, pointers to data on the heap) and the function's local\nvariables get pushed onto the stack. When the function is over, those values\nget popped off the stack.\n\nKeeping track of what parts of code are using what data on the heap,\nminimizing the amount of duplicate data on the heap, and cleaning up unused\ndata on the heap so you don't run out of space are all problems that ownership\naddresses. Once you understand ownership, you won't need to think about the\nstack and the heap very often, but knowing that managing heap data is why\nownership exists can help explain why it works the way it does.\n\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 4.3,
                        "section_name": "Ownership Rules",
                        "section_path": "./screenshots-images-2/chapter_4/section_3",
                        "images": [
                            "./screenshots-images-2/chapter_4/section_3/8c7bf624-010f-4800-b971-d4bf27cfb9bb.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Ownership Rules\n\nFirst, let\u2019s take a look at the ownership rules. Keep these rules in mind as we\nwork through the examples that illustrate them:\n\ne Each value in Rust has a variable that\u2019s called its owner.\n\ne There can be only one owner at a time.\n\ne When the owner goes out of scope, the value will be dropped.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 4.4,
                        "section_name": "Variable Scope",
                        "section_path": "./screenshots-images-2/chapter_4/section_4",
                        "images": [
                            "./screenshots-images-2/chapter_4/section_4/ed60a214-9552-4ae2-bc45-96ee56974911.png",
                            "./screenshots-images-2/chapter_4/section_4/a5228a8a-7b4f-4801-b131-fc0e0665facb.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Variable Scope\n\nWe've walked through an example of a Rust program already in Chapter 2.\nNow that we're past basic syntax, we won't include all the fn main() { code\nin examples, so if you're following along, you'll have to put the following\nexamples inside a main function manually. As a result, our examples will\nbe a bit more concise, letting us focus on the details rather than boiler-\nplate code.\n\nAs a first example of ownership, we'll look at the scope of some variables.\nA scope is the range within a program for which an item is valid. Let\u2019s say\nwe have a variable that looks like this:\n\nlet s = \"hello\";\n\nThe variable s refers to a string literal, where the value of the string\nis hardcoded into the text of our program. The variable is valid from the\npoint at which it\u2019s declared until the end of the current scope. Listing 4-1\nhas comments annotating where the variable s is valid.\n\n{ // s is not valid here; it's not yet declared\nlet s = \"hello\"; // s is valid from this point forward\n\n// do stuff with s\n} // this scope is now over, and s is no longer valid\n\nListing 4-1: A variable and the scope in which it is valid\nIn other words, there are two important points in time here:\n\ne When s comes into scope, it is valid.\ne = Itremains valid until it goes out of scope.\nAt this point, the relationship between scopes and when variables are\n\nvalid is similar to that in other programming languages. Now we'll build on\ntop of this understanding by introducing the String type.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 4.5,
                        "section_name": "The String Type",
                        "section_path": "./screenshots-images-2/chapter_4/section_5",
                        "images": [
                            "./screenshots-images-2/chapter_4/section_5/9c23f876-9f23-4ad9-85cc-de56a3770fe3.png",
                            "./screenshots-images-2/chapter_4/section_5/e2bc4672-e4bf-40eb-a435-3765a8fc877c.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "The String Type\n\nTo illustrate the rules of ownership, we need a data type that is more complex\nthan the ones we covered in \u201cData Types\u201d on page 36. The types covered\npreviously are all stored on the stack and popped off the stack when their\nscope is over, but we want to look at data that is stored on the heap and\nexplore how Rust knows when to clean up that data.\n\nWe'll use String as the example here and concentrate on the parts of\nString that relate to ownership. These aspects also apply to other complex\ndata types provided by the standard library and that you create. We'll dis-\ncuss String in more depth in Chapter 8.\n\nWe've already seen string literals, where a string value is hardcoded into\nour program. String literals are convenient, but they aren\u2019t suitable for every\nsituation in which we may want to use text. One reason is that they\u2019re immu-\ntable. Another is that not every string value can be known when we write\nour code: for example, what if we want to take user input and store it? For\nthese situations, Rust has a second string type, String. This type is allocated\non the heap and as such is able to store an amount of text that is unknown\nto us at compile time. You can create a String from a string literal using the\nfrom function, like so:\n\nlet s = String::from(\"hello\");\n\nThe double colon (::) is an operator that allows us to namespace this\nparticular from function under the String type rather than using some sort\nof name like string from. We'll discuss this syntax more in \u201cMethod Syntax\u201d\non page 92 and when we talk about namespacing with modules in \u201cPaths\nfor Referring to an Item in the Module Tree\u201d on page 115.\n\nThis kind of string can be mutated:\n\nlet mut s = String: :from(\"hello\");\ns.push_str(\", world!\"); // push_str() appends a literal to a String\n\nprintln!(\"{}\", s); // this will print \u201chello, world!\u201d\n\nSo, what's the difference here? Why can String be mutated but literals\ncannot? The difference is how these two types deal with memory.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 4.6,
                        "section_name": "Memory and Allocation",
                        "section_path": "./screenshots-images-2/chapter_4/section_6",
                        "images": [
                            "./screenshots-images-2/chapter_4/section_6/aca60edb-ffe4-483a-9163-819a46621249.png",
                            "./screenshots-images-2/chapter_4/section_6/fe5aa56b-3839-4e9a-95da-b1d8aac15561.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Memory and Allocation\n\nIn the case of a string literal, we know the contents at compile time, so\nthe text is hardcoded directly into the final executable. This is why string\nliterals are fast and efficient. But these properties only come from the\nstring literal\u2019s immutability. Unfortunately, we can\u2019t put a blob of memory\ninto the binary for each piece of text whose size is unknown at compile time\nand whose size might change while running the program.\n\nWith the String type, in order to support a mutable, growable piece of\ntext, we need to allocate an amount of memory on the heap, unknown at\ncompile time, to hold the contents. This means:\n\ne The memory must be requested from the operating system at runtime.\n\ne We need a way of returning this memory to the operating system when\nwe're done with our String.\n\nThat first part is done by us: when we call String: : from, its implementa-\ntion requests the memory it needs. This is pretty much universal in pro-\ngramming languages.\n\nHowever, the second part is different. In languages with a garbage collector\n(GC), the GC keeps track and cleans up memory that isn\u2019t being used any-\nmore, and we don\u2019t need to think about it. Without a GC, it\u2019s our respon-\nsibility to identify when memory is no longer being used and call code to\nexplicitly return it, just as we did to request it. Doing this correctly has histori-\ncally been a difficult programming problem. If we forget, we'll waste memory.\nIf we do it too early, we'll have an invalid variable. If we do it twice, that\u2019s a\nbug too. We need to pair exactly one allocate with exactly one free.\n\nRust takes a different path: the memory is automatically returned once\nthe variable that owns it goes out of scope. Here's a version of our scope\nexample from Listing 4-1 using a String instead of a string literal:\n\n{\nlet s = String::from(\"hello\"); // s is valid from this point forward\n\n// do stuff with s\n} // this scope is now over, and s is no\n// longer valid\n\nThere is a natural point at which we can return the memory our String\nneeds to the operating system: when s goes out of scope. When a variable\ngoes out of scope, Rust calls a special function for us. This function is\ncalled drop, and it\u2019s where the author of String can put the code to return\nthe memory. Rust calls drop automatically at the closing curly bracket.\n\nIn C++, this pattern of deallocating resources at the end of an item\u2019s lifetime is some-\ntimes called Resource Acquisition Is Initialization (RAII). The drop function in\nRust will be familiar to you if you've used RAII patterns.\n\nThis pattern has a profound impact on the way Rust code is written. It\nmay seem simple right now, but the behavior of code can be unexpected in\nmore complicated situations when we want to have multiple variables use the\ndata we've allocated on the heap. Let\u2019s explore some of those situations now.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 4.7,
                        "section_name": "Ways That Variables and Data Interact: Move",
                        "section_path": "./screenshots-images-2/chapter_4/section_7",
                        "images": [
                            "./screenshots-images-2/chapter_4/section_7/4d787591-92c8-439f-963e-f4e9637c166e.png",
                            "./screenshots-images-2/chapter_4/section_7/2ec32030-2fd4-42d5-a071-aaafe12ad022.png",
                            "./screenshots-images-2/chapter_4/section_7/baf9c902-57a9-4294-9b0f-a127c9ecd50c.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Ways That Variables and Data Interact: Move\n\nMultiple variables can interact with the same data in different ways in Rust.\nLet\u2019s look at an example using an integer in Listing 4-2.\n\nlet x\nlet y\n\n53\nx;\n\nListing 4-2: Assigning the integer value of variable x to y\n\nWe can probably guess what this is doing: \u201cbind the value \u00a75 to x; then\nmake a copy of the value in x and bind it to y.\u201d We now have two variables, x\nand y, and both equal 5. This is indeed what is happening, because integers\nare simple values with a known, fixed size and these two 5 values are pushed\nonto the stack.\n\nNow let\u2019s look at the String version:\n\nlet s1\nlet s2\n\nString: :from(\"hello\");\n$1;\n\nThis looks very similar to the previous code, so we might assume that\nthe way it works would be the same: that is, the second line would make a\ncopy of the value in s1 and bind it to s2. But this isn\u2019t quite what happens.\n\nTake a look at Figure 4-1 to see what is happening to String under the\ncovers. A String is made up of three parts, shown on the left: a pointer to\nthe memory that holds the contents of the string, a length, and a capacity.\nThis group of data is stored on the stack. On the right is the memory on the\nheap that holds the contents.\n\nThe length is how much si\nmemory, in bytes, the contents\nof the String is currently using.\nThe capacity is the total amount\nof memory, in bytes, that the String\nhas received from the operating\nsystem. The difference between\nlength and capacity matters, but\n\nnot in this context, so for now, it\u2019s . a\nu text, mW, Figure 4-1: Representation in memory\n\nfine to ignore the capacity. of a String holding the value \u201chello\u201d\nWhen we assign s1 to s2, the bound to s1\n\nString data is copied, meaning we\n\ncopy the pointer, the length, and the\n\ncapacity that are on the stack. We do not copy the data on the heap that the\npointer refers to. In other words, the data representation in memory looks\nlike Figure 4-2.\n\nThe representation does not look like Figure 4-3, which is what memory\nwould look like if Rust instead copied the heap data as well. If Rust did this,\nthe operation s2 = s1 could be very expensive in terms of runtime perfor-\nmance if the data on the heap were large.\n\nFigure 4-2: Representation in memo: Figure 4-3: Another possibility for what\nof the variable s2 that has a copy of the s2 = s1 might do if Rust copied the\npointer, length, and capacity of s1 heap data as well\n\nEarlier, we said that when a variable goes out of scope, Rust automati-\ncally calls the drop function and cleans up the heap memory for that variable.\nBut Figure 4-2 shows both data pointers pointing to the same location. This is\na problem: when s2 and s1 go out of scope, they will both try to free the same\nmemory. This is known as a double free error and is one of the memory safety\nbugs we mentioned previously. Freeing memory twice can lead to memory\ncorruption, which can potentially lead to security vulnerabilities.\n\nTo ensure memory safety, there\u2019s one more detail to what happens in\nthis situation in Rust. Instead of trying to copy the allocated memory, Rust\nconsiders s1 to no longer be valid and, therefore, Rust doesn\u2019t need to free\nanything when s1 goes out of scope. Check out what happens when you try\nto use s1 after s2 is created; it won't work:\n\nlet si\nlet s2\n\nString: :from(\"hello\");\n$1;\n\nprintln!(\"{}, world!\", s1);\n\nYou'll get an error like this because Rust prevents you from using the\ninvalidated reference:\n\nerror[E0382]: use of moved value: \u201csi\u201d\n--> src/main.rs:5:28\n\n|\n3 | let s2 = s1;\n-- value moved here\n\n|\n4)\n5] println!(\"{}, world!\", s1);\n| ** value used here after move\n|\n\n= note: move occurs because ~s1~ has type \u201cstd::string::String\u2019, which does\nnot implement the \u201cCopy\u201d trait\n\nIf you've heard the terms shallow\ncopy and deep copy while working with\nother languages, the concept of copy-\ning the pointer, length, and capacity\nwithout copying the data probably\nsounds like making a shallow copy.\nBut because Rust also invalidates the\nfirst variable, instead of being called\na shallow copy, it\u2019s known as a move.\nIn this example, we would say that s1\nwas moved into s2. So what actually\nhappens is shown in Figure 4-4.\n\nThat solves our problem! With\nonly s2 valid, when it goes out of\n\nFigure 4-4: Representation in memory\nscope, it alone will free the memory, after s1 has been invalidated\n\nand we're done.\n\nIn addition, there\u2019s a design choice that's implied by this: Rust will\nnever automatically create \u201cdeep\u201d copies of your data. Therefore, any\nautomatic copying can be assumed to be inexpensive in terms of runtime\nperformance.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 4.8,
                        "section_name": "Ways That Variables and Data Interact: Clone",
                        "section_path": "./screenshots-images-2/chapter_4/section_8",
                        "images": [
                            "./screenshots-images-2/chapter_4/section_8/d3981db8-c889-4590-9d09-d4a69c032c7f.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Ways That Variables and Data Interact: Clone\n\nIf we do want to deeply copy the heap data of the String, not just the stack\ndata, we can use a common method called clone. We'll discuss method syn-\ntax in Chapter 5, but because methods are a common feature in many pro-\ngramming languages, you've probably seen them before.\n\nHere\u2019s an example of the clone method in action:\n\nlet si\nlet s2\n\nString: :from(\"hello\");\ns1.clone();\n\nprintln!(\"s1 = {}, s2 = {}\", s1, s2);\n\nThis works just fine and explicitly produces the behavior shown in\nFigure 4-3, where the heap data does get copied.\n\nWhen you see a call to clone, you know that some arbitrary code is being\nexecuted and that code may be expensive. It\u2019s a visual indicator that some-\nthing different is going on.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 4.9,
                        "section_name": "Stack-Only Data: Copy",
                        "section_path": "./screenshots-images-2/chapter_4/section_9",
                        "images": [
                            "./screenshots-images-2/chapter_4/section_9/ffdfb33a-7081-42a3-b824-9e76c9ebb402.png",
                            "./screenshots-images-2/chapter_4/section_9/8c99b5c9-53dd-4734-bc2e-ee74931975ec.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Stack-Only Data: Copy\nThere's another wrinkle we haven't talked about yet. This code using integers,\npart of which was shown in Listing 4-2, works and is valid:\n\nlet x\nlet y\n\n53\nx5\n\nprintln! (\"x = {}, y = (\"sx y)s\n\nBut this code seems to contradict what we just learned: we don\u2019t have a\ncall to clone, but x is still valid and wasn\u2019t moved into y.\n\nThe reason is that types such as integers that have a known size at com-\npile time are stored entirely on the stack, so copies of the actual values are\nquick to make. That means there's no reason we would want to prevent x\nfrom being valid after we create the variable y. In other words, there\u2019s no dif-\nference between deep and shallow copying here, so calling clone wouldn't do\nanything different from the usual shallow copying and we can leave it out.\n\nRust has a special annotation called the Copy trait that we can place on\ntypes like integers that are stored on the stack (we'll talk more about traits\nin Chapter 10). If a type has the Copy trait, an older variable is still usable\nafter assignment. Rust won't let us annotate a type with the Copy trait if the\ntype, or any of its parts, has implemented the Drop trait. If the type needs\nsomething special to happen when the value goes out of scope and we add\nthe Copy annotation to that type, we'll get a compile-time error. To learn\nabout how to add the Copy annotation to your type, see Appendix C.\n\nSo what types are Copy? You can check the documentation for the given\ntype to be sure, but as a general rule, any group of simple scalar values can\n\nbe Copy, and nothing that requires allocation or is some form of resource is\nCopy. Here are some of the types that are Copy:\n\nAll the integer types, such as u32.\n\nThe Boolean type, bool, with values true and false.\nThe character type, char.\n\nAll the floating point types, such as f64.\n\nTuples, if they only contain types that are also Copy. For example, (132,\ni32) is Copy, but (132, String) is not.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 4.1,
                        "section_name": "Ownership and Functions",
                        "section_path": "./screenshots-images-2/chapter_4/section_10",
                        "images": [
                            "./screenshots-images-2/chapter_4/section_10/49813a0f-7b49-4d64-9cff-342d4476ffec.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nOwnership and Functions\n\nThe semantics for passing a value to a function are similar to those for\nassigning a value to a variable. Passing a variable to a function will move\nor copy, just as assignment does. Listing 4-3 has an example with some\nannotations showing where variables go into and out of scope.\n\nfn main() {\nlet s = String::from(\"hello\"); // s comes into scope\ntakes_ownership(s); // s's value moves into the function...\n// ... and so is no longer valid here\nlet x = 5; // x comes into scope\nmakes_copy(x); // x would move into the function,\n\n// but i32 is Copy, so it's okay to\n// still use x afterward\n\n} // Here, x goes out of scope, then s. But because s's value was moved,\n// nothing special happens.\n\nfn takes_ownership(some_string: String) { // some_string comes into scope\nprintln!(\"{}\", some_string);\n} // Here, some_string goes out of scope and \u201cdrop\u201d is called. The backing\n// memory is freed.\n\nfn makes_copy(some_integer: i32) { // some_integer comes into scope\nprintln!(\"{}\", some_integer);\n} // Here, some_integer goes out of scope. Nothing special happens.\n\nListing 4-3: Functions with ownership and scope annotated\n\nIf we tried to use s after the call to takes_ownership, Rust would throw a\ncompile-time error. These static checks protect us from mistakes. Try add-\ning code to main that uses s and x to see where you can use them and where\nthe ownership rules prevent you from doing so.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 4.11,
                        "section_name": "Return Values and Scope",
                        "section_path": "./screenshots-images-2/chapter_4/section_11",
                        "images": [
                            "./screenshots-images-2/chapter_4/section_11/de1ca5b7-4afe-4d09-b622-e0b7260a2cbf.png",
                            "./screenshots-images-2/chapter_4/section_11/bd3c754f-ebc8-482d-9eeb-d0e8c783fce0.png",
                            "./screenshots-images-2/chapter_4/section_11/88b79fa0-d4e6-40a0-87db-bb15d13637ca.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Return Values and Scope\n\nReturning values can also transfer ownership. Listing 4-4 is an example\nwith similar annotations to those in Listing 4-3.\n\nsrc/main.rs\n\nsrc/main.rs\n\nfn main() {\nlet s1 = gives_ownership(); // gives ownership moves its return\n// value into s1\n\nlet s2 = String::from(\"hello\"); // s2 comes into scope\n\nlet $3\n\ntakes_and_gives back(s2); // s2 is moved into\n// takes_and_gives back, which also\n// moves its return value into s3\n} // Here, s3 goes out of scope and is dropped. s2 goes out of scope but was\n// moved, so nothing happens. s1 goes out of scope and is dropped.\n\nfn gives ownership() -> String { // gives ownership will move its\n// return value into the function\n// that calls it\n\nlet some_string = String::from(\"hello\"); // some_string comes into scope\n\nsome_string // some_string is returned and\n// moves out to the calling\n// function\n\n}\n\n// takes_and_gives back will take a String and return one\nfn takes_and_gives back(a_string: String) -> String { // a_string comes into\n// scope\n\na_string // a_string is returned and moves out to the calling function\n\n}\n\nListing 4-4: Transferring ownership of return values\n\nThe ownership of a variable follows the same pattern every time: assign-\ning a value to another variable moves it. When a variable that includes data\non the heap goes out of scope, the value will be cleaned up by drop unless\nthe data has been moved to be owned by another variable.\n\nTaking ownership and then returning ownership with every function is\na bit tedious. What if we want to let a function use a value but not take own-\nership? It\u2019s quite annoying that anything we pass in also needs to be passed\nback if we want to use it again, in addition to any data resulting from the\nbody of the function that we might want to return as well.\n\nIt\u2019s possible to return multiple values using a tuple, as shown in\nListing 4-5.\n\nfn main() {\nlet s1 = String::from(\"hello\");\n\nlet (s2, len) = calculate_length(s1);\n\nprintln!(\"The length of '{}' is {}.\", s2, len);\n\nfn calculate_length(s: String) -> (String, usize) {\nlet length = s.len(); // len() returns the length of a String\n\n(s, length)\n\nListing 4-5: Returning ownership of parameters\n\nBut this is too much ceremony and a lot of work for a concept that should\nbe common. Luckily for us, Rust has a feature for this concept, called references.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 4.12,
                        "section_name": "References and Borrowing",
                        "section_path": "./screenshots-images-2/chapter_4/section_12",
                        "images": [
                            "./screenshots-images-2/chapter_4/section_12/ed7eb83c-a176-4e77-9110-3202cd8513cc.png",
                            "./screenshots-images-2/chapter_4/section_12/5cb5165a-2fb2-4804-bb72-8e4f0829bd25.png",
                            "./screenshots-images-2/chapter_4/section_12/d5814f1e-3b42-4369-afa3-cb0021835c7f.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "References and Borrowing\n\nsrc/main.rs\n\nThe issue with the tuple code in Listing 4-5 is that we have to return the\nString to the calling function so we can still use the String after the call to\ncalculate_length, because the String was moved into calculate_length.\n\nHere is how you would define and use a calculate_length function that\nhas a reference to an object as a parameter instead of taking ownership of\nthe value:\n\nfn main() {\nlet si = String::from(\"hello\");\n\nlet len = calculate_length(&s1);\n\nprintln!(\"The length of '{}' is {}.\", s1, len);\n\n}\n\nfn calculate_length(s: &String) -> usize {\ns.len()\n\n}\n\nFirst, notice that all the tuple code in the variable declaration and\nthe function return value is gone. Second, note that we pass &s1 into\ncalculate_length and, in its definition, we take &String rather than String.\n\nThese ampersands are references, and they allow you to refer to some\nvalue without taking ownership of it. Figure 4-5 shows a diagram.\n\nFigure 4-5: A diagram of &String s pointing at String s1\n\nThe opposite of referencing by using & is dereferencing, which is accomplished with\nthe dereference operator, *. We'll see some uses of the dereference operator in Chapter 8\nand discuss details of dereferencing in Chapter 15.\n\nsrc/main.rs\n\nLet's take a closer look at the function call here:\nlet si = String: :from(\"hello\");\n\nlet len = calculate_length(&s1);\n\nThe &s1 syntax lets us create a reference that refers to the value of s1 but\ndoes not own it. Because it does not own it, the value it points to will not be\ndropped when the reference goes out of scope.\n\nLikewise, the signature of the function uses & to indicate that the type\nof the parameter s is a reference. Let's add some explanatory annotations:\n\nfn calculate_length(s: &String) -> usize { // s is a reference to a String\ns.len()\n} // Here, s goes out of scope. But because it does not have ownership of\n// what it refers to, nothing happens.\n\nThe scope in which the variable s is valid is the same as any function\nparameter\u2019s scope, but we don\u2019t drop what the reference points to when it\ngoes out of scope because we don\u2019t have ownership. When functions have\nreferences as parameters instead of the actual values, we don\u2019t need to return\nthe values in order to give back ownership, because we never had ownership.\n\nWe call having references as function parameters borrowing. As in real\nlife, if a person owns something, you can borrow it from them. When you're\ndone, you have to give it back.\n\nSo what happens if we try to modify something we're borrowing? Try\nthe code in Listing 4-6. Spoiler alert: it doesn\u2019t work!\n\nfn main() {\nlet s = String::from(\"hello\");\n\nchange(&s) ;\n\nfn change(some_string: &String) {\nsome_string.push_str(\", world\");\n}\n\nListing 4-6: Attempting to modify a borrowed value\n\nHere's the error:\n\nerror[E0596]: cannot borrow immutable borrowed content ~*some_string\u2122 as\nmutable\n\n--> error.rs:8:5\n\n|\n7 | fn change(some_string: &String) {\n\nPo nee ee use \u201c&mut String\u201d here to make mutable\n8 | some_string.push_str(\", world\");\n\n| AAAAAAKAAAN Cannot borrow as mutable\n\n\nJust as variables are immutable by default, so are references. We're not\nallowed to modify something we have a reference to.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 4.13,
                        "section_name": "Mutable References",
                        "section_path": "./screenshots-images-2/chapter_4/section_13",
                        "images": [
                            "./screenshots-images-2/chapter_4/section_13/fa0cdc2f-ed72-4951-89b3-bcd5653850cd.png",
                            "./screenshots-images-2/chapter_4/section_13/b767f2c2-8e99-47a2-8f86-f0f9301e3c54.png",
                            "./screenshots-images-2/chapter_4/section_13/e95ad326-1bc3-4b46-9b88-b424dc90c0a9.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nsrc/main.rs\n\nMutable References\n\nWe can fix the error in the code from Listing 4-6 with just a small tweak:\n\nfn main() {\nlet mut s = String::from(\"hello\");\n\nchange(&mut s);\n}\n\nfn change(some_string: &mut String) {\nsome_string.push_str(\", world\");\n}\n\nFirst, we had to change s to be mut. Then we had to create a mutable\nreference with &mut s and accept a mutable reference with some_string:\n&mut String.\n\nBut mutable references have one big restriction: you can have only one\nmutable reference to a particular piece of data in a particular scope. This\ncode will fail:\n\nlet mut s = String: :from(\"hello\");\n\nlet r1 = &mut s;\nlet r2 = &mut s;\n\nprintln!(\"{}, {}\", x1, 12);\n\nHere\u2019s the error:\n\nerror[E0499]: cannot borrow ~s* as mutable more than once at a time\n--> src/main.rs:5:14\n\n|\n4| let r1 = &mut s;\n| wee eee first mutable borrow occurs here\n|\n\n5 let 12 = &mut s;\n\n| A*44\u00ae second mutable borrow occurs here\n6 |\n7 | printlni(\"{}, {}\", x1, 12)5\n\n|\n\n-- first borrow later used here\n\nThis restriction allows for mutation but in a very controlled fashion. It\u2019s\nsomething that new Rustaceans struggle with, because most languages let\nyou mutate whenever you'd like.\n\nThe benefit of having this restriction is that Rust can prevent data races\nat compile time. A data race is similar to a race condition and happens when\nthese three behaviors occur:\n\ne Two or more pointers access the same data at the same time.\ne Atleast one of the pointers is being used to write to the data.\ne There's no mechanism being used to synchronize access to the data.\n\nData races cause undefined behavior and can be difficult to diagnose\nand fix when you're trying to track them down at runtime; Rust prevents\nthis problem from happening because it won't even compile code with\ndata races!\n\nAs always, we can use curly brackets to create a new scope, allowing for\nmultiple mutable references, just not simultaneous ones:\n\nlet mut s = String: :from(\"hello\");\n\nlet r1 = &mut s;\n\n} // 1 goes out of scope here, so we can make a new reference with no\n// problems.\n\nlet r2 = &mut s;\n\nAsimilar rule exists for combining mutable and immutable references.\nThis code results in an error:\n\nlet mut s = String::from(\"hello\");\nlet ri = &s; // no problem\n\nlet 12 = &s; // no problem\n\nlet r3 = &mut s; // BIG PROBLEM\n\nprintln!(\"{}, {}, and {}\", ri, 12, 13);\nHere\u2019s the error:\n\nerror[E0502]: cannot borrow ~s~ as mutable because it is also borrowed as\nimmutable\n--> src/main.rs:6:14\n\n-- immutable borrow later used here\n\n4| let r1 = &; // no problem\n\n| -- immutable borrow occurs here\n5 | let r2 = &; // no problem\n6 | let r3 = &mut s; // BIG PROBLEM\n\n| *aeea\u00ae mutable borrow occurs here\n7 |\n8 | println!(\"{}, {}, and {}\", r1, x2, 13);\n\n\nWhew! We also cannot have a mutable reference while we have an\nimmutable one. Users of an immutable reference don\u2019t expect the values\nto suddenly change out from under them! However, multiple immutable\nreferences are okay because no one who is just reading the data has the\nability to affect anyone else\u2019s reading of the data.\n\nEven though these errors may be frustrating at times, remember that it\u2019s\nthe Rust compiler pointing out a potential bug early (at compile time rather\nthan at runtime) and showing you exactly where the problem is. Then you\ndon\u2019t have to track down why your data isn\u2019t what you thought it was.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 4.14,
                        "section_name": "Dangling References",
                        "section_path": "./screenshots-images-2/chapter_4/section_14",
                        "images": [
                            "./screenshots-images-2/chapter_4/section_14/8da3249a-1535-4e8c-85d0-becb95bc0819.png",
                            "./screenshots-images-2/chapter_4/section_14/2e3432cf-c8ad-497c-98f7-5b4e7179a661.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nDangling References\n\nIn languages with pointers, it\u2019s easy to erroneously create a dangling pointer,\na pointer that references a location in memory that may have been given to\nsomeone else, by freeing some memory while preserving a pointer to that\nmemory. In Rust, by contrast, the compiler guarantees that references will\nnever be dangling references: if you have a reference to some data, the com-\npiler will ensure that the data will not go out of scope before the reference\nto the data does.\n\nLet\u2019s try to create a dangling reference, which Rust will prevent with a\ncompile-time error:\n\nfn main() {\nlet reference_to_nothing = dangle();\n}\n\nfn dangle() -> &String {\nlet s = String::from(\"hello\");\n\nas\n\nHere\u2019s the error:\n\nerror[E0106]: missing lifetime specifier\n--> main.rs:5:16\n|\n5 | fn dangle() -> &String {\n| \u201cexpected lifetime parameter\n|\n= help: this function's return type contains a borrowed value, but there is\nno value for it to be borrowed from\nhelp: consider giving it a \u2018static lifetime\n\nThis error message refers to a feature we haven't covered yet: lifetimes.\nWe'll discuss lifetimes in detail in Chapter 10. But, if you disregard the\nparts about lifetimes, the message does contain the key to why this code\nis a problem:\n\nthis function's return type contains a borrowed value, but there is\nno value for it to be borrowed from.\n\nsrc/main.rs\n\nsrc/main.rs\n\nLet's take a closer look at exactly what's happening at each stage of our\ndangle code:\n\nfn dangle() -> &String { // dangle returns a reference to a String\nlet s = String::from(\"hello\"); // s is a new String\n\n&s // we return a reference to the String, s\n} // Here, s goes out of scope, and is dropped. Its memory goes away.\n// Danger!\n\nBecause s is created inside dangle, when the code of dangle is finished, s\nwill be deallocated. But we tried to return a reference to it. That means this\nreference would be pointing to an invalid String. That's no good! Rust won't\nlet us do this.\n\nThe solution here is to return the String directly:\n\nfn no_dangle() -> String {\nlet s = String::from(\"hello\");\n\ns\n\nThis works without any problems. Ownership is moved out, and nothing\nis deallocated.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 4.15,
                        "section_name": "The Rules of References",
                        "section_path": "./screenshots-images-2/chapter_4/section_15",
                        "images": [
                            "./screenshots-images-2/chapter_4/section_15/91b56bc3-bad4-48e6-b9ce-db8237cf68cf.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "The Rules of References\n\nLet\u2019s recap what we've discussed about references:\n\ne Atany given time, you can have either but not both of the following: one\nmutable reference orany number of immutable references.\n\ne References must always be valid.\n\nNext, we'll look at a different kind of reference: slices.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 4.16,
                        "section_name": "The Slice Type",
                        "section_path": "./screenshots-images-2/chapter_4/section_16",
                        "images": [
                            "./screenshots-images-2/chapter_4/section_16/681210af-1d27-4216-a43a-6ad8f45aa80f.png",
                            "./screenshots-images-2/chapter_4/section_16/4fd29a90-ef1e-4c46-9759-817181078a65.png",
                            "./screenshots-images-2/chapter_4/section_16/07fe2650-046b-4deb-b24d-26e21e4e904c.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "The Slice Type\n\nAnother data type that does not have ownership is the stice. Slices let you\nreference a contiguous sequence of elements in a collection rather than the\nwhole collection.\n\nHere\u2019s a small programming problem: write a function that takes a string\nand returns the first word it finds in that string. If the function doesn\u2019t find\na space in the string, the whole string must be one word, so the entire string\nshould be returned.\n\nLet\u2019s think about the signature of this function:\n\nfn first_word(s: &String) -> ?\n\nsrc/main.rs\n\nsrc/main.rs\n\nThis function, first_word, has a &String as a parameter. We don\u2019t want\nownership, so this is fine. But what should we return? We don't really have a\nway to talk about part of a string. However, we could return the index of the\nend of the word. Let\u2019s try that, as shown in Listing 4-7.\n\nfn first_word(s: &String) -> usize {\n@ let bytes = s.as_bytes();\n\nfor (i, &item)@ in bytes.iter()@.enumerate() {\n\u00a9 if item == b' ' {\nreturn i;\n}\n\n}\n\n@ s.len()\n}\n\nListing 4-7: The first_word function that returns a byte index value into the String\nparameter\n\nBecause we need to go through the String element by element and check\nwhether a value is a space, we'll convert our String to an array of bytes using\nthe as_bytes method @. Next, we create an iterator over the array of bytes\nusing the iter method \u00a9.\n\nWe'll discuss iterators in more detail in Chapter 13. For now, know that\niter is a method that returns each element in a collection and that enumerate\nwraps the result of iter and returns each element as part of a tuple instead.\nThe first element of the tuple returned from enumerate is the index, and the\nsecond element is a reference to the element. This is a bit more convenient\nthan calculating the index ourselves.\n\nBecause the enumerate method returns a tuple, we can use patterns to\ndestructure that tuple, just like everywhere else in Rust. So in the for loop,\nwe specify a pattern that has i for the index in the tuple and &item for the\nsingle byte in the tuple @. Because we get a reference to the element from\n-iter().enumerate(), we use & in the pattern.\n\nInside the for loop, we search for the byte that represents the space by\nusing the byte literal syntax \u00ae. If we find a space, we return the position.\nOtherwise, we return the length of the string by using s.len() \u00a9.\n\nWe now have a way to find out the index of the end of the first word in\nthe string, but there\u2019s a problem. We\u2019re returning a usize on its own, but\nit\u2019s only a meaningful number in the context of the &String. In other words,\nbecause it\u2019s a separate value from the String, there\u2019s no guarantee that it\nwill still be valid in the future. Consider the program in Listing 4-8 that\nuses the first_word function from Listing 4-7.\n\nfn main() {\nlet mut s = String::from(\"hello world\");\n\nlet word = first_word(&s); // word will get the value 5\n\ns.clear(); // this empties the String, making it equal to \"\"\n\n// word still has the value 5 here, but there's no more string that\n// we could meaningfully use the value 5 with. word is now totally\n// invalid!\n\n}\n\nListing 4-8: Storing the result from calling the first_word function and then changing the\nString contents\n\nThis program compiles without any errors and would also do so if we\nused word after calling s.clear(). Because word isn\u2019t connected to the state\nof s at all, word still contains the value 5. We could use that value 5 with the\nvariable s to try to extract the first word, but this would be a bug because\nthe contents of s have changed since we saved 5 in word.\n\nHaving to worry about the index in word getting out of syne with the\ndata in s is tedious and error prone! Managing these indices is even more\nbrittle if we write a second_word function. Its signature would have to look\nlike this:\n\nfn second_word(s: &String) -> (usize, usize) {\n\nNow we're tracking a starting and an ending index, and we have even\nmore values that were calculated from data in a particular state but aren\u2019t\ntied to that state at all. We now have three unrelated variables floating\naround that need to be kept in sync.\n\nLuckily, Rust has a solution to this problem: string slices.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 4.17,
                        "section_name": "String Slices",
                        "section_path": "./screenshots-images-2/chapter_4/section_17",
                        "images": [
                            "./screenshots-images-2/chapter_4/section_17/1487a670-10f0-40bf-8316-813edc32c001.png",
                            "./screenshots-images-2/chapter_4/section_17/16be6bc4-435c-4523-9e93-312b87f0b2d2.png",
                            "./screenshots-images-2/chapter_4/section_17/ce0bbdaa-7c9f-472d-a75f-01a11d46be87.png",
                            "./screenshots-images-2/chapter_4/section_17/9a6b7957-a061-4a10-84fe-05beb83d163b.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "String Slices\n\nA string slice is a reference to part of a String, and it looks like this:\nlet s = String::from(\"hello world\");\n\nlet hello = &s[0..5];\nlet world = &s[6..11];\n\nThis is similar to taking a reference to the whole String but with the\nextra [0..5] bit. Rather than a reference to the entire String, it\u2019s a reference\nto a portion of the String.\n\nWe can create slices using a range within brackets by specifying\n[starting _index..ending index], where starting_index is the first position in\nthe slice and ending_index is one more than the last position in the slice.\nInternally, the slice data structure stores the starting position and the\nlength of the slice, which corresponds to ending index minus starting_index.\nSo at @, world would be a slice that contains a pointer to the 7th byte of s\nwith a length value of 5.\n\nFigure 4-6 shows this in a diagram.\n\nFigure 4-6: String slice referring to part of a String\n\nWith Rust\u2019s .. range syntax, if you want to start at the first index (zero),\nyou can drop the value before the two periods. In other words, these are\nequal:\n\nlet s = String::from(\"hello\");\n\nlet slice\nlet slice\n\n&s[0..2];\n&s[..2];\n\nBy the same token, if your slice includes the last byte of the String, you\ncan drop the trailing number. That means these are equal:\n\nlet s = String::from(\"hello\");\nlet len = s.len();\n\nlet slice\nlet slice\n\n&s[3..len];\n&s[3..];\n\nYou can also drop both values to take a slice of the entire string. So\nthese are equal:\n\nlet s = String::from(\"hello\");\nlet len = s.len();\n\nlet slice\nlet slice\n\n&s[0..len];\nas[..];\n\nString slice range indices must occur at valid UTF-8 character boundaries. If you\nattempt to create a string slice in the middle of a multibyte character, your program\n\nsrc/main.rs\n\nsrc/main.rs\n\nwill exit with an error. For the purposes of introducing string slices, we are assum-\ning ASCII only in this section; a more thorough dicussion of UTF-8 handling is in\n\u201cStoring UTF-8 Encoded Text with Strings\u201d on page 137.\n\nWith all this information in mind, let\u2019s rewrite first_word to return a slice.\nThe type that signifies \u201cstring slice\u201d is written as &str:\n\nfn first_word(s: &String) -> &str {\nlet bytes = s.as_bytes();\n\nfor (i, &item) in bytes.iter().enumerate() {\nif item == b' ' {\nreturn &s[0..i];\n}\n\n}\n&s[..]\n\nWe get the index for the end of the word in the same way as we did in\nListing 4-7, by looking for the first occurrence of a space. When we find a\nspace, we return a string slice using the start of the string and the index of\nthe space as the starting and ending indices.\n\nNow when we call first_word, we get back a single value that is tied to\nthe underlying data. The value is made up of a reference to the starting\npoint of the slice and the number of elements in the slice.\n\nReturning a slice would also work for a second_word function:\n\nfn second_word(s: &String) -> &str {\n\nWe now have a straightforward API that\u2019s much harder to mess up,\nbecause the compiler will ensure the references into the String remain\nvalid. Remember the bug in the program in Listing 4-8, when we got the\nindex to the end of the first word but then cleared the string so our index\nwas invalid? That code was logically incorrect but didn\u2019t show any immedi-\nate errors. The problems would show up later if we kept trying to use the\nfirst word index with an emptied string. Slices make this bug impossible and\nlet us know we have a problem with our code much sooner. Using the slice\nversion of first_word will throw a compile-time error:\n\nfn main() {\nlet mut s = String::from(\"hello world\");\n\nlet word = first_word(&s) ;\ns.clear(); // error!\n\nprintln!(\"the first word is: {}\", word);\n\n\nHere\u2019s the compiler error:\n\nerror[\u00a30502]: cannot borrow \u201cs\u00b0 as mutable because it is also borrowed as\nimmutable\n--> src/main.rs:18:5\n\n16 | let word = first_word(&s) ;\n| -- immutable borrow occurs here\n17 |\n18 | s.clear(); // error!\n| AAAAAAADN mutable borrow occurs here\n19 |\n20 | println!(\"the first word is: {}\", word);\n|\n\n---- immutable borrow later used here\n\nRecall from the borrowing rules that if we have an immutable refer-\nence to something, we cannot also take a mutable reference. Because clear\nneeds to truncate the String, it tries to take a mutable reference, which fails.\nNot only has Rust made our API easier to use, but it has also eliminated an\nentire class of errors at compile time!\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 4.18,
                        "section_name": "String Literals Are Slices",
                        "section_path": "./screenshots-images-2/chapter_4/section_18",
                        "images": [
                            "./screenshots-images-2/chapter_4/section_18/526e20aa-f63b-4e54-a017-9cf7d6909b15.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "String Literals Are Slices\n\nRecall that we talked about string literals being stored inside the binary.\nNow that we know about slices, we can properly understand string literals:\n\nlet s = \u201cHello, world!\";\n\nThe type of s here is &str: it\u2019s a slice pointing to that specific point of\nthe binary. This is also why string literals are immutable; str is an immu-\ntable reference.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 4.19,
                        "section_name": "String Slices as Parameters",
                        "section_path": "./screenshots-images-2/chapter_4/section_19",
                        "images": [
                            "./screenshots-images-2/chapter_4/section_19/afedf164-f8fe-404b-acc0-79d27bc9a553.png",
                            "./screenshots-images-2/chapter_4/section_19/389ad6f4-dff0-4b8d-adaf-13db47030d3e.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "String Slices as Parameters\n\nKnowing that you can take slices of literals and String values leads us to one\nmore improvement on first_word, and that\u2019s its signature:\n\nfn first_word(s: &String) -> &str {\n\nAmore experienced Rustacean would write the signature shown in\nListing 4-9 instead because it allows us to use the same function on both\nString and &str values.\n\nfn first_word(s: &str) -> &str {\n\nListing 4-9: Improving the first_word function by using a string slice for the type of the s\nparameter\n\nIf we have a string slice, we can pass that directly. If we have a String, we\ncan pass a slice of the entire String. Defining a function to take a string slice\ninstead of a reference to a String makes our API more general and useful\nwithout losing any functionality:\n\nsrc/main.rs fn main() {\nlet my_string = String::from(\"hello world\");\n\n// first_word works on slices of ~String\u2019s\nlet word = first_word(&my string[..]);\n\nlet my_string literal = \u201chello world\";\n\n// first_word works on slices of string literals\nlet word = first_word(&my string literal[..]);\n\n// Because string literals *tare* string slices already,\n// this works too, without the slice syntax!\nlet word = first_word(my string literal);\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 4.2,
                        "section_name": "Other Slices",
                        "section_path": "./screenshots-images-2/chapter_4/section_20",
                        "images": [
                            "./screenshots-images-2/chapter_4/section_20/1791a5db-0fc6-4abe-8805-b2413643802b.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Other Slices\n\nString slices, as you might imagine, are specific to strings. But there's a\nmore general slice type, too. Consider this array:\n\nlet a = [1, 2, 3, 4, 5];\n\nJust as we might want to refer to a part of a string, we might want to\nrefer to part of an array. We'd do so like this:\n\nlet a = [1, 2, 3, 4, 5];\nlet slice = &a[1..3];\n\nThis slice has the type 8[i32]. It works the same way as string slices do,\nby storing a reference to the first element and a length. You'll use this kind\nof slice for all sorts of other collections. We'll discuss these collections in\ndetail when we talk about vectors in Chapter 8.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 4.21,
                        "section_name": "Summary",
                        "section_path": "./screenshots-images-2/chapter_4/section_21",
                        "images": [
                            "./screenshots-images-2/chapter_4/section_21/6e798e1c-cd87-4cb1-a671-9c0caf59dd20.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Summary\n\nThe concepts of ownership, borrowing, and slices ensure memory safety in\nRust programs at compile time. The Rust language gives you control over\nyour memory usage in the same way as other systems programming lan-\nguages, but having the owner of data automatically clean up that data when\nthe owner goes out of scope means you don\u2019t have to write and debug extra\ncode to get this control.\n\nOwnership affects how lots of other parts of Rust work, so we'll talk\nabout these concepts further throughout the rest of the book. Let\u2019s move\non to Chapter 5 and look at grouping pieces of data together in a struct.\n",
                        "extracted-code": ""
                    }
                ]
            },
            {
                "chapter_id": 5,
                "chapter_name": "USING STRUCTS TO STRUCTURE\nRELATED DATA",
                "chapter_path": "./screenshots-images-2/chapter_5",
                "sections": [
                    {
                        "section_id": 5.1,
                        "section_name": "USING STRUCTS TO STRUCTURE\nRELATED DATA",
                        "section_path": "./screenshots-images-2/chapter_5/section_1",
                        "images": [
                            "./screenshots-images-2/chapter_5/section_1/edc48ed0-fb8f-4ff5-abd3-4990fdc916e8.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "USING STRUCTS TO STRUCTURE\nRELATED DATA\n\nA struct, or structure, is a custom data type\nthat lets you name and package together\nmultiple related values that make up a\nmeaningful group. If you\u2019re familiar with an\nobject-oriented language, a struct is like an object\u2019s\n\ndata attributes. In this chapter, we\u2019ll compare and\n\ncontrast tuples with structs, demonstrate how to use structs, and discuss\nhow to define methods and associated functions to specify behavior associ-\nated with a struct\u2019s data. Structs and enums (discussed in Chapter 6) are the\nbuilding blocks for creating new types in your program's domain to take full\nadvantage of Rust\u2019s compile time type checking.\n\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 5.2,
                        "section_name": "Defining and Instantiating Structs",
                        "section_path": "./screenshots-images-2/chapter_5/section_2",
                        "images": [
                            "./screenshots-images-2/chapter_5/section_2/928b85fb-a3fc-484f-84ea-dd3972729fdf.png",
                            "./screenshots-images-2/chapter_5/section_2/e1e0130b-8651-431b-b938-4c4368dd6150.png",
                            "./screenshots-images-2/chapter_5/section_2/c0ec996f-88fd-4a64-95a7-94d6105286d0.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Defining and Instantiating Structs\n\nStructs are similar to tuples, which were discussed in Chapter 3. Like tuples,\nthe pieces of a struct can be different types. Unlike with tuples, you'll name\neach piece of data so it\u2019s clear what the values mean. As a result of these\n\nnames, structs are more flexible than tuples: you don\u2019t have to rely on the\norder of the data to specify or access the values of an instance.\n\nTo define a struct, we enter the keyword struct and name the entire\nstruct. A struct\u2019s name should describe the significance of the pieces of\ndata being grouped together. Then, inside curly brackets, we define the\nnames and types of the pieces of data, which we call fields. For example,\nListing 5-1 shows a struct that stores information about a user account.\n\nstruct User {\nusername: String,\nemail: String,\nsign_in_count: u64,\nactive: bool,\n\n}\n\nListing 5-1: A User struct definition\n\nTo use a struct after we've defined it, we create an instance of that struct\nby specifying concrete values for each of the fields. We create an instance by\nstating the name of the struct and then add curly brackets containing key:\nvalue pairs, where the keys are the names of the fields and the values are the\ndata we want to store in those fields. We don't have to specify the fields in\nthe same order in which we declared them in the struct. In other words, the\nstruct definition is like a general template for the type, and instances fill in\nthat template with particular data to create values of the type. For example,\nwe can declare a particular user as shown in Listing 5-2.\n\nlet user1 = User {\nemail: String: :from(\"someone@example.com\"),\nusername: String: :from(\"someusername123\"),\nactive: true,\nsign_in_count: 1,\n\nhs\nListing 5-2: Creating an instance of the User struct\n\nTo get a specific value from a struct, we can use dot notation. If we wanted\njust this user\u2019s email address, we could use user1.email wherever we wanted to\nuse this value. If the instance is mutable, we can change a value by using the\ndot notation and assigning into a particular field. Listing 5-3 shows how to\nchange the value in the email field of a mutable User instance.\n\nlet mut user1 = User {\nemail: String: :from(\"someone@example.com\"),\nusername: String: :from(\"someusername123\"),\nactive: true,\nsign_in_count: 1,\n\nhs\nuseri.email = String: :from(\"anotheremail@example.com\");\n\nListing 5-3: Changing the value in the email field of a User instance\n\nNote that the entire instance must be mutable; Rust doesn\u2019t allow us\nto mark only certain fields as mutable. As with any expression, we can con-\nstruct a new instance of the struct as the last expression in the function\nbody to implicitly return that new instance.\n\nListing 5-4 shows a build_user function that returns a User instance with\nthe given email and username. The active field gets a value of true, and the\nsign_in_count gets a value of 1.\n\nfn build_user(email: String, username: String) -> User {\nUser {\nemail: email,\nusername: username,\nactive: true,\nsign_in_count: 1,\n\n}\n\nListing 5-4: A build_user function that takes an email and username and returns a User\ninstance\n\nIt makes sense to name the function parameters with the same name as\nthe struct fields, but having to repeat the email and username field names and\nvariables is a bit tedious. If the struct had more fields, repeating each name\nwould get even more annoying. Luckily, there\u2019s a convenient shorthand!\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 5.3,
                        "section_name": "Using the Field Init Shorthand When Variables and Fields\nHave the Same Name",
                        "section_path": "./screenshots-images-2/chapter_5/section_3",
                        "images": [
                            "./screenshots-images-2/chapter_5/section_3/5a05cc4e-711a-404f-992a-9b6055121aad.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Using the Field Init Shorthand When Variables and Fields\nHave the Same Name\n\nBecause the parameter names and the struct field names are exactly the same\nin Listing 5-4, we can use the field init shorthand syntax to rewrite build_user so\nthat it behaves exactly the same but doesn\u2019t have the repetition of email and\n\nusername, as shown in Listing 5-5.\n\nsild user(email: String, username: String) -> User {\nser\n\nemail,\n\nusername,\n\nListing 5-5: A build_user function that uses field init shorthand because the email and\nusername parameters have the same name as struct fields\n\nHere, we're creating a new instance of the User struct, which has a\nfield named email. We want to set the email field\u2019s value to the value in the\nemail parameter of the build_user function. Because the email field and\nthe email parameter have the same name, we only need to write email\nrather than email: email.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 5.4,
                        "section_name": "Geating Instances from Other Instances with Struct Update Syntax",
                        "section_path": "./screenshots-images-2/chapter_5/section_4",
                        "images": [
                            "./screenshots-images-2/chapter_5/section_4/94de3304-3e13-450f-a390-9b3561c54e3a.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Geating Instances from Other Instances with Struct Update Syntax\n\nIt\u2019s often useful to create a new instance of a struct that uses most of an old\ninstance\u2019s values but changes some. You'll do this using struct update syntax.\n\nFirst, Listing 5-6 shows how we create a new User instance in user2 without\nthe update syntax. We set new values for email and username but otherwise\nuse the same values from user1 that we created in Listing 5-2.\n\nlet user2 = User {\nemail: String::from(\"another@example.com\"),\nusername: String: :from(\"anotherusername567\"),\nactive: userl.active,\nsign_in_count: user1.sign_in_count,\n\nhs\nListing 5-6: Creating a new User instance using some of the values from user1\n\nUsing struct update syntax, we can achieve the same effect with less code,\nas shown in Listing 5-7. The syntax .. specifies that the remaining fields not\nexplicitly set should have the same value as the fields in the given instance.\n\nListing 5-7: Using struct update syntax to set new email and username values for a User\ninstance but use the rest of the values from the fields of the instance in the user1 variable\n\nThe code in Listing 5-7 also creates an instance in user2 that has a dif-\nferent value for email and username but has the same values for the active and\nsign_in_count fields from user1.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 5.5,
                        "section_name": "Using Tuple Structs Without Named Fields to Create Different Types",
                        "section_path": "./screenshots-images-2/chapter_5/section_5",
                        "images": [
                            "./screenshots-images-2/chapter_5/section_5/ecc516bc-f8dd-4b06-b8df-a02192eacfbd.png",
                            "./screenshots-images-2/chapter_5/section_5/79950e70-759c-45fe-8682-576bce316ef2.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Using Tuple Structs Without Named Fields to Create Different Types\n\nYou can also define structs that look similar to tuples, called tuple structs.\nTuple structs have the added meaning the struct name provides but don\u2019t\nhave names associated with their fields; rather, they just have the types of\nthe fields. Tuple structs are useful when you want to give the whole tuple a\nname and make the tuple be a different type from other tuples, and naming\neach field as in a regular struct would be verbose or redundant.\n\nTo define a tuple struct, start with the struct keyword and the struct\nname followed by the types in the tuple. For example, here are definitions\nand usages of two tuple structs named Color and Point:\n\nstruct Color(i32, i32, 132);\nstruct Point(i32, i32, 132);\n\nlet black = Color(0, 0, 0);\nlet origin = Point(0, 0, 0);\n\nNote that the black and origin values are different types, because they\u2019re\ninstances of different tuple structs. Each struct you define is its own type,\neven though the fields within the struct have the same types. For example, a\nfunction that takes a parameter of type Color cannot take a Point as an argu-\nment, even though both types are made up of three i32 values. Otherwise,\ntuple struct instances behave like tuples: you can destructure them into\ntheir individual pieces, you can use a . followed by the index to access an\nindividual value, and so on.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 5.6,
                        "section_name": "Unit-Like Structs Without Any Fields",
                        "section_path": "./screenshots-images-2/chapter_5/section_6",
                        "images": [
                            "./screenshots-images-2/chapter_5/section_6/c89a3b84-3ffa-46d1-9752-03555e2708f9.png",
                            "./screenshots-images-2/chapter_5/section_6/629a0c7b-802e-4736-839b-bf63132d1a06.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Unit-Like Structs Without Any Fields\n\nYou can also define structs that don\u2019t have any fields! These are called\nunit-like structs because they behave similarly to (), the unit type. Unit-like\nstructs can be useful in situations in which you need to implement a trait\non some type but don\u2019t have any data that you want to store in the type\nitself. We'll discuss traits in Chapter 10.\n\nOWNERSHIP OF STRUCT DATA\n\nIn the User struct definition in Listing 5-1, we use the owned String type rather\nthan the astr string slice type. This is a deliberate choice because we want\ninstances of this struct to own all of its data and for that data to be valid for as\nlong as the entire struct is valid.\n\nIt\u2019s possible for structs to store references to data owned by something\nelse, but to do so requires the use of lifetimes, a Rust feature that we'll discuss\nin Chapter 10. Lifetimes ensure that the data referenced by a struct is valid for\nas long as the struct is. Let\u2019s say you try to store a reference in a struct without\nspecifying lifetimes, like this, which won't work:\n\nsrc/main.rs struct User {\nusername: &str,\nemail: &str,\nsign_in_count: u64,\nactive: bool,\n}\n\nfn main() {\nlet user1 = User {\nemail: \u201csomeone@example.com\",\nusername: \u201csomeusername123\",\nactive: true,\nsign_in_count: 1,\n\n(continued)\n\n\nThe compiler will complain that it needs lifetime specifiers:\n\nerror[\u00a30106]: missing lifetime specifier\n->\n\n2 username: &str,\n\n\u201d expected lifetime parameter\nerror[\u00a30106]: missing lifetime specifier\n\nemail: &str,\n\u201d expected lifetime parameter\n\nIn Chapter 10, we'll discuss how to fix these errors so you can store refer-\nences in structs, but for now, we'll fix errors like these using owned types like\nString instead of references like &str.\n\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 5.7,
                        "section_name": "An Example Program Using Structs",
                        "section_path": "./screenshots-images-2/chapter_5/section_7",
                        "images": [
                            "./screenshots-images-2/chapter_5/section_7/7045f211-a5eb-4605-a2d4-a5ac603fa265.png",
                            "./screenshots-images-2/chapter_5/section_7/c68b51cb-0fe6-416b-a01a-d361ee531f4b.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "An Example Program Using Structs\n\nsrc/main.rs\n\nTo understand when we might want to use structs, let's write a program that\ncalculates the area of a rectangle. We'll start with single variables, and then\nrefactor the program until we\u2019re using structs instead.\n\nLet\u2019s make a new binary project with Cargo called rectangles that will\ntake the width and height of a rectangle specified in pixels and calculate\nthe area of the rectangle. Listing 5-8 shows a short program with one way\nof doing exactly that in our project\u2019s src/main.rs.\n\nfn main() {\nlet width1 = 30;\nlet height1 = 50;\n\nprintln!(\n\u201cThe area of the rectangle is {} square pixels.\",\narea(width1, height1)\n)3\n}\n\nfn area(width: u32, height: u32) -> u32 {\nwidth * height\n}\n\nListing 5-8: Calculating the area of a rectangle specified by separate width and height\nvariables\n\nNow, run this program using cargo run:\n\nThe area of the rectangle is 1500 square pixels.\n\n\nEven though Listing 5-8 works and figures out the area of the rectangle\nby calling the area function with each dimension, we can do better. The width\nand the height are related to each other because together they describe one\nrectangle.\n\nThe issue with this code is evident in the signature of area:\n\nfn area(width: u32, height: u32) -> u32 {\n\nThe area function is supposed to calculate the area of one rectangle, but\nthe function we wrote has two parameters. The parameters are related, but\nthat\u2019s not expressed anywhere in our program. It would be more readable\nand more manageable to group width and height together. We've already\ndiscussed one way we might do that in \"The Tuple Type\" on page 40: by\nusing tuples.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 5.8,
                        "section_name": "Refactoring with Tuples",
                        "section_path": "./screenshots-images-2/chapter_5/section_8",
                        "images": [
                            "./screenshots-images-2/chapter_5/section_8/02a440d8-0bc3-4670-ac18-2b6edd6226e8.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nRefactoring with Tuples\n\nListing 5-9 shows another version of our program that uses tuples.\n\nfn main()\n\nlet rect = (30, 50);\n\nprintln\n\"The area of the rectangle is {} square pixels.\",\n@ area(rect1)\n\nfn area(dimensions: (u32, u32)) -> u32 {\n\u00a9 dimensions.o * dimensions.1\n\n}\n\nListing 5-9: Specifying the width and height of the rectangle with a tuple\n\nIn one way, this program is better. Tuples let us add a bit of structure, and\nwe're now passing just one argument \u00ae. But in another way, this version is less\nclear: tuples don\u2019t name their elements, so our calculation has become more\n\nconfusing because we have to index into the parts of the tuple @.\n\nIt doesn\u2019t matter if we mix up width and height for the area calcula-\ntion, but if we want to draw the rectangle on the screen, it would matter!\nWe would have to keep in mind that width is the tuple index 0 and height\nis the tuple index 1. If someone else worked on this code, they would have\nto figure this out and keep it in mind as well. It would be easy to forget or\nmix up these values and cause errors, because we haven't conveyed the\n\nmeaning of our data in our code.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 5.9,
                        "section_name": "Refactoring with Structs: Adding More Meaning",
                        "section_path": "./screenshots-images-2/chapter_5/section_9",
                        "images": [
                            "./screenshots-images-2/chapter_5/section_9/8bdf6959-1245-4565-a5ba-57f74c8e2426.png",
                            "./screenshots-images-2/chapter_5/section_9/c260030a-9615-44d8-a43e-302714f5889c.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Refactoring with Structs: Adding More Meaning\n\nWe use structs to add meaning by labeling the data. We can transform\nthe tuple we\u2019re using into a data type with a name for the whole as well as\nnames for the parts, as shown in Listing 5-10.\n\nsr\u00a2/main.rs\n\n@ struct Rectangle {\n\n@ width: u32,\nheight: u32,\n\nn main\n\n\u00a9 let recti = Rectangle { width: 30, height: 50 };\n\nprintln! (\nThe area of the rectangle is {} square pixels.\",\n\narea(&rect1)\n\n}\n\n\u00a9 fn area(rectangle: &Rectangle) -> u32 {\n\n\u00a9 rectangle.width * rectangle.height\n}\n\nListing 5-10: Defining a Rectangle struct\n\nHere we've defined a struct and named it Rectangle @. Inside the curly\nbrackets, we defined the fields as width and height, both of which have type\nu32 @. Then in main, we created a particular instance of Rectangle that has a\nwidth of 30 and a height of 50 \u00a9.\n\nOur area function is now defined with one parameter, which we've\nnamed rectangle, whose type is an immutable borrow of a struct Rectangle\ninstance \u00ae. As mentioned in Chapter 4, we want to borrow the struct rather\nthan take ownership of it. This way, main retains its ownership and can con-\ntinue using rect1, which is the reason we use the & in the function signature\nand where we call the function.\n\nThe area function accesses the width and height fields of the Rectangle\ninstance \u00ae. Our function signature for area now says exactly what we mean:\ncalculate the area of Rectangle, using its width and height fields. This conveys\nthat the width and height are related to each other, and it gives descriptive\nnames to the values rather than using the tuple index values of 0 and 1.\nThis is a win for clarity.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 5.1,
                        "section_name": "Adding Useful Functionality with Derived Traits",
                        "section_path": "./screenshots-images-2/chapter_5/section_10",
                        "images": [
                            "./screenshots-images-2/chapter_5/section_10/f272ced8-e396-444e-ab93-7bbdc8a62cab.png",
                            "./screenshots-images-2/chapter_5/section_10/1576aaa5-ece9-4aaf-bc4c-e79ff90ea5da.png",
                            "./screenshots-images-2/chapter_5/section_10/e2938e01-2815-4984-8a35-86150407fb4b.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Adding Useful Functionality with Derived Traits\n\nIt'd be nice to be able to print an instance of Rectangle while we're debug-\nging our program and see the values for all its fields. Listing 5-11 tries\nusing the println! macro as we have used in previous chapters. This won\u2019t\nwork, however.\n\nsrc/main.rs\n\nsrc/main.rs\n\nprintln!(\"rect1 is {}\", rect1);\n\nListing 5-11: Attempting to print a Rectangle instance\n\nWhen we run this code, we get an error with this core message:\nerror[E0277]: \u201cRectangle\u201d doesn't implement ~std::fmt::Display\u201d\n\nThe println! macro can do many kinds of formatting, and by default,\nthe curly brackets tell println! to use formatting known as Display: output\nintended for direct end user consumption. The primitive types we've seen\nso far implement Display by default, because there\u2019s only one way you'd\nwant to show a 1 or any other primitive type to a user. But with structs, the\nway println! should format the output is less clear because there are more\ndisplay possibilities: Do you want commas or not? Do you want to print the\ncurly brackets? Should all the fields be shown? Due to this ambiguity, Rust\ndoesn\u2019t try to guess what we want, and structs don\u2019t have a provided imple-\nmentation of Display.\n\nIf we continue reading the errors, we'll find this helpful note:\n\nhelp: the trait \u201cstd::fmt::Display\u201d is not implemented for \u201cRectangle\nnote: in format strings you may be able to use ~{:?}\u00b0 (or {:#?} for pretty-\nprint) instead\n\nLet's try it! The println! macro call will now look like println!(\"rect1 is\n{:?}\", rect1);. Putting the specifier :? inside the curly brackets tells print1n!\nwe want to use an output format called Debug. The Debug trait enables us to\nprint our struct in a way that is useful for developers so we can see its value\nwhile we're debugging our code.\n\nRun the code with this change. Drat! We still get an error:\n\nerror[E0277]: ~Rectangle\u2019 doesn't implement ~std::fmt::Debug\u2122\nBut again, the compiler gives us a helpful note:\n\nhelp: the trait ~std::fmt::Debug\u201d is not implemented for \u201cRectangle\nnote: add ~#[derive(Debug)]~ or manually implement ~std:: fmt: :Debug\u2122\n\nRust does include functionality to print debugging information, but we\nhave to explicitly opt in to make that functionality available for our struct. To\ndo that, we add the annotation #[derive(Debug)] just before the struct defini-\ntion, as shown in Listing 5-12.\n\n#[derive(Debug)] _\n\nstruct Rectang\n\nwidth: u32\n\nheight: u32,\n\nfn main() {\n\nlet recti = Rectangle { width: 30, height: 50\n\nprintln!(\"recti is {:?}\", rect1);\n}\n\nListing 5-12: Adding the annotation to derive the Debug trait and printing the Rectangle\ninstance using debug formatting\n\nNow when we run the program, we won't get any errors, and we'll see\nthe following output:\n\nrecti is Rectangle { width: 30, height: 50 }\n\nNice! It\u2019s not the prettiest output, but it shows the values of all the fields\nfor this instance, which would definitely help during debugging. When we\nhave larger structs, it\u2019s useful to have output that\u2019s a bit easier to read; in\nthose cases, we can use {:#?} instead of {:?} in the println! string. When\nwe use the {:#?} style in the example, the output will look like this:\n\nrecti is Rectangle {\nwidth: 30,\nheight: 50\n\n}\n\nRust has provided a number of traits for us to use with the derive annota-\ntion that can add useful behavior to our custom types. Those traits and their\nbehaviors are listed in Appendix C. We'll cover how to implement these traits\nwith custom behavior as well as how to create your own traits in Chapter 10.\n\nOur area function is very specific: it only computes the area of rectangles.\nIt would be helpful to tie this behavior more closely to our Rectangle struct,\nbecause it won't work with any other type. Let's look at how we can continue\nto refactor this code by turning the area function into an area method defined\non our Rectangle type.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 5.11,
                        "section_name": "Method Syntax",
                        "section_path": "./screenshots-images-2/chapter_5/section_11",
                        "images": [
                            "./screenshots-images-2/chapter_5/section_11/1ed01c93-6e09-4068-ac4c-bb12fed6eb25.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Method Syntax\n\nMethods are similar to functions: they're declared with the fn keyword and\ntheir name, they can have parameters and a return value, and they contain\nsome code that is run when they're called from somewhere else. However,\nmethods are different from functions in that they're defined within the con-\ntext of a struct (or an enum or a trait object, which we cover in Chapters 6\nand 17, respectively), and their first parameter is always self, which represents\nthe instance of the struct the method is being called on.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 5.12,
                        "section_name": "Defining Methods",
                        "section_path": "./screenshots-images-2/chapter_5/section_12",
                        "images": [
                            "./screenshots-images-2/chapter_5/section_12/a187d3ef-ad60-41d9-8afb-74175ed54b1b.png",
                            "./screenshots-images-2/chapter_5/section_12/00caac14-20df-4cb3-a080-5049ec7c522a.png",
                            "./screenshots-images-2/chapter_5/section_12/5090ae6e-34b5-475d-a5b6-968d7c9de21d.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Defining Methods\n\nLet\u2019s change the area function that has a Rectangle instance as a parameter\nand instead make an area method defined on the Rectangle struct, as shown\nin Listing 5-13.\n\nsrc/main.rs\n\nimpl Rectangle {\n\u00a9 fn area(&self) -> u32 {\nself.width * self.height\n\nprintln\n\"The area of the rectangle is {} s\n\u00a9 rect1.area()\n\nListing 5-13: Defining an area method on the Rectangle struct\n\nTo define the function within the context of Rectangle, we start an imp]\n(implementation) block \u00ae. Then we move the area function within the imp1\ncurly brackets \u00ae and change the first (and in this case, only) parameter to\nbe self in the signature and everywhere within the body. In main, where we\ncalled the area function and passed rect1 as an argument, we can instead\nuse method syntax to call the area method on our Rectangle instance \u00ae. The\nmethod syntax goes after an instance: we add a dot followed by the method\nname, parentheses, and any arguments.\n\nIn the signature for area, we use &self instead of rectangle: Rectangle\nbecause Rust knows the type of self is Rectangle due to this method's being\ninside the impl Rectangle context. Note that we still need to use the & before\nself, just as we did in &Rectangle. Methods can take ownership of self, bor-\nrow self immutably as we've done here, or borrow self mutably, just as they\ncan any other parameter.\n\nWe've chosen &self here for the same reason we used &Rectangle in the\nfunction version: we don\u2019t want to take ownership, and we just want to read\nthe data in the struct, not write to it. If we wanted to change the instance\nthat we've called the method on as part of what the method does, we'd use\namut self as the first parameter. Having a method that takes ownership of\nthe instance by using just self as the first parameter is rare; this technique\nis usually used when the method transforms self into something else and\nyou want to prevent the caller from using the original instance after the\ntransformation.\n\nThe main benefit of using methods instead of functions, in addition\nto using method syntax and not having to repeat the type of self in every\nmethod's signature, is for organization. We've put all the things we can\n\ndo with an instance of a type in one imp] block rather than making future\nusers of our code search for capabilities of Rectangle in various places in\nthe library we provide.\n\nWHERE'S THE -> OPERATOR?\n\nIn C and C++, two different operators are used for calling methods: you use the\n. operator if you're calling a method on the object directly and the -> operator\nif you're calling the method on a pointer to the object and need to dereference\nthe pointer first. In other words, if object is a pointer, object->something() is\nsimilar to (*object) . something().\n\nRust doesn\u2019t have an equivalent to the -> operator; instead, Rust has a fea-\nture called automatic referencing and dereferencing. Calling methods is one of\nthe few places in Rust that has this behavior.\n\nHere's how it works: when you call a method with object.something(),\nRust automatically adds in & &mut, or * so object matches the signature of the\n\nmethod. In other words, the following are the same:\n\npi.distance(&p2);\n(&p1).distance(&p2) ;\n\nThe first one looks much cleaner. This automatic referencing behavior works\nbecause methods have a clear receiver\u2014the type of self. Given the receiver\nand name of a method, Rust can figure out definitively whether the method is\nreading (8self), mutating (amut self), or consuming (self). The fact that Rust\nmakes borrowing implicit for method receivers is a big part of making ownership\nergonomic in practice.\n\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 5.13,
                        "section_name": "Methods with More Parameters",
                        "section_path": "./screenshots-images-2/chapter_5/section_13",
                        "images": [
                            "./screenshots-images-2/chapter_5/section_13/604b2217-13dc-448d-98b9-dc836cac4bfa.png",
                            "./screenshots-images-2/chapter_5/section_13/fc445b11-a115-4daa-9d9a-cd44d78bb41d.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Methods with More Parameters\n\nLet's practice using methods by implementing a second method on the\nRectangle struct. This time, we want an instance of Rectangle to take another\ninstance of Rectangle and return true if the second Rectangle can fit completely\nwithin self; otherwise it should return false. That is, we want to be able to\nwrite the program shown in Listing 5-14, once we've defined the can_hold\n\nmethod.\nsrc/main.rs fn main() {\nlet recti = Rectangle { width: 30, height: 50 };\nlet rect2 = Rectangle { width: 10, height: 40 };\nlet rect3 = Rectangle { width: 60, height: 45 };\n\nprintln!(\"Can rect1 hold rect2? {}\", rect1.can_hold(&rect2));\nprintln!(\"Can rect1 hold rect3? {}\", rect1.can_hold(&rect3));\n}\n\nListing 5-14: Using the as-yet-unwritten can_hold method\n\nsrc/main.rs\n\nAnd the expected output would look like the following, because both\ndimensions of rect2 are smaller than the dimensions of rect1 but rect3 is\nwider than rect1:\n\nCan recti hold rect2? true\nCan recti hold rect3? false\n\nWe know we want to define a method, so it will be within the imp]\nRectangle block. The method name will be can_hold, and it will take an\nimmutable borrow of another Rectangle as a parameter. We can tell what\nthe type of the parameter will be by looking at the code that calls the\nmethod: recti.can_hold(&rect2) passes in &rect2, which is an immutable\nborrow to rect2, an instance of Rectangle. This makes sense because we\nonly need to read rect2 (rather than write, which would mean we'd need a\nmutable borrow), and we want main to retain ownership of rect2 so we can\nuse it again after calling the can_hold method. The return value of can_hold\nwill be a Boolean, and the implementation will check whether the width\nand height of self are both greater than the width and height of the other\nRectangle, respectively. Let\u2019s add the new can_hold method to the imp] block\nfrom Listing 5-13, shown in Listing 5-15.\n\nfn can_hold(&self, other: &Rectangle) -> bool {\nself.width > other.width && self.height > other.height\n}\n\nListing 5-15: Implementing the can_hold method on Rectangle that takes another Rectangle\ninstance as a parameter\n\nWhen we run this code with the main function in Listing 5-14, we'll get\nour desired output. Methods can take multiple parameters that we add to\nthe signature after the self parameter, and those parameters work just like\nparameters in functions.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 5.14,
                        "section_name": "Associated Functions",
                        "section_path": "./screenshots-images-2/chapter_5/section_14",
                        "images": [
                            "./screenshots-images-2/chapter_5/section_14/15c1c42a-97db-4a16-868b-5b2bc2b30d48.png",
                            "./screenshots-images-2/chapter_5/section_14/97fa379d-2664-48d2-b34f-2739caf0d3d7.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Associated Functions\n\nAnother useful feature of imp1 blocks is that we're allowed to define\nfunctions within impl blocks that don\u2019t take self as a parameter. These\nare called associated functions because they're associated with the struct.\nThey're still functions, not methods, because they don\u2019t have an instance\nof the struct to work with. You've already used the String: : from associated\nfunction.\n\nAssociated functions are often used for constructors that will return\na new instance of the struct. For example, we could provide an associated\n\nsrc/main.rs\n\nfunction that would have one dimension parameter and use that as both\nwidth and height, thus making it easier to create a square Rectangle rather\nthan having to specify the same value twice:\n\nimpl Rectangle {\nfn square(size: u32) -> Rectangle {\nRectangle { width: size, height: size }\n\nTo call this associated function, we use the :: syntax with the struct\nname; let sq = Rectangle: :square(3); is an example. This function is name-\nspaced by the struct: the :: syntax is used for both associated functions and\nnamespaces created by modules. We'll discuss modules in Chapter 7.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 5.15,
                        "section_name": "Multiple imp! Blocks",
                        "section_path": "./screenshots-images-2/chapter_5/section_15",
                        "images": [
                            "./screenshots-images-2/chapter_5/section_15/0fec91b1-4111-4a06-9b7d-8337ea7d8432.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nMultiple imp! Blocks\n\nEach struct is allowed to have multiple imp1 blocks. For example, Listing 5-15\nis equivalent to the code shown in Listing 5-16, which has each method in its\nown imp] block.\n\nimpl Rectangle {\nfn area(&self) -> u32 {\nself.width * self.height\n}\n\n}\nimpl Rectangle {\n\nfn can_hold(&self, other: &Rectangle) -> bool {\nself.width > other.width 8 self.height > other.height\n}\n\n}\n\nListing 5-16: Rewriting Listing 5-15 using multiple imp1 blocks\n\nThere\u2019s no reason to separate these methods into multiple imp1 blocks\nhere, but this is valid syntax. We'll see a case in which multiple imp] blocks\nare useful in Chapter 10, where we discuss generic types and traits.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 5.16,
                        "section_name": "Summary",
                        "section_path": "./screenshots-images-2/chapter_5/section_16",
                        "images": [
                            "./screenshots-images-2/chapter_5/section_16/781083f2-605f-41c6-8543-d37394a104fa.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Summary\n\nStructs let you create custom types that are meaningful for your domain. By\nusing structs, you can keep associated pieces of data connected to each other\nand name each piece to make your code clear. Methods let you specify the\nbehavior that instances of your structs have, and associated functions let you\nnamespace functionality that is particular to your struct without having an\ninstance available.\n\nBut structs aren't the only way you can create custom types: let\u2019s turn to\nRust\u2019s enum feature to add another tool to your toolbox.\n",
                        "extracted-code": ""
                    }
                ]
            },
            {
                "chapter_id": 6,
                "chapter_name": "ENUMS AND PATTERN MATCHING",
                "chapter_path": "./screenshots-images-2/chapter_6",
                "sections": [
                    {
                        "section_id": 6.1,
                        "section_name": "ENUMS AND PATTERN MATCHING",
                        "section_path": "./screenshots-images-2/chapter_6/section_1",
                        "images": [
                            "./screenshots-images-2/chapter_6/section_1/07370b25-a0b7-42f4-9dc6-ea6e3c71d586.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "In this chapter, we\u2019ll look at enumerations,\nalso referred to as enums. Enums allow you\nto define a type by enumerating its possible\nvalues. First, we\u2019ll define and use an enum to\nshow how an enum can encode meaning along with\ndata. Next, we'll explore a particularly useful enum,\ncalled Option, which expresses that a value can be\n\neither something or nothing. Then we\u2019ll look at how pattern matching in\nthe match expression makes it easy to run different code for different values\nof an enum. Finally, we'll cover how the if let construct is another conve-\nnient and concise idiom available to you to handle enums in your code.\n\nEnums are a feature in many languages, but their capabilities differ in\neach language. Rust\u2019s enums are most similar to algebraic data types in func-\ntional languages, such as F#, OCaml, and Haskell.\n\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 6.2,
                        "section_name": "Defining an Enum",
                        "section_path": "./screenshots-images-2/chapter_6/section_2",
                        "images": [
                            "./screenshots-images-2/chapter_6/section_2/6167c614-32fe-4bba-a7b0-a9b6a8214745.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Defining an Enum\n\nLet\u2019s look at a situation we might want to express in code and see why\nenums are useful and more appropriate than structs in this case. Say we\nneed to work with IP addresses. Currently, two major standards are used for\nIP addresses: version four and version six. These are the only possibilities\nfor an IP address that our program will come across: we can enumerate all\npossible values, which is where enumeration gets its name.\n\nAny IP address can be either a version four or a version six address, but\nnot both at the same time. That property of IP addresses makes the enum\ndata structure appropriate, because enum values can only be one of the\nvariants. Both version four and version six addresses are still fundamentally\nIP addresses, so they should be treated as the same type when the code is\nhandling situations that apply to any kind of IP address.\n\nWe can express this concept in code by defining an IpAddrKind enumera-\ntion and listing the possible kinds an IP address can be, V4 and V6. These\nare known as the variants of the enum:\n\nenum IpAddrKind {\nv4,\nv6,\n\nIpAddrKind is now a custom data type that we can use elsewhere in\nour code.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 6.3,
                        "section_name": "Enum Values",
                        "section_path": "./screenshots-images-2/chapter_6/section_3",
                        "images": [
                            "./screenshots-images-2/chapter_6/section_3/956733e1-bae1-4739-8773-8331d054e7d5.png",
                            "./screenshots-images-2/chapter_6/section_3/0c1d805e-e237-4060-a7fa-d8d684ca455e.png",
                            "./screenshots-images-2/chapter_6/section_3/eb984732-f015-478b-8a57-c85b902b6692.png",
                            "./screenshots-images-2/chapter_6/section_3/938ac8b6-7864-418b-bbc8-e7873466adbb.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Enum Values\n\nWe can create instances of each of the two variants of IpAddrKind like this:\n\nlet four = IpAddrKind::V4;\nlet six = IpAddrKind: :V6;\n\nNote that the variants of the enum are namespaced under its identifier,\nand we use a double colon to separate the two. The reason this is useful\nis that now both values IpAddrKind: :V4 and IpAddrKind: :V6 are of the same\ntype: IpAddrKind. We can then, for instance, define a function that takes any\nIpAddrKind:\n\nfn route(ip kind: IpAddrKind) { }\nAnd we can call this function with either variant:\n\nroute(IpAddrKind: :V4) ;\nroute(IpAddrKind: :V6) ;\n\nUsing enums has even more advantages. Thinking more about our\nIP address type, at the moment we don\u2019t have a way to store the actual IP\naddress data; we only know what kind it is. Given that you just learned about\nstructs in Chapter 5, you might tackle this problem as shown in Listing 6-1.\n\n\u00a9 enum IpAddrKind {\n\nv4,\nv6,\n}\n\n@ struct IpAddr {\n\n\u00a9 kind: IpAddrKind,\n\u00a9 address: String,\n}\n\n\u00a9 let home = IpAddr {\n\nkind: IpAddrKind: :V4,\naddress: String: :from(\"127.0.0.1\"),\n\n}s\n\n@ let loopback = IpAddr {\n\nkind: IpAddrKind: :V6,\naddress: String::from(\"::1\"),\n\nss\nListing 6-1: Storing the data and IpAddrKind variant of an IP address using a struct\n\nHere, we've defined a struct IpAddr @ that has two fields: a kind field \u00a9\nthat is of type IpAddrKind (the enum we defined previously \u00ae) and an\naddress field \u00a9 of type String. We have two instances of this struct. The\nfirst, hone @, has the value IpAddrKind: :V4 as its kind with associated address\ndata of 127.0.0.1. The second instance, loopback @, has the other variant of\nIpAddrKind as its kind value, V6, and has address ::1 associated with it. We\u2019ve\nused a struct to bundle the kind and address values together, so now the vari-\nant is associated with the value.\n\nWe can represent the same concept in a more concise way using just\nan enum, rather than an enum inside a struct, by putting data directly into\neach enum variant. This new definition of the IpAddr enum says that both V4\nand V6 variants will have associated String values:\n\nenum IpAddr {\nV4(String),\nV6(String),\n}\n\nlet home = IpAddr::V4(String::from(\"127.0.0.1\"));\nlet loopback = IpAddr::V6(String::from(\"::1\"));\n\nWe attach data to each variant of the enum directly, so there is no need\nfor an extra struct.\n\nThere\u2019s another advantage to using an enum rather than a struct: each\nvariant can have different types and amounts of associated data. Version\nfour type IP addresses will always have four numeric components that will\nhave values between 0 and 255. If we wanted to store V4 addresses as four u8\nvalues but still express V6 addresses as one String value, we wouldn't be able\nto with a struct. Enums handle this case with ease.\n\nenum IpAddr {\nV4(u8, u8, u8, us),\nV6(String),\n\n}\n\nlet home = IpAddr::V4(127, 0, 0, 1);\n\nlet loopback = IpAddr::V6(String: :from(\"::1\"));\n\nWe've shown several different ways to define data structures to store ver-\nsion four and version six IP addresses. However, as it turns out, wanting to\nstore IP addresses and encode which kind they are is so common that the\nstandard library has a definition we can use! Let\u2019s look at how the standard\nlibrary defines IpAddr: it has the exact enum and variants that we've defined\nand used, but it embeds the address data inside the variants in the form of\ntwo different structs, which are defined differently for each variant:\n\nstruct Ipv4Addr {\n\n// --snip--\n}\nstruct Ipv6Addr {\n// --snip--\n}\nenum IpAddr {\nV4(Ipv4Addr),\nV6(Ipv6Addr),\n}\n\nThis code illustrates that you can put any kind of data inside an enum\nvariant: strings, numeric types, or structs, for example. You can even include\nanother enum! Also, standard library types are often not much more compli-\ncated than what you might come up with.\n\nNote that even though the standard library contains a definition for\nIpAddr, we can still create and use our own definition without conflict because\nwe haven't brought the standard library\u2019s definition into our scope. We'll talk\nmore about bringing types into scope in Chapter 7.\n\nLet\u2019s look at another example of an enum in Listing 6-2: this one has a\nwide variety of types embedded in its variants.\n\nenum Message {\nQuit,\nMove { x: 132, y: 132 },\nWrite(String),\nChangeColor(i32, i32, 132),\n}\n\nListing 6-2: A Message enum whose variants each store different amounts and types of values\n\nThis enum has four variants with different types:\n\n\u00ae Quit has no data associated with it at all.\n\ne Move includes an anonymous struct inside it.\ne Write includes a single String.\n\n\u00a9 \u2014ChangeColor includes three i32 values.\n\nDefining an enum with variants such as the ones in Listing 6-2 is simi-\nlar to defining different kinds of struct definitions, except the enum doesn\u2019t\nuse the struct keyword and all the variants are grouped together under the\nMessage type. The following structs could hold the same data that the pre-\nceding enum variants hold:\n\nstruct QuitMessage; // unit struct\nstruct MoveMessage {\nx: 132,\ny: 132,\n}\nstruct WriteMessage(String); // tuple struct\nstruct ChangeColorMessage(i32, i32, 132); // tuple struct\n\nBut if we used the different structs, which each have their own type, we\ncouldn't as easily define a function to take any of these kinds of messages as\nwe could with the Message enum defined in Listing 6-2, which is a single type.\n\nThere is one more similarity between enums and structs: just as we're\nable to define methods on structs using imp], we're also able to define\nmethods on enums. Here\u2019s a method named call that we could define on\nour Message enum:\n\nimpl Message {\nfn call(&self) {\n@ // method body would be defined here\n\n}\n}\nlet m = Message: :wWrite(String::from(\"hello\"));\nm.call();\n\nThe body of the method would use self to get the value that we called\nthe method on. In this example, we've created a variable m @ that has the\nvalue Message: :Write(String::from(\"hello\")), and that is what self will be in\nthe body of the call method @ when m.call() runs.\n\nLet's look at another enum in the standard library that is very common\nand useful: Option.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 6.4,
                        "section_name": "The Option Enum and Its Advantages over Null Values",
                        "section_path": "./screenshots-images-2/chapter_6/section_4",
                        "images": [
                            "./screenshots-images-2/chapter_6/section_4/e0eadbf4-9ac2-4445-b51e-205a733af078.png",
                            "./screenshots-images-2/chapter_6/section_4/f285c80b-0228-4231-aa4e-de1224fa7f7b.png",
                            "./screenshots-images-2/chapter_6/section_4/da26df55-8275-4086-9c9f-3664b0e4e433.png",
                            "./screenshots-images-2/chapter_6/section_4/8fafffe9-e749-4a7b-affa-302945427ca2.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "The Option Enum and Its Advantages over Null Values\n\nIn the previous section, we looked at how the IpAddr enum let us use Rust\u2019s\ntype system to encode more information than just the data into our program.\nThis section explores a case study of Option, which is another enum defined\n\nby the standard library. The Option type is used in many places because it\nencodes the very common scenario in which a value could be something\nor it could be nothing. Expressing this concept in terms of the type system\nmeans the compiler can check whether you've handled all the cases you\nshould be handling; this functionality can prevent bugs that are extremely\ncommon in other programming languages.\n\nProgramming language design is often thought of in terms of which\nfeatures you include, but the features you exclude are important too. Rust\ndoesn\u2019t have the null feature that many other languages have. Nullis a value\nthat means there is no value there. In languages with null, variables can\nalways be in one of two states: null or not-null.\n\nIn his 2009 presentation \u201cNull References: The Billion Dollar Mistake,\u201d\nTony Hoare, the inventor of null, has this to say:\n\nI call it my billion dollar mistake. At that time, I was design-\n\ning the first comprehensive type system for references in an\nobject-oriented language. My goal was to ensure that all use of\nreferences should be absolutely safe, with checking performed\nautomatically by the compiler. But I couldn\u2019t resist the temptation\nto put in a null reference, simply because it was so easy to imple-\nment. This has led to innumerable errors, vulnerabilities, and\nsystem crashes, which have probably caused a billion dollars of\npain and damage in the last forty years.\n\nThe problem with null values is that if you try to use a null value as a\nnot-null value, you'll get an error of some kind. Because this null or not-null\nproperty is pervasive, it\u2019s extremely easy to make this kind of error.\n\nHowever, the concept that null is trying to express is still a useful one: a\nnull is a value that is currently invalid or absent for some reason.\n\nThe problem isn\u2019t really with the concept but with the particular imple-\nmentation. As such, Rust does not have nulls, but it does have an enum that\ncan encode the concept of a value being present or absent. This enum is\nOption<T>, and it is defined by the standard library as follows:\n\nenum Option<T> {\nSome(T) ,\nNone,\n\nThe Option<T> enum is so useful that it\u2019s even included in the prelude;\nyou don\u2019t need to bring it into scope explicitly. In addition, so are its vari-\nants: you can use Some and None directly without the Option:: prefix. The\nOption<T> enum is still just a regular enum, and Some(T) and None are still\nvariants of type Option<T>.\n\nThe <T> syntax is a feature of Rust we haven't talked about yet. It\u2019s a\ngeneric type parameter, and we'll cover generics in more detail in Chapter 10.\nFor now, all you need to know is that <T> means the Some variant of the Option\n\nenum can hold one piece of data of any type. Here are some examples of\nusing Option values to hold number types and string types:\n\nlet some_number = Some(S);\nlet some_string = Some(\"a string\");\n\nlet absent_number: Option<i32> = None;\n\nIf we use None rather than Some, we need to tell Rust what type of Option<T>\nwe have, because the compiler can\u2019t infer the type that the Some variant will\nhold by looking only at a None value.\n\nWhen we have a Some value, we know that a value is present and the value\nis held within the Some. When we have a None value, in some sense, it means the\nsame thing as null: we don\u2019t have a valid value. So why is having Option<T> any\nbetter than having null?\n\nIn short, because Option<T> and T (where T can be any type) are different\ntypes, the compiler won't let us use an Option<T> value as if it were definitely\na valid value. For example, this code won't compile because it\u2019s trying to\nadd an i8 to an Option<i8>:\n\nlet x: i8 = 5;\nlet y: Option<i8> = Some(5);\n\nlet sum = x + y;\nIf we run this code, we get an error message like this:\n\nerror[{E0277]: the trait bound ~i8: std::ops::Add<std: :option: :Option<i8>>\u00b0 is\nnot satisfied\n-->\n\n|\nlet sum = x + y;\n\n5 |\n| \u201cno implementation for ~i8 + std::option::Option<i8>~\n|\n\nIntense! In effect, this error message means that Rust doesn\u2019t under-\nstand how to add an i8 and an Option<i8>, because they're different types.\nWhen we have a value of a type like i8 in Rust, the compiler will ensure that\nwe always have a valid value. We can proceed confidently without having\nto check for null before using that value. Only when we have an Option<i8>\n(or whatever type of value we're working with) do we have to worry about\npossibly not having a value, and the compiler will make sure we handle that\ncase before using the value.\n\nIn other words, you have to convert an Option<T> to a T before you can\nperform T operations with it. Generally, this helps catch one of the most com-\nmon issues with null: assuming that something isn\u2019t null when it actually is.\n\nNot having to worry about incorrectly assuming a not-null value helps\nyou to be more confident in your code. In order to have a value that can\npossibly be null, you must explicitly opt in by making the type of that value\n\nOption<T>. Then, when you use that value, you are required to explicitly\nhandle the case when the value is null. Everywhere that a value has a type\nthat isn\u2019t an Option<T>, you can safely assume that the value isn\u2019t null. This\nwas a deliberate design decision for Rust to limit null\u2019s pervasiveness and\nincrease the safety of Rust code.\n\nSo, how do you get the T value out of a Some variant when you have a value\nof type Option<T> so you can use that value? The Option<T> enum has a large\nnumber of methods that are useful in a variety of situations; you can check\nthem out in its documentation. Becoming familiar with the methods on\nOption<T> will be extremely useful in your journey with Rust.\n\nIn general, in order to use an Option<T> value, you want to have code that\nwill handle each variant. You want some code that will run only when you\nhave a Some(T) value, and this code is allowed to use the inner T. You want\nsome other code to run if you have a None value, and that code doesn\u2019t have\naT value available. The match expression is a control flow construct that does\njust this when used with enums: it will run different code depending on\nwhich variant of the enum it has, and that code can use the data inside the\nmatching value.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 6.5,
                        "section_name": "The match Control Flow Operator",
                        "section_path": "./screenshots-images-2/chapter_6/section_5",
                        "images": [
                            "./screenshots-images-2/chapter_6/section_5/45b9dbf9-ab04-4e7d-be5d-4db0893e0ac4.png",
                            "./screenshots-images-2/chapter_6/section_5/7f19db11-07c3-4a78-91c7-c2ccd64c6c01.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "The match Control Flow Operator\n\nRust has an extremely powerful control flow operator called match that allows\nyou to compare a value against a series of patterns and then execute code\nbased on which pattern matches. Patterns can be made up of literal values,\nvariable names, wildcards, and many other things; Chapter 18 covers all the\ndifferent kinds of patterns and what they do. The power of match comes from\nthe expressiveness of the patterns and the fact that the compiler confirms\nthat all possible cases are handled.\n\nThink of a match expression as being like a coin-sorting machine:\ncoins slide down a track with variously sized holes along it, and each coin\nfalls through the first hole it encounters that it fits into. In the same way,\nvalues go through each pattern in a match, and at the first pattern the\nvalue \u201cfits,\u201d the value falls into the associated code block to be used dur-\ning execution.\n\nBecause we just mentioned coins, let\u2019s use them as an example of using\nmatch! We can write a function that can take an unknown United States coin\nand, in a similar way as the counting machine, determine which coin it is\nand return its value in cents, as shown here in Listing 6-3.\n\n@ enum Coin {\nPenny,\nNickel,\nDime,\nQuarter,\n\nfn value_in_cents(coin: Coin) -> u8 {\n@ match coin {\n\u00a9 Coin: :Penny => 1,\n\nDime => 10,\nCoin: :Quarter => 25,\n\nListing 6-3: An enum and a match expression that has the variants of the enum as its patterns\n\nLet\u2019s break down the match in the value_in_cents function. First, we list\nthe match keyword followed by an expression, which in this case is the value\ncoin @. This seems very similar to an expression used with if, but there's a\nbig difference: with if, the expression needs to return a Boolean value, but\nhere, it can be any type. The type of coin in this example is the Coin enum\nthat we defined at @.\n\nNext are the match arms. An arm has two parts: a pattern and some code.\nThe first arm here has a pattern that is the value Coin: :Penny and then the =>\noperator that separates the pattern and the code to run \u00a9. The code in this\ncase is just the value 1. Each arm is separated from the next with a comma.\n\nWhen the match expression executes, it compares the resulting value\nagainst the pattern of each arm, in order. If a pattern matches the value, the\ncode associated with that pattern is executed. If that pattern doesn\u2019t match\nthe value, execution continues to the next arm, much as in a coin-sorting\nmachine. We can have as many arms as we need: in Listing 6-3, our match has\nfour arms.\n\nThe code associated with each arm is an expression, and the resulting\nvalue of the expression in the matching arm is the value that gets returned\nfor the entire match expression.\n\nCurly brackets typically aren't used if the match arm code is short,\nas it is in Listing 6-3 where each arm just returns a value. If you want to\nrun multiple lines of code in a match arm, you can use curly brackets. For\nexample, the following code would print \u201cLucky penny!\u201d every time the\nmethod was called with a Coin: :Penny but would still return the last value\nof the block, 1:\n\nfn value_in_cents(coin: Coin) -> u& {\nmatch coin {\nCoin: :Penny => {\nprintln! (\"Lucky penny!\");\n\nDime => 10,\nCoin: :Quarter => 25,\n\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 6.6,
                        "section_name": "Patterns That Bind to Values",
                        "section_path": "./screenshots-images-2/chapter_6/section_6",
                        "images": [
                            "./screenshots-images-2/chapter_6/section_6/674142ab-5f56-4a85-bc1c-2c9957207f15.png",
                            "./screenshots-images-2/chapter_6/section_6/052b29b5-c8f3-472b-8ec9-c0735b65df2d.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Patterns That Bind to Values\n\nAnother useful feature of match arms is that they can bind to the parts of\nthe values that match the pattern. This is how we can extract values out of\nenum variants.\n\nAs an example, let\u2019s change one of our enum variants to hold data\ninside it. From 1999 through 2008, the United States minted quarters with\ndifferent designs for each of the 50 states on one side. No other coins got\nstate designs, so only quarters have this extra value. We can add this infor-\nmation to our enum by changing the Quarter variant to include a UsState value\nstored inside it, which we've done here in Listing 6-4.\n\n#t[derive(Debug)] // so we can inspect the state in a minute\nenum UsState {\n\nAlabama,\n\nAlaska,\n\n// --snip--\n}\n\nenum Coin {\nPenny,\nNickel,\nDime,\nQuarter(UsState) ,\n}\n\nListing 6-4: A Coin enum in which the Quarter variant also holds a UsState value\n\nLet\u2019s imagine that a friend of ours is trying to collect all 50 state quar-\nters. While we sort our loose change by coin type, we'll also call out the\nname of the state associated with each quarter so if it\u2019s one our friend\ndoesn\u2019t have, they can add it to their collection.\n\nIn the match expression for this code, we add a variable called state\nto the pattern that matches values of the variant Coin: :Quarter. When a\nCoin: :Quarter matches, the state variable will bind to the value of that quar-\nter\u2019s state. Then we can use state in the code for that arm, like so:\n\nfn value_in_cents(coin: Coin) -> u8 {\nmatch coin {\n\nCoin::Penny => 1,\n\nCoin::Nickel => 5,\n\nCoin::Dime => 10,\n\nCoin: :Quarter(state) => {\nprintln!(\"State quarter from {:?}!\", state);\n25\n\n}\n\nIf we were to call value_in_cents (Coin: :Quarter(UsState: :Alaska)),\ncoin would be Coin: :Quarter(UsState: :Alaska). When we compare that\nvalue with each of the match arms, none of them match until we reach\n\nCoin: :Quarter (state). At that point, the binding for state will be the value\nUsState: :Alaska. We can then use that binding in the println! expression,\nthus getting the inner state value out of the Coin enum variant for Quarter.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 6.7,
                        "section_name": "Matching with Option<T>",
                        "section_path": "./screenshots-images-2/chapter_6/section_7",
                        "images": [
                            "./screenshots-images-2/chapter_6/section_7/12f60bdc-e65b-4953-b45b-83b82e62bb4f.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Matching with Option<T>\nIn the previous section, we wanted to get the inner T value out of the Some\ncase when using Option<T>; we can also handle Option<T> using match as we did\nwith the Coin enum! Instead of comparing coins, we'll compare the variants\nof Option<T>, but the way that the match expression works remains the same.\nLet's say we want to write a function that takes an Option<i32> and, if\nthere\u2019s a value inside, adds 1 to that value. If there isn\u2019t a value inside, the\nfunction should return the None value and not attempt to perform any\noperations.\nThis function is very easy to write, thanks to match, and will look like\nListing 6-5.\n\nfn plus_one(x: Option<i32>) -> Option<i32> {\nmatch x {\n@ None => None,\n\u00a9 Some(i) => Some(i + 1),\n\n}\n\nlet five = Some(5);\nlet six = plus_one(five);\u00ae\nlet none = plus_one(None);\u00ae\n\nListing 6-5: A function that uses a match expression on an Option<i32>\n\nLet's examine the first execution of plus_one in more detail. When we\ncall plus_one(five) \u00ae, the variable x in the body of plus_one will have the\nvalue Some(5). We then compare that against each match arm.\n\nThe Some(5) value doesn\u2019t match the pattern None \u00ae, so we continue to the\nnext arm. Does Some(5) match Some(i) @? Why yes it does! We have the same\nvariant. The i binds to the value contained in Some, so i takes the value 5. The\ncode in the match arm is then executed, so we add 1 to the value of i and\ncreate a new Some value with our total 6 inside.\n\nNow let\u2019s consider the second call of plus_one in Listing 6-5, where x is\nNone @. We enter the match and compare to the first arm @.\n\nIt matches! There's no value to add to, so the program stops and returns\nthe None value on the right side of =>. Because the first arm matched, no other\narms are compared.\n\nCombining match and enums is useful in many situations. You'll see this\npattern a lot in Rust code: match against an enum, bind a variable to the data\ninside, and then execute code based on it. It\u2019s a bit tricky at first, but once you\nget used to it, you'll wish you had it in all languages. It\u2019s consistently a user\nfavorite.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 6.8,
                        "section_name": "Matches Are Exhaustive",
                        "section_path": "./screenshots-images-2/chapter_6/section_8",
                        "images": [
                            "./screenshots-images-2/chapter_6/section_8/abc67d3f-f912-410e-b15a-326ac2fa82be.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Matches Are Exhaustive\n\nThere\u2019s one other aspect of match we need to discuss. Consider this version\nof our plus_one function that has a bug and won't compile:\n\nfn plus_one(x: Option<i32>) -> Option<i32> {\nmatch x {\nSome(i) => Some(i + 1),\n}\n\nWe didn\u2019t handle the None case, so this code will cause a bug. Luckily, it\u2019s\na bug Rust knows how to catch. If we try to compile this code, we'll get this\nerror:\n\nerror[E0004]: non-exhaustive patterns: \u201cNone\u201d not covered\n-->\n\n|\n6 | match x {\n| * pattern \u201cNone\u201d not covered\n\nRust knows that we didn\u2019t cover every possible case and even knows\nwhich pattern we forgot! Matches in Rust are exhaustive: we must exhaust\nevery last possibility in order for the code to be valid. Especially in the case\nof Option<T>, when Rust prevents us from forgetting to explicitly handle the\nNone case, it protects us from assuming that we have a value when we might\nhave null, thus making the billion-dollar mistake discussed earlier.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 6.9,
                        "section_name": "The _ Placeholder",
                        "section_path": "./screenshots-images-2/chapter_6/section_9",
                        "images": [
                            "./screenshots-images-2/chapter_6/section_9/6b3cc166-2a27-4592-b527-e5a97bf61a16.png",
                            "./screenshots-images-2/chapter_6/section_9/dc0c027a-c43b-4b74-a67f-d0a807fd4f20.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "The _ Placeholder\n\nRust also has a pattern we can use when we don\u2019t want to list all possible\nvalues. For example, a u8 can have valid values of 0 through 255. If we only\ncare about the values 1, 3, 5, and 7, we don\u2019t want to have to list out 0, 2, 4,\n6, 8, 9 all the way up to 255. Fortunately, we don\u2019t have to: we can use the\nspecial pattern _ instead:\n\nlet some_u8 value = 0u8;\nmatch some_u8 value {\n\n1 => println!(\"one\"),\n=> println! (\"three\"),\n=> println! (\"five\"),\n=> println! (\"seven\"),\n\n-? 0s\n\nsw\n\nThe _ pattern will match any value. By putting it after our other arms,\nthe _ will match all the possible cases that aren\u2019t specified before it. The ()\n\nis just the unit value, so nothing will happen in the _ case. As a result, we\ncan say that we want to do nothing for all the possible values that we don\u2019t\nlist before the _ placeholder.\n\nHowever, the match expression can be a bit wordy in a situation in which\nwe care about only one of the cases. For this situation, Rust provides if let.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 6.1,
                        "section_name": "Concise Control Flow with if let",
                        "section_path": "./screenshots-images-2/chapter_6/section_10",
                        "images": [
                            "./screenshots-images-2/chapter_6/section_10/58e7fedf-7363-4d5d-9b6e-541b01a9d32a.png",
                            "./screenshots-images-2/chapter_6/section_10/f88e5028-83f4-4270-8c79-37e166c5189c.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Concise Control Flow with if let\n\nThe if let syntax lets you combine if and let into a less verbose way to\nhandle values that match one pattern while ignoring the rest. Consider the\nprogram in Listing 6-6 that matches on an Option<u8> value but only wants\nto execute code if the value is 3.\n\nlet some_u& value = Some(0u8) ;\nmatch some_u8 value {\nSome(3) => println! (\"three\"),\n-? 0,\n\n}\n\nListing 6-6: A match that only cares about executing code when the value is Some(3)\n\nWe want to do something with the Some(3) match but do nothing with any\nother Some<u8> value or the None value. To satisfy the match expression, we have\nto add _ => () after processing just one variant, which is a lot of boilerplate\ncode to add.\n\nInstead, we could write this in a shorter way using if let. The following\ncode behaves the same as the match in Listing 6-6:\n\nif let Some(3) = some_u8 value {\nprintln! (\"three\") ;\n}\n\nThe syntax if let takes a pattern and an expression separated by an\nequal sign. It works the same way as a match, where the expression is given\nto the match and the pattern is its first arm.\n\nUsing if let means less typing, less indentation, and less boilerplate\ncode. However, you lose the exhaustive checking that match enforces.\nChoosing between match and if let depends on what you're doing in your\nparticular situation and whether gaining conciseness is an appropriate\ntrade-off for losing exhaustive checking.\n\nIn other words, you can think of if let as syntax sugar for a match that\nruns code when the value matches one pattern and then ignores all other\nvalues.\n\nWe can include an else with an if let. The block of code that goes\nwith the else is the same as the block of code that would go with the _ case\nin the match expression that is equivalent to the if let and else. Recall the\n\nCoin enum definition in Listing 6-4, where the Quarter variant also held a\nUsState value. If we wanted to count all non-quarter coins we see while also\nannouncing the state of the quarters, we could do that with a match expres-\nsion like this:\n\nlet mut count = 0;\n\nmatch coin {\nCoin: :Quarter(state) => println!(\"State quarter from {:?}!\", state),\n_ => count += 1,\n\nOr we could use an if let and else expression like this:\n\nlet mut count = 0;\nif let Coin::Quarter(state) = coin {\nprintln!(\"State quarter from {:?}!\", state);\n} else {\ncount += 1;\n}\n\nIf you have a situation in which your program has logic that is too ver-\nbose to express using a match, remember that if let is in your Rust toolbox\nas well.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 6.11,
                        "section_name": "Summary",
                        "section_path": "./screenshots-images-2/chapter_6/section_11",
                        "images": [
                            "./screenshots-images-2/chapter_6/section_11/25400a7c-082e-4f52-bfcb-44eaa4bc6bd6.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Summary\n\nWe've now covered how to use enums to create custom types that can be\none of a set of enumerated values. We've shown how the standard library's\nOption<T> type helps you use the type system to prevent errors. When enum\nvalues have data inside them, you can use match or if let to extract and use\nthose values, depending on how many cases you need to handle.\n\nYour Rust programs can now express concepts in your domain using\nstructs and enums. Creating custom types to use in your API ensures type\nsafety: the compiler will make certain your functions get only values of the\ntype each function expects.\n\nIn order to provide a well-organized API to your users that is straight-\nforward to use and only exposes exactly what your users will need, let\u2019s now\nturn to Rust\u2019s modules.\n",
                        "extracted-code": ""
                    }
                ]
            },
            {
                "chapter_id": 7,
                "chapter_name": "MANAGING GROWING PROJECTS\nWITH PACKAGES, CRATES,\nAND MODULES",
                "chapter_path": "./screenshots-images-2/chapter_7",
                "sections": [
                    {
                        "section_id": 7.1,
                        "section_name": "MANAGING GROWING PROJECTS\nWITH PACKAGES, CRATES,\nAND MODULES",
                        "section_path": "./screenshots-images-2/chapter_7/section_1",
                        "images": [
                            "./screenshots-images-2/chapter_7/section_1/9ae646ce-9d0b-4285-a89b-7514f5b34234.png",
                            "./screenshots-images-2/chapter_7/section_1/eedf65f7-b08a-46dc-be8b-b57680ed60f5.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "As you write large programs, organizing\n\nyour code will be important because keep-\ning track of your entire program in your\n\nhead will become impossible. By grouping\n\nrelated functionality and separating code with dis-\ntinct features, you'll clarify where to find code that\nimplements a particular feature and where to go to\nchange how a feature works.\n\nThe programs we've written so far have been in one module in one\nfile. As a project grows, you can organize code by splitting it into multiple\nmodules and then multiple files. A package can contain multiple binary\ncrates and optionally one library crate. As a package grows, you can extract\nparts into separate crates that become external dependencies. This chapter\ncovers all these techniques. For very large projects of a set of interrelated\npackages that evolve together, Cargo provides workspaces, which we'll cover\nin \u201cCargo Workspaces\u201d on page 303.\n\n\nIn addition to grouping functionality, encapsulating implementation\ndetails lets you reuse code at a higher level: once you've implemented an\noperation, other code can call that code via the code\u2019s public interface\nwithout knowing how the implementation works. The way you write code\ndefines which parts are public for other code to use and which parts are\nprivate implementation details that you reserve the right to change. This is\nanother way to limit the amount of detail you have to keep in your head.\n\nA related concept is scope: the nested context in which code is written\nhas a set of names that are defined as \u201cin scope.\u201d When reading, writing,\nand compiling code, programmers and compilers need to know whether\na particular name at a particular spot refers to a variable, function, struct,\nenum, module, constant, or other item and what that item means. You can\ncreate scopes and change which names are in or out of scope. You can\u2019t\nhave two items with the same name in the same scope; tools are available\nto resolve name conflicts.\n\nRust has a number of features that allow you to manage your code\u2019s\norganization, including which details are exposed, which details are\nprivate, and what names are in each scope in your programs. These\nfeatures, sometimes collectively referred to as the module system, include:\n\nPackages A Cargo feature that lets you build, test, and share crates\n\nCrates A tree of modules that produces a library or executable\n\nModules and use Let you control the organization, scope, and privacy\nof paths\n\nPaths A way of naming an item, such as a struct, function, or module\n\nIn this chapter, we'll cover all these features, discuss how they interact,\nand explain how to use them to manage scope. By the end, you should have\na solid understanding of the module system and be able to work with scopes\nlike a pro!\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 7.2,
                        "section_name": "Packages and Crates",
                        "section_path": "./screenshots-images-2/chapter_7/section_2",
                        "images": [
                            "./screenshots-images-2/chapter_7/section_2/74d9881e-05fd-430f-bd4b-3aaf82f6eec1.png",
                            "./screenshots-images-2/chapter_7/section_2/29881f49-b2e0-43c6-98f8-f974c2ab1a51.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Packages and Crates\n\nThe first parts of the module system we'll cover are packages and crates. A\ncrate is a binary or library. The crate root is a source file that the Rust com-\npiler starts from and makes up the root module of your crate (we'll explain\nmodules in depth in \u201cDefining Modules to Control Scope and Privacy\u201d on\npage 113). A package is one or more crates that provide a set of functional-\nity. A package contains a Cargo.toml file that describes how to build those\ncrates.\n\nSeveral rules determine what a package can contain. A package must\ncontain zero or one library crates, and no more. It can contain as many\nbinary crates as you'd like, but it must contain at least one crate (either\nlibrary or binary).\n\nLet's walk through what happens when we create a package. First, we\nenter the command cargo new:\n\n$ cargo new my-project\nCreated binary (application) \u201cmy-project\u2019 package\n$ 1s my-project\nCargo.toml\nsrc\n$ 1s my-project/sre\nmain.rs\n\nWhen we entered the command, Cargo created a Cargo.toml file, giving\nus a package. Looking at the contents of Cargo.toml, there\u2019s no mention of\nsrc/main.rs because Cargo follows a convention that sr\u00a2/main.rs is the crate\nroot of a binary crate with the same name as the package. Likewise, Cargo\nknows that if the package directory contains src/lib.rs, the package contains\na library crate with the same name as the package, and src/lib.rs is its crate\nroot. Cargo passes the crate root files to rustc to build the library or binary.\n\nHere, we have a package that only contains src/main.rs, meaning it only\ncontains a binary crate named my-project. If a package contains sr\u00a2/main.rs\nand sre/lib.rs, it has two crates: a library and a binary, both with the same\nname as the package. A package can have multiple binary crates by placing\nfiles in the src/bin directory: each file will be a separate binary crate.\n\nA crate will group related functionality together in a scope so the\nfunctionality is easy to share between multiple projects. For example,\nthe rand crate we used in \u201cGenerating a Secret Number\u201d on page 19\nprovides functionality that generates random numbers. We can use that\nfunctionality in our own projects by bringing the rand crate into our proj-\nect\u2019s scope. All the functionality provided by the rand crate is accessible\nthrough the crate\u2019s name, rand.\n\nKeeping a crate\u2019s functionality in its own scope clarifies whether par-\nticular functionality is defined in our crate or the rand crate and prevents\npotential conflicts. For example, the rand crate provides a trait named Rng.\nWe can also define a struct named Rng in our own crate. Because a crate\u2019s\nfunctionality is namespaced in its own scope, when we add rand as a depen-\ndency, the compiler isn\u2019t confused about what the name Rng refers to. In our\ncrate, it refers to the struct Rng that we defined. We would access the Rng\ntrait from the rand crate as rand: :Rng.\n\nLet\u2019s move on and talk about the module system!\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 7.3,
                        "section_name": "Defining Modules to Control Scope and Privacy",
                        "section_path": "./screenshots-images-2/chapter_7/section_3",
                        "images": [
                            "./screenshots-images-2/chapter_7/section_3/145f7438-8eab-478a-ac90-57e311cacc62.png",
                            "./screenshots-images-2/chapter_7/section_3/9b79562c-c46d-41a2-9064-c25cb16809b1.png",
                            "./screenshots-images-2/chapter_7/section_3/b96746c3-f32b-47b0-ab18-39eab9cb5d5b.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Defining Modules to Control Scope and Privacy\n\nIn this section, we'll talk about modules and other parts of the module\nsystem, namely paths that allow you to name items, the use keyword that\nbrings a path into scope, and the pub keyword to make items public. We'll\nalso discuss the as keyword, external packages, and the glob operator. For\nnow, let\u2019s focus on modules!\n\nsrc/lib.rs\n\nModules let us organize code within a crate into groups for readability\nand easy reuse. Modules also control the privacy of items, which is whether\nan item can be used by outside code (public) or is an internal implementa-\ntion detail and not available for outside use (private).\n\nAs an example, let\u2019s write a library crate that provides the functionality\nof a restaurant. We'll define the signatures of functions but leave their bodies\nempty to concentrate on the organization of the code, rather than actually\nimplement a restaurant in code.\n\nIn the restaurant industry, some parts of a restaurant are referred to as\nfront of house and others as back of house. Front of house is where customers\nare; this is where hosts seat customers, servers take orders and payment, and\nbartenders make drinks. Back of house is where the chefs and cooks work in\nthe kitchen, dishwashers clean up, and managers do administrative work.\n\nTo structure our crate in the same way that a real restaurant works,\nwe can organize the functions into nested modules. Create a new library\nnamed restaurant by running cargo new --lib restaurant; then put the code\nin Listing 7-1 into src/lib.rs to define some modules and function signatures.\n\nmod front_of_house {\nmod hosting {\nfn add_to_waitlist() {}\n\nfn seat_at_table() {}\n}\n\nmod serving {\nfn take_order() {}\n\nfn serve order() {}\nfn take_payment() {}\n\n}\n\nListing 7-1: A front_of_house module containing other modules that then contain functions\n\nWe define a module by starting with the mod keyword and then specify\nthe name of the module (in this case, front_of_house) and place curly brackets\naround the body of the module. Inside modules, we can have other modules,\nas in this case with the modules hosting and serving. Modules can also hold\ndefinitions for other items, such as structs, enums, constants, traits, or\u2014as in\nListing 7-1\u2014functions.\n\nBy using modules, we can group related definitions together and name\nwhy they're related. Programmers using this code would have an easier time\nfinding the definitions they wanted to use because they could navigate the\ncode based on the groups rather than having to read through all the defi-\nnitions. Programmers adding new functionality to this code would know\nwhere to place the code to keep the program organized.\n\nEarlier, we mentioned that sr\u00a2/main.rs and sre/lib.rs are called crate roots.\nThe reason for their name is that the contents of either of these two files\nform a module named crate at the root of the crate\u2019s module structure,\nknown as the module tree.\n\nListing 7-2 shows the module tree for the structure in Listing 7-1.\n\ncrate\nL\u2014 front_of_house\n\nhosting\n[E aid te waite ist\nEs _at_table\n\nserving\ntake_order\n\nE serve_order\n\ntake_payment\n\nListing 7-2: The module tree for the code in Listing 7-1\n\nThis tree shows that some of the modules nest inside one another\n(for example, hosting nests inside front_of_house). The tree also shows that\nsome modules are siblings to each other, meaning they're defined in the\nsame module (hosting and serving are defined within front_of_house). To\ncontinue the family metaphor, if module A is contained inside module B,\nwe say that module A is the child of module B and that module B is the\nparent of module A. Notice that the entire module tree is rooted under\nthe implicit module named crate.\n\nThe module tree might remind you of the filesystem\u2019s directory tree on\nyour computer; this is a very apt comparison! Just like directories in a file-\nsystem, you use modules to organize your code. And just like files in a direc-\ntory, we need a way to find our modules.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 7.4,
                        "section_name": "Paths for Referring to an Item in the Module Tree",
                        "section_path": "./screenshots-images-2/chapter_7/section_4",
                        "images": [
                            "./screenshots-images-2/chapter_7/section_4/6c934d54-8ef2-4a49-8d7f-2875e84f110f.png",
                            "./screenshots-images-2/chapter_7/section_4/011b4dfe-2e20-4037-9c3e-b93391605971.png",
                            "./screenshots-images-2/chapter_7/section_4/78eb31e5-0ccd-4210-918a-6b2005b5a7c1.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Paths for Referring to an Item in the Module Tree\n\nTo show Rust where to find an item in a module tree, we use a path in the\nsame way we use a path when navigating a filesystem. If we want to call a\nfunction, we need to know its path.\n\nA path can take two forms:\n\ne An absolute path starts from a crate root by using a crate name or a\nliteral crate.\n\ne A relative path starts from the current module and uses self, super, or an\nidentifier in the current module.\n\nBoth absolute and relative paths are followed by one or more identifiers\nseparated by double colons (::).\n\nLet\u2019s return to the example in Listing 7-1. How do we call the\nadd_to_waitlist function? This is the same as asking, what's the path of\nthe add_to_waitlist function? In Listing 7-3, we simplified our code a bit\nby removing some of the modules and functions. We'll show two ways\n\nsre/lib.rs\n\nto call the add_to_waitlist function from a new function eat_at_restaurant\ndefined in the crate root. The eat_at_restaurant function is part of our library\ncrate\u2019s public API, so we mark it with the pub keyword. In \u201cExposing Paths\nwith the pub Keyword\u201d on page 117, we'll go into more detail about pub.\nNote that this example won\u2019t compile just yet; we'll explain why in a bit.\n\nmod front_of_house {\nmod hosting {\nfn add_to_waitlist() {}\n}\n\n}\n\npub fn eat_at_restaurant() {\n// Absolute path\ncrate::front_of_house::hosting: :add_to_waitlist();\n\n// Relative path\nfront_of_house: :hosting::add_to_waitlist();\n\n}\n\nListing 7-3: Calling the add_to_waitlist function using absolute and relative paths\n\nThe first time we call the add_to_waitlist function in eat_at_restaurant,\nwe use an absolute path. The add_to_waitlist function is defined in the same\ncrate as eat_at_restaurant, which means we can use the crate keyword to\nstart an absolute path.\n\nAfter crate, we include each of the successive modules until we make\nour way to add_to_waitlist. You can imagine a filesystem with the same\nstructure, and we'd specify the path /front_of_house/hosting/add_to_waitlist\nto run the add_to_waitlist program; using the crate name to start from the\ncrate root is like using / to start from the filesystem root in your shell.\n\nThe second time we call add_to_waitlist in eat_at_restaurant, we use a\nrelative path. The path starts with front_of_house, the name of the module\ndefined at the same level of the module tree as eat_at_restaurant. Here the\nfilesystem equivalent would be using the path front_of_house/hosting/add_to\n_waitlist. Starting with a name means that the path is relative.\n\nChoosing whether to use a relative or absolute path is a decision you'll\nmake based on your project. The decision should depend on whether you're\nmore likely to move item definition code separately from or together with the\ncode that uses the item. For example, if we move the front_of_house module\nand the eat_at_restaurant function into a module named customer_experience,\nwe'd need to update the absolute path to add_to_waitlist, but the relative path\nwould still be valid. However, if we moved the eat_at_restaurant function sepa-\nrately into a module named dining, the absolute path to the add_to_waitlist\ncall would stay the same, but the relative path would need to be updated. Our\npreference is to specify absolute paths because it\u2019s more likely to move code\ndefinitions and item calls independently of each other.\n\nLet's try to compile Listing 7-3 and find out why it won\u2019t compile yet!\nThe error we get is shown in Listing 7-4.\n\n$ cargo build\n\nCompiling restaurant v0.1.0 (file:///projects/restaurant)\nerror[E\u00a30603]: module \u201chosting\u201d is private\n--> sre/lib.rs:9:28\n\n9 | crate::front_of_house::hosting::add_to_waitlist();\n|\n\nARAARAAN\n\nerror[E0603]: module \u201chosting\u201d is private\n--> src/lib.rs:12:21\n\n|\n12 | front_of_house: :hosting: :add_to_waitlist();\n\n| ARAAAAA\n\nListing 7-4: Compiler errors from building the code in Listing 7-3\n\nThe error messages say that module hosting is private. In other words,\nwe have the correct paths for the hosting module and the add_to_waitlist\nfunction, but Rust won't let us use them because it doesn\u2019t have access to\nthe private sections.\n\nModules aren't useful only for organizing your code. They also define\nRust\u2019s privacy boundary: the line that encapsulates the implementation details\nexternal code isn\u2019t allowed to know about, call, or rely on. So, if you want to\nmake an item like a function or struct private, you put it in a module.\n\nThe way privacy works in Rust is that all items (functions, methods,\nstructs, enums, modules, and constants) are private by default. Items in a\nparent module can\u2019t use the private items inside child modules, but items\nin child modules can use the items in their ancestor modules. The reason is\nthat child modules wrap and hide their implementation details, but the child\nmodules can see the context in which they're defined. To continue with the\nrestaurant metaphor, think of privacy rules as being like the back office of a\nrestaurant: what goes on in there is private to restaurant customers, but office\nmanagers can see and do everything in the restaurant in which they operate.\n\nRust chose to have the module system function this way so that hiding\ninner implementation details is the default. That way, you know which parts\nof the inner code you can change without breaking outer code. But you\ncan expose inner parts of child modules code to outer ancestor modules by\nusing the pub keyword to make an item public.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 7.5,
                        "section_name": "Exposing Paths with the pub Keyword",
                        "section_path": "./screenshots-images-2/chapter_7/section_5",
                        "images": [
                            "./screenshots-images-2/chapter_7/section_5/d67b988d-b80e-4062-a1ae-df5dcfe88fe0.png",
                            "./screenshots-images-2/chapter_7/section_5/7a7d7eca-ae2e-4d20-9528-7863c6013b65.png",
                            "./screenshots-images-2/chapter_7/section_5/23dbee6c-979d-4934-ae32-8dd5a577bdfc.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/lib.rs\n\nExposing Paths with the pub Keyword\n\nLet\u2019s return to the error in Listing 7-4 that told us the hosting module is pri-\nvate. We want the eat_at_restaurant function in the parent module to have\naccess to the add_to_waitlist function in the child module, so we mark the\nhosting module with the pub keyword, as shown in Listing 7-5.\n\nnt_of_h {\nmod hosting {\n\npub\n\nsrc/lib.rs\n\n// Relative path\n\nfront of house:: ::add to waitlist();\n\n}\n\nListing 7-5: Declaring the hosting module as pub to use it from eat_at_restaurant\n\nUnfortunately, the code in Listing 7-5 still results in an error, as shown\nin Listing 7-6.\n\n$ cargo build\n\nCompiling restaurant v0.1.0 (file:///projects/restaurant)\nerror[E0603]: function ~add_to_waitlist\u2019 is private\n--> src/lib.rs:9:37\n\n|\n9] crate: :front_of_house: :hosting: :add_to_waitlist();\n\n| AAAARARAAARAAAAA\n\nerror[E0603]: function \u201cadd _to_waitlist\u201d is private\n--> src/lib.rs:12:30\n\n|\n12 | front_of_house::hosting: :add_to_waitlist();\n\n| AARARAARAARAAAA\n\nListing 7-6: Compiler errors from building the code in Listing 7-5\n\nWhat happened? Adding the pub keyword in front of mod hosting makes\nthe module public. With this change, if we can access front_of_house, we can\naccess hosting. But the contents of hosting are still private; making the mod-\nule public doesn\u2019t make its contents public. The pub keyword on a module\nonly lets code in its ancestor modules refer to it.\n\nThe errors in Listing 7-6 say that the add_to_waitlist function is private.\nThe privacy rules apply to structs, enums, functions, and methods as well as\nmodules.\n\nLet\u2019s also make the add_to_waitlist function public by adding the pub\nkeyword before its definition, as in Listing 7-7.\n\nmod front_of_hou\npub mod hosting\n\npub fn add to waitlist() {}\n}\n\npub fn eat_at_restaurant() {\n\nolute path\ncrate::front_of_house::hosting::add_to waitlist();\n\nListing 7-7: Adding the pub keyword to mod hosting and fn add_to_waitlist lets us call the\nfunction from eat_at_restaurant\n\nNow the code will compile! Let\u2019s look at the absolute and the relative\npath and double-check why adding the pub keyword lets us use these paths\nin add_to_waitlist with respect to the privacy rules.\n\nIn the absolute path, we start with crate, the root of our crate\u2019s\nmodule tree. Then the front_of_house module is defined in the crate root.\nThe front_of_house module isn\u2019t public, but because the eat_at_restaurant\nfunction is defined in the same module as front_of_house (that is, eat_at\n_restaurant and front_of_house are siblings), we can refer to front_of_house\nfrom eat_at_restaurant. Next is the hosting module marked with pub. We can\naccess the parent module of hosting, so we can access hosting. Finally, the\nadd_to_waitlist function is marked with pub and we can access its parent\nmodule, so this function call works!\n\nIn the relative path, the logic is the same as in the absolute path except\nfor the first step: rather than starting from the crate root, the path starts\nfrom front_of_house. The front_of_house module is defined within the same\nmodule as eat_at_restaurant, so the relative path starting from the module\nin which eat_at_restaurant is defined works. Then, because hosting and add\n_to_waitlist are marked with pub, the rest of the path works, and this func-\ntion call is valid!\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 7.6,
                        "section_name": "Starting Relative Paths with super",
                        "section_path": "./screenshots-images-2/chapter_7/section_6",
                        "images": [
                            "./screenshots-images-2/chapter_7/section_6/6d37ee85-7c4e-4ab5-bd9d-9abaf02af4df.png",
                            "./screenshots-images-2/chapter_7/section_6/ca8a7597-42d2-4cd0-b974-159a04ab2ef1.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/lib.rs\n\nStarting Relative Paths with super\n\nWe can also construct relative paths that begin in the parent module by\nusing super at the start of the path. This is like starting a filesystem path\nwith the .. syntax. Why would we want to do this?\n\nConsider the code in Listing 7-8 that models the situation in which a\nchef fixes an incorrect order and personally brings it out to the customer.\nThe function fix_incorrect_order calls the function serve_order by specifying\nthe path to serve_order starting with super.\n\nfn serve_order() {}\n\nmod back_of_house {\nfn fix_incorrect_order() {\ncook_order();\nsuper: :serve_order();\n\n}\n\nfn cook_order() {}\n}\n\nListing 7-8: Calling a function using a relative path starting with super\n\nThe fix_incorrect_order function is in the back_of_house module, so we\ncan use super to go to the parent module of back_of_house, which in this case\nis crate, the root. From there, we look for serve_order and find it. Success!\nWe think the back_of_house module and the serve_order function are likely to\nstay in the same relationship to each other and get moved together should\nwe decide to reorganize the crate\u2019s module tree. Therefore, we used super so\nwe'll have fewer places to update code in the future if this code gets moved\nto a different module.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 7.7,
                        "section_name": "Making Structs and Enums Public",
                        "section_path": "./screenshots-images-2/chapter_7/section_7",
                        "images": [
                            "./screenshots-images-2/chapter_7/section_7/ebd8eaa0-5ac8-4c28-b375-9d508e6f8063.png",
                            "./screenshots-images-2/chapter_7/section_7/ce1aec3d-8afa-46c0-a292-f104a0b5e12f.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/lib.rs\n\nMaking Structs and Enums Public\n\nWe can also use pub to designate structs and enums as public, but there\nare a few extra details. If we use pub before a struct definition, we make the\nstruct public, but the struct\u2019s fields will still be private. We can make each\nfield public or not on a case-by-case basis. In Listing 7-9, we've defined\n\na public back_of_house: :Breakfast struct with a public toast field but a pri-\nvate seasonal_fruit field. This models the case in a restaurant where the\ncustomer can pick the type of bread that comes with a meal, but the chef\ndecides which fruit accompanies the meal based on what's in season and\nin stock. The available fruit changes quickly, so customers can\u2019t choose the\nfruit or even see which fruit they'll get.\n\nmod back_of_house {\npub struct Breakfast {\npub toast: String,\nseasonal_fruit: String,\n\n}\n\nimpl Breakfast {\npub fn summer(toast: &str) -> Breakfast {\nBreakfast {\ntoast: String::from(toast),\nseasonal fruit: String::from(\"peaches\"),\n\npub fn eat_at_restaurant() {\n// Order a breakfast in the summer with Rye toast\nlet mut meal = back_of_house: :Breakfast: :summer(\"Rye\");\n// Change our mind about what bread we'd like\nmeal.toast = String::from(\"Wheat\");\nprintln!(\"I'd like {} toast please\", meal.toast);\n\n// The next line won't compile if we uncomment it; we're not allowed\n// to see or modify the seasonal fruit that comes with the meal\n// meal.seasonal_fruit = String::from(\"blueberries\");\n\n}\n\nListing 7-9: A struct with some public fields and some private fields\n\nsrc/lib.rs\n\nBecause the toast field in the back_of_house: :Breakfast struct is public,\nin eat_at_restaurant we can write and read to the toast field using dot nota-\ntion. Notice that we can\u2019t use the seasonal_fruit field in eat_at_restaurant\nbecause seasonal_fruit is private. Try uncommenting the line modifying\nthe seasonal_fruit field value to see what error you get!\n\nAlso, note that because back_of_house: : Breakfast has a private field,\nthe struct needs to provide a public associated function that constructs\nan instance of Breakfast (we\u2019ve named it summer here). If Breakfast didn\u2019t\nhave such a function, we couldn't create an instance of Breakfast in eat_at\n_restaurant because we couldn't set the value of the private seasonal_fruit\nfield in eat_at_restaurant.\n\nIn contrast, if we make an enum public, all of its variants are then public.\nWe only need the pub before the enum keyword, as shown in Listing 7-10.\n\nmod back_of_house {\npub enum Appetizer {\nSoup,\nSalad,\n\n}\n\npub fn eat_at_restaurant() {\nlet order1 = back_of_house: :Appetizer: : Soup;\nlet order2 = back_of_house: :Appetizer: :Salad;\n}\n\nListing 7-10: Designating an enum as public makes all its variants public\n\nBecause we made the Appetizer enum public, we can use the Soup and\nSalad variants in eat_at_restaurant. Enums aren't very useful unless their vari-\nants are public; it would be annoying to have to annotate all enum variants\nwith pub in every case, so the default for enum variants is to be public. Structs\nare often useful without their fields being public, so struct fields follow the\ngeneral rule of everything being private by default unless annotated with pub.\n\nThere's one more situation involving pub that we haven't covered, and\nthat is our last module system feature: the use keyword. We'll cover use by\nitself first, and then we'll show how to combine pub and use.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 7.8,
                        "section_name": "Bringing Paths into Scope with the use Keyword",
                        "section_path": "./screenshots-images-2/chapter_7/section_8",
                        "images": [
                            "./screenshots-images-2/chapter_7/section_8/95f8dace-94cd-4838-bb4c-bd31b26e5dc3.png",
                            "./screenshots-images-2/chapter_7/section_8/fd4333c4-1aad-41f2-b6c6-026b1232bd5c.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Bringing Paths into Scope with the use Keyword\n\nIt might seem like the paths we've written to call functions so far are incon-\nveniently long and repetitive. For example, in Listing 7-7, whether we chose\nthe absolute or relative path to the add_to_waitlist function, every time we\nwanted to call add_to_waitlist we had to specify front_of_house and hosting\ntoo. Fortunately, there's a way to simplify this process. We can bring a path\ninto a scope once and then call the items in that path as if they're local\nitems with the use keyword.\n\nsrc/lib.rs\n\nsrc/lib.rs\n\nIn Listing 7-11, we bring the crate: :front_of_house: :hosting mod-\nule into the scope of the eat_at_restaurant function so we only have to\nspecify hosting: :add_to_waitlist to call the add_to_waitlist function in\neat_at_restaurant.\n\nmod front_of_house {\npub mod hosting {\npub fn add_to_waitlist() {}\n\n}\nuse crate::front_of_house: : hosting;\n\npub fn eat_at_restaurant() {\nhosting: :add_to_waitlist();\nhosting: :add_to_waitlist();\nhosting: :add_to_waitlist();\n\n}\n\nListing 7-11: Bringing a module into scope with use\n\nAdding use and a path in a scope is similar to creating a symbolic link\nin the filesystem. By adding use crate: :front_of_house: :hosting in the crate\nroot, hosting is now a valid name in that scope, just as though the hosting\nmodule had been defined in the crate root. Paths brought into scope with\nuse also check privacy, like any other paths.\n\nSpecifying a relative path with use is slightly different. Instead of start-\ning from a name in the current scope, we must start the path given to use\nwith the keyword self. Listing 7-12 shows how to specify a relative path to\nget the same behavior as in Listing 7-11.\n\nmod fro\npub mod ing {\n\npub fn add to waitlist() {}\n\n}\n\nuse self::front_of_house: :hosting;\n\npub fn\n\nListing 7-12: Bringing a module into scope with use and a relative path starting with self\n\nNote that using self in this way might not be necessary in the future;\nit\u2019s an inconsistency in the language that Rust developers are working to\neliminate.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 7.9,
                        "section_name": "Creating Idiomatic use Paths",
                        "section_path": "./screenshots-images-2/chapter_7/section_9",
                        "images": [
                            "./screenshots-images-2/chapter_7/section_9/2fa6f301-3cf2-4659-8536-99344e2d0482.png",
                            "./screenshots-images-2/chapter_7/section_9/04bb846e-18e5-488e-83a0-47a08b185afe.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/lib.rs\n\nsrc/main.rs\n\nCreating Idiomatic use Paths\n\nIn Listing 7-11, you might have wondered why we specified use crate: : front\n_of_house: :hosting and then called hosting: :add_to_waitlist in eat_at_restaurant\nrather than specifying the use path all the way out to the add_to_waitlist func-\ntion to achieve the same result, as in Listing 7-13.\n\n1d front_of_house {\npub mod hos\n\npub fn add\n\n}\n\nuse crate::front_of_house: :hosting: :add_to_waitlist;\n\npub fn eat_at_restaurant(\nadd_to_waitlist();\nadd_to_waitlist();\nadd_to_waitlist();\n\nListing 7-13: Bringing the add_to_waitlist function into scope with use, which is unidiomatic\n\nAlthough both Listing 7-11 and 7-13 accomplish the same task,\nListing 7-11 is the idiomatic way to bring a function into scope with use.\nBringing the function\u2019s parent module into scope with use so we have to\nspecify the parent module when calling the function makes it clear that\nthe function isn\u2019t locally defined while still minimizing repetition of the\nfull path. The code in Listing 7-13 is unclear as to where add_to_waitlist is\ndefined.\n\nOn the other hand, when bringing in structs, enums, and other items\nwith use, it\u2019s idiomatic to specify the full path. Listing 7-14 shows the idi-\nomatic way to bring the standard library's HashMap struct into the scope of a\nbinary crate.\n\nuse std::collections: :HashMap;\n\nfn main() {\nlet mut map = HashMap: :new();\nmap.insert(1, 2);\n\n}\n\nListing 7-14: Bringing HashMap into scope in an idiomatic way\n\nThere's no strong reason behind this idiom: it\u2019s just the convention that\nhas emerged, and folks have gotten used to reading and writing Rust code\nthis way.\n\nThe exception to this idiom is if we\u2019re bringing two items with the\nsame name into scope with use statements, because Rust doesn\u2019t allow that.\nListing 7-15 shows how to bring two Result types into scope that have the\nsame name but different parent modules and how to refer to them.\n\nsrc/lib.rs\n\nuse std:: fmt;\nuse std::i0;\n\nfn functioni() -> fmt::Result {\n\n// --snip--\n\n}\n\nfn function2() -> io::Result<()> {\n// --snip--\n\n}\n\nListing 7-15: Bringing two types with the same name into the same scope requires using\ntheir parent modules.\n\nAs you can see, using the parent modules distinguishes the two Result\ntypes. If instead we specified use std::fmt::Result and use std::i0::Result, we'd\nhave two Result types in the same scope and Rust wouldn't know which one\nwe meant when we used Result.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 7.1,
                        "section_name": "Providing New Names with the as Keyword",
                        "section_path": "./screenshots-images-2/chapter_7/section_10",
                        "images": [
                            "./screenshots-images-2/chapter_7/section_10/57267b8b-e94c-4429-bf57-4f31d7921e97.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/lib.rs\n\nProviding New Names with the as Keyword\n\nThere\u2019s another solution to the problem of bringing two types of the same\nname into the same scope with use: after the path, we can specify as and a\nnew local name, or alias, for the type. Listing 7-16 shows another way to write\nthe code in Listing 7-15 by renaming one of the two Result types using as.\n\nuse std::fmt::Result;\nuse std::io::Result as IoResult;\n\nfn function1() -> Result {\n\n// --snip--\n\n}\n\nfn function2() -> IoResult<()> {\n// --snip--\n\n}\n\nListing 7-16: Renaming a type when it\u2019s brought into scope with the as keyword\n\nIn the second use statement, we chose the new name IoResult for the\nstd::i0::Result type, which won't conflict with the Result from std::fmt that\nwe've also brought into scope. Listing 7-15 and Listing 7-16 are both consid-\nered idiomatic, so the choice is up to you!\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 7.11,
                        "section_name": "Re-exporting Names with pub use",
                        "section_path": "./screenshots-images-2/chapter_7/section_11",
                        "images": [
                            "./screenshots-images-2/chapter_7/section_11/6a6cbd00-4ea7-4e20-9cdb-eb2b1773b94b.png",
                            "./screenshots-images-2/chapter_7/section_11/2a25d19c-89d4-4574-8963-81d796e54c34.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Re-exporting Names with pub use\n\nWhen we bring a name into scope with the use keyword, the name available\nin the new scope is private. To enable the code that calls our code to refer\nto that name as if it had been defined in that code\u2019s scope, we can combine\n\nsrc/lib.rs\n\npub and use. This technique is called re-exporting because we're bringing an\nitem into scope but also making that item available for others to bring into\ntheir scope.\n\nListing 7-17 shows the code in Listing 7-11 with use in the root module\nchanged to pub use.\n\npub mod hos\npub fn\n\n}\n\nListing 7-17: Making a name available for any code to use from a new scope with pub use\n\nBy using pub use, external code can now call the add_to_waitlist func-\ntion using hosting: :add_to_waitlist. If we hadn't specified pub use, the eat\n_at_restaurant function could call hosting: :add_to_waitlist in its scope, but\nexternal code couldn't take advantage of this new path.\n\nRe-exporting is useful when the internal structure of your code is dif-\nferent from how programmers calling your code would think about the\ndomain. For example, in this restaurant metaphor, the people running the\nrestaurant think about \u201cfront of house\u201d and \u201cback of house.\u201d But customers\nvisiting a restaurant probably won't think about the parts of the restaurant\nin those terms. With pub use, we can write our code with one structure but\nexpose a different structure. Doing so makes our library well organized for\nprogrammers working on the library and programmers calling the library.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 7.12,
                        "section_name": "Using External Packages",
                        "section_path": "./screenshots-images-2/chapter_7/section_12",
                        "images": [
                            "./screenshots-images-2/chapter_7/section_12/b04bdda6-da18-4910-b3c6-d09613b00af8.png",
                            "./screenshots-images-2/chapter_7/section_12/684d5907-a88d-4bac-a049-258d40fbde76.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Cargo.tom!\n\nUsing External Packages\n\nIn Chapter 2, we programmed a guessing game project that used an external\npackage called rand to get random numbers. To use rand in our project, we\nadded this line to Cargo.toml:\n\n[dependencies]\nrand = \"0.5.5\"\n\nAdding rand as a dependency in Cargo.toml tells Cargo to download the\nrand package and any dependencies from Attps://crates.io/ and make rand\navailable to our project.\n\nThen, to bring rand definitions into the scope of our package, we added\na use line starting with the name of the package, rand, and listed the items we\n\nwanted to bring into scope. Recall that in \u201cGenerating a Random Number\u201d\non page 21, we brought the Rng trait into scope and called the rand: : thread\n_1ng function:\n\nuse rand: :Rng;\nfn main() {\n\nlet secret_number = rand::thread_rng().gen_range(1, 101);\n}\n\nMembers of the Rust community have made many packages available\nat Attps://crates.io/, and pulling any of them into your package involves these\nsame steps: listing them in your package\u2019s Cargo.toml file and using use to\nbring items into scope.\n\nNote that the standard library (std) is also a crate that\u2019s external to our\npackage. Because the standard library is shipped with the Rust language,\nwe don\u2019t need to change Cargo.tom/ to include std. But we do need to refer\nto it with use to bring items from there into our package's scope. For example,\nwith HashMap we would use this line:\n\nuse std::collections: :HashMap;\n\nThis is an absolute path starting with std, the name of the standard\nlibrary crate.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 7.13,
                        "section_name": "Using Nested Paths to Cean Up Large use Lists",
                        "section_path": "./screenshots-images-2/chapter_7/section_13",
                        "images": [
                            "./screenshots-images-2/chapter_7/section_13/6bed0dec-ff30-4435-b392-2d9e83fd431f.png",
                            "./screenshots-images-2/chapter_7/section_13/3204b1dc-3f8c-4a3e-b55b-cf00cf88a733.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nstc/main.rs\n\nUsing Nested Paths to Gean Up Large use Lists\n\nIf we're using multiple items defined in the same package or same module,\nlisting each item on its own line can take up a lot of vertical space in our\nfiles. For example, these two use statements we had in the Guessing Game in\nListing 2-4 on page 23 bring items from std into scope:\n\nuse std::io;\nuse std::cmp::Ordering;\n// --snip--\n\nInstead, we can use nested paths to bring the same items into scope in\none line. We do this by specifying the common part of the path, followed by\ntwo colons, and then curly brackets around a list of the parts of the paths\nthat differ, as shown in Listing 7-18.\n\nuse std::{io, cmp::0Ordering};\n// ~-snip--\n\nListing 7-18: Specifying a nested path to bring multiple items with the same prefix into scope\n\nIn bigger programs, bringing many items into scope from the same\npackage or module using nested paths can reduce the number of separate\nuse statements needed by a lot!\n\nsrc/lib.rs\n\nsrc/lib.rs\n\nWe can use a nested path at any level in a path, which is useful\nwhen combining two use statements that share a subpath. For example,\nListing 7-19 shows two use statements: one that brings std::io into scope\nand one that brings std: :io: :Write into scope.\n\nuse std::io;\nuse std::io::Write;\n\nListing 7-19: Two use statements where one is a subpath of the other\n\nThe common part of these two paths is std: :io, and that\u2019s the complete\nfirst path. To merge these two paths into one use statement, we can use self\nin the nested path, as shown in Listing 7-20.\n\nuse std::io::{self, Write};\n\nListing 7-20: Combining the paths in Listing 7-19 into one use statement\n\nThis line brings std::io and std::io::Write into scope.\n\nThe Glob Operator\n\nIf we want to bring all public items defined in a path into scope, we can\nspecify that path followed by *, the glob operator:\n\nuse std::collections: :*;\n\nThis use statement brings all public items defined in std: :collections\ninto the current scope. Be careful when using the glob operator! Glob can\nmake it harder to tell what names are in scope and where a name used in\nyour program was defined.\n\nThe glob operator is often used when testing to bring everything\nunder test into the tests module; we'll talk about that in \u201cHow to Write\nTests\u201d on page 208. The glob operator is also sometimes used as part of\nthe prelude pattern: see the standard library documentation at https://doc\n-rust-lang.org/stable/std/prelude/index.html#other-preludes for more informa-\ntion on that pattern.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 7.14,
                        "section_name": "Separating Modules into Different Files",
                        "section_path": "./screenshots-images-2/chapter_7/section_14",
                        "images": [
                            "./screenshots-images-2/chapter_7/section_14/6a901ff0-40c7-433e-bdd7-525b324eb546.png",
                            "./screenshots-images-2/chapter_7/section_14/68d1e786-6d9f-4d97-b3a5-c72ec2c15c08.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Separating Modules into Different Files\n\nSo far, all the examples in this chapter defined multiple modules in one\nfile. When modules get large, you might want to move their definitions to a\nseparate file to make the code easier to navigate.\n\nFor example, let\u2019s start from the code in Listing 7-17 and move the\nfront_of_house module to its own file src/front_of_house.rs by changing the\ncrate root file so it contains the code shown in Listing 7-21. In this case,\nthe crate root file is sr\u00a2/lib.rs, but this procedure also works with binary\ncrates whose crate root file is src/main.rs.\n\nsrc/lib.rs\n\nsrc/front_of_house.rs\n\nsrc/front_of_house.rs\n\nsrc/front_of_house/\nhosting.rs\n\nmod front_of_house;\npub use crate::front_of_house::hosting;\n\npub fn eat_at_restaurant() {\nhosting: :add_to_waitlist();\nhosting: :add_to_waitlist();\nhosting: :add_to_waitlist();\n}\n\nListing 7-21: Declaring the front_of_house module whose body will be in src/front_of\n_house.rs\n\nAnd src/front_of_house.rs gets the definitions from the body of the\nfront_of_house module, as shown in Listing 7-22.\n\npub mod hosting {\npub fn add_to_waitlist() {}\n}\n\nListing 7-22: Definitions inside the front_of_house module in src/front_of_house.rs\n\nUsing a semicolon after mod front_of_house rather than using a block\ntells Rust to load the contents of the module from another file with the\nsame name as the module. To continue with our example and extract the\nhosting module to its own file as well, we change src/front_of_house.rs to con-\ntain only the declaration of the hosting module:\n\npub mod hosting;\n\nThen we create a src/front_of_house directory and a file sre/front_of\n_house/hosting.rs to contain the definitions made in the hosting module:\n\npub fn add_to_waitlist() {}\n\nThe module tree remains the same, and the function calls in eat_at\n_restaurant will work without any modification, even though the definitions\nlive in different files. This technique lets you move modules to new files as\nthey grow in size.\n\nNote that the pub use crate: :front_of_house::hosting statement in\nsr\u00a2/lib.rs also hasn\u2019t changed, nor does use have any impact on what files\nare compiled as part of the crate. The mod keyword declares modules, and\nRust looks in a file with the same name as the module for the code that\ngoes into that module.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 7.15,
                        "section_name": "Summary",
                        "section_path": "./screenshots-images-2/chapter_7/section_15",
                        "images": [
                            "./screenshots-images-2/chapter_7/section_15/b0f23206-4ae5-40e6-9902-8aa1807b7bbd.png",
                            "./screenshots-images-2/chapter_7/section_15/e6466c42-1062-4a12-8b43-abe5b093dde3.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Summary\n\nRust lets you organize your packages into crates and your crates into mod-\nules so you can refer to items defined in one module from another module.\nYou can do this by specifying absolute or relative paths. These paths can be\n\nbrought into scope with a use statement so you can use a shorter path for\nmultiple uses of the item in that scope. Module code is private by default,\nbut you can make definitions public by adding the pub keyword.\n\nIn the next chapter, we'll look at some collection data structures in the\nstandard library that you can use in your neatly organized code.\n",
                        "extracted-code": ""
                    }
                ]
            },
            {
                "chapter_id": 8,
                "chapter_name": "COMMON COLLECTIONS",
                "chapter_path": "./screenshots-images-2/chapter_8",
                "sections": [
                    {
                        "section_id": 8.1,
                        "section_name": "COMMON COLLECTIONS",
                        "section_path": "./screenshots-images-2/chapter_8/section_1",
                        "images": [
                            "./screenshots-images-2/chapter_8/section_1/02b4e3c4-fe4d-47aa-b202-99e5360e5aa9.png",
                            "./screenshots-images-2/chapter_8/section_1/6d6c4bbb-211b-40e4-924b-0ead28d0dc68.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Rust\u2019s standard library includes a number\nof very useful data structures called collec-\n\ntions. Most other data types represent one\nspecific value, but collections can contain mul-\n\ntiple values. Unlike the built-in array and tuple types,\n\nthe data these collections point to is stored on the\n\nheap, which means the amount of data does not need to be known at com-\npile time and can grow or shrink as the program runs. Each kind of collec-\ntion has different capabilities and costs, and choosing an appropriate one\nfor your current situation is a skill you'll develop over time. In this chapter,\nwe'll discuss three collections that are used very often in Rust programs:\n\ne A vectorallows you to store a variable number of values next to each other.\n\ne A Stringis a collection of characters. We've mentioned the String type\npreviously, but in this chapter we'll talk about it in depth.\n\ne A hash map allows you to associate a value with a particular key. It\u2019s a par-\nticular implementation of the more general data structure called a map.\n\nTo learn about the other kinds of collections provided by the standard\nlibrary, see the documentation at Attps://doc.rust-lang.org/stable/std/collections/.\n\nWe'll discuss how to create and update vectors, strings, and hash maps,\nas well as what makes each special.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 8.2,
                        "section_name": "Storing Lists of Values with Vectors",
                        "section_path": "./screenshots-images-2/chapter_8/section_2",
                        "images": [
                            "./screenshots-images-2/chapter_8/section_2/ff0d0d0c-a167-49b7-9058-18c33bdb990b.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Storing Lists of Values with Vectors\n\nThe first collection type we'll look at is Vec<T>, also known as a vector. Vectors\nallow you to store more than one value in a single data structure that puts\nall the values next to each other in memory. Vectors can only store values\nof the same type. They are useful when you have a list of items, such as the\nlines of text in a file or the prices of items in a shopping cart.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 8.3,
                        "section_name": "Geating a New Vector",
                        "section_path": "./screenshots-images-2/chapter_8/section_3",
                        "images": [
                            "./screenshots-images-2/chapter_8/section_3/3ccce2ea-d6a0-433b-8dd3-cfb5e7f57939.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Geating a New Vector\n\nTo create a new, empty vector, we can call the Vec: :new function, as shown in\nListing 8-1.\n\nlet v: Vec<i32> = Vec::new();\n\nListing 8-1: Creating a new, empty vector to hold values of type i32\n\nNote that we added a type annotation here. Because we aren\u2019t inserting\nany values into this vector, Rust doesn\u2019t know what kind of elements we intend\nto store. This is an important point. Vectors are implemented using generics;\nwe\u2019ll cover how to use generics with your own types in Chapter 10. For now,\nknow that the Vec<T> type provided by the standard library can hold any type,\nand when a specific vector holds a specific type, the type is specified within\nangle brackets. In Listing 8-1, we've told Rust that the Vec<T> in v will hold\nelements of the i32 type.\n\nIn more realistic code, Rust can often infer the type of value you want to\nstore once you insert values, so you rarely need to do this type annotation. It\u2019s\nmore common to create a Vec<T> that has initial values, and Rust provides the\nvec! macro for convenience. The macro will create a new vector that holds the\nvalues you give it. Listing 8-2 creates a new Vec<i32> that holds the values 4, 2,\nand 3.\n\nlet v = vec![1, 2, 3];\n\nListing 8-2: Creating a new vector containing values\n\nBecause we've given initial i32 values, Rust can infer that the type of v is\nVec<i32>, and the type annotation isn\u2019t necessary. Next, we'll look at how to\nmodify a vector.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 8.4,
                        "section_name": "Updating a Vector",
                        "section_path": "./screenshots-images-2/chapter_8/section_4",
                        "images": [
                            "./screenshots-images-2/chapter_8/section_4/e0f228d2-4726-4b95-93c4-95090204d8e6.png",
                            "./screenshots-images-2/chapter_8/section_4/093f8487-547f-464d-809a-c6b90cedc1b0.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Updating a Vector\nTo create a vector and then add elements to it, we can use the push method,\nas shown in Listing 8-3.\n\nlet mut v = Vec::new();\n\nv.push(S);\nv.push(6);\nv.push(7);\nv.push(8);\n\nListing 8-3: Using the push method to add values to a vector\n\nAs with any variable, if we want to be able to change its value, we need\nto make it mutable using the mut keyword, as discussed in Chapter 3. The\nnumbers we place inside are all of type i32, and Rust infers this from the\ndata, so we don\u2019t need the Vec<i32> annotation.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 8.5,
                        "section_name": "Dropping a Vector Drops Its Elements",
                        "section_path": "./screenshots-images-2/chapter_8/section_5",
                        "images": [
                            "./screenshots-images-2/chapter_8/section_5/97aa5c9d-a165-4c5e-9fe6-b86a89dcfcf9.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Dropping a Vector Drops Its Elements\n\nLike any other struct, a vector is freed when it goes out of scope, as annotated\nin Listing 8-4.\n\n{\nlet v = vec![1, 2, 3, 4];\n\n// do stuff with v\n} // <- v goes out of scope and is freed here\n\nListing 8-4: Showing where the vector and its elements are dropped\n\nWhen the vector gets dropped, all of its contents are also dropped,\nmeaning those integers it holds will be cleaned up. This may seem like a\nstraightforward point but can get a bit more complicated when you start to\nintroduce references to the elements of the vector. Let's tackle that next!\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 8.6,
                        "section_name": "Reading Elements of Vectors",
                        "section_path": "./screenshots-images-2/chapter_8/section_6",
                        "images": [
                            "./screenshots-images-2/chapter_8/section_6/e15e39ac-f1d7-4707-b46d-5cd0284fe34d.png",
                            "./screenshots-images-2/chapter_8/section_6/9995943f-4525-4d8d-880c-2ab3d4a93aec.png",
                            "./screenshots-images-2/chapter_8/section_6/d6348226-d218-4232-94be-2eb889a05057.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Reading Elements of Vectors\n\nNow that you know how to create, update, and destroy vectors, knowing how\nto read their contents is a good next step. There are two ways to reference a\nvalue stored in a vector. In the examples, we've annotated the types of the\nvalues that are returned from these functions for extra clarity.\n\nListing 8-5 shows both methods of accessing a value in a vector, either\nwith indexing syntax or the get method.\n\nlet v = vec![1, 2, 3, 4, 5];\n\nlet third: &i32 = &v[2];\nprintln!(\"The third element is {}\", third);\n\nmatch v.get(2) {\nSome(third) => println!(\"The third element is {}\", third),\nNone => println!(\"There is no third element.\"),\n\n}\n\nListing 8-5: Using indexing syntax or the get method to access an item in a vector\n\nNote two details here. First, we use the index value of 2 to get the third\nelement: vectors are indexed by number, starting at zero. Second, the two\nways to get the third element are by using & and [], which gives us a reference,\nor by using the get method with the index passed as an argument, which\ngives us an Option<&T>.\n\nRust has two ways to reference an element so you can choose how the\nprogram behaves when you try to use an index value that the vector doesn\u2019t\nhave an element for. As an example, let\u2019s see what a program will do if it\nhas a vector that holds five elements and then tries to access an element at\nindex 100, as shown in Listing 8-6.\n\nlet v = vec![1, 2, 3, 4, 5];\n\nlet does_not_exist\nlet does_not_exist\n\n&v[100];\nv.get(100) ;\n\nListing 8-6: Attempting to access the element at index 100 in a vector containing\nfive elements\n\nWhen we run this code, the first [] method will cause the program to\npanic because it references a nonexistent element. This method is best used\nwhen you want your program to crash if there\u2019s an attempt to access an ele-\nment past the end of the vector.\n\nWhen the get method is passed an index that is outside the vector, it\nreturns None without panicking. You would use this method if accessing an\nelement beyond the range of the vector happens occasionally under nor-\nmal circumstances. Your code will then have logic to handle having either\nSome(&element) or None, as discussed in Chapter 6. For example, the index\ncould be coming from a person entering a number. If they accidentally\nenter a number that\u2019s too large and the program gets a None value, you\ncould tell the user how many items are in the current vector and give them\nanother chance to enter a valid value. That would be more user-friendly\nthan crashing the program due to a typo!\n\nWhen the program has a valid reference, the borrow checker enforces\nthe ownership and borrowing rules (covered in Chapter 4) to ensure this\nreference and any other references to the contents of the vector remain\nvalid. Recall the rule that states you can\u2019t have mutable and immutable ref\nerences in the same scope. That rule applies in Listing 8-7, where we hold\nan immutable reference to the first element in a vector and try to add an\nelement to the end, which won't work.\n\nlet mut v = vec![1, 2, 3, 4, 5];\nlet first = &v[o];\nv.push(6);\n\nprintln!(\"The first element is: {}\", first);\n\nListing 8-7: Attempting to add an element to a vector while holding a reference to an item\n\nCompiling this code will result in this error:\n\nerror[E0502]: cannot borrow ~v\u2019 as mutable because it is also borrowed as immutable\n--> src/main.rs:6:5\n\nlet first = &v[o];\n\n- immutable borrow occurs here\n\nv.push(6) ;\nAAAAAAAAN mutable borrow occurs here\n\nprintln!(\"The first element is: {}\", first);\n\n----- immutable borrow later used here\n\nThe code in Listing 8-7 might look like it should work: why should a\nreference to the first element care about what changes at the end of the\nvector? This error is due to the way vectors work: adding a new element\nonto the end of the vector might require allocating new memory and\ncopying the old elements to the new space, if there isn\u2019t enough room to\nput all the elements next to each other where the vector currently is. In\nthat case, the reference to the first element would be pointing to deallo-\ncated memory. The borrowing rules prevent programs from ending up in\nthat situation.\n\nFor more on the implementation details of the Vec<T> type, see The Rustonomicon\nat https://doc.rust-lang.org/stable/nomicon/vec.html.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 8.7,
                        "section_name": "Iterating over the Values in a Vector",
                        "section_path": "./screenshots-images-2/chapter_8/section_7",
                        "images": [
                            "./screenshots-images-2/chapter_8/section_7/daaaa877-cf16-4200-8f1f-b2bc5b97aabc.png",
                            "./screenshots-images-2/chapter_8/section_7/16318068-a793-4133-8bed-c0c2f5faed95.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Iterating over the Values in a Vector\n\nIf we want to access each element in a vector in turn, we can iterate through\nall of the elements rather than use indices to access one at a time. Listing 8-8\nshows how to use a for loop to get immutable references to each element in a\nvector of i32 values and print them.\n\nlet v = vec![100, 32, 57];\nfor i in &v {\nprintln!(\"{}\", i);\n\nListing 8-8: Printing each element in a vector by iterating over the elements using a for loop\n\nWe can also iterate over mutable references to each element in a\nmutable vector in order to make changes to all the elements. The for loop\nin Listing 8-9 will add 50 to each element.\n\nlet mut v = vec![100, 32, 57];\nfor i in &mut v {\n\n*i += 50;\n}\n\nlisting 8-9: Iterating over mutable references to elements in a vector\n\nTo change the value that the mutable reference refers to, we have to use\nthe dereference operator (*) to get to the value in i before we can use the\n+= operator. We'll talk more about the dereference operator in \u201cFollowing\nthe Pointer to the Value with the Dereference Operator\u201d on page 318.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 8.8,
                        "section_name": "Using an Enum to Store Multiple Types",
                        "section_path": "./screenshots-images-2/chapter_8/section_8",
                        "images": [
                            "./screenshots-images-2/chapter_8/section_8/55b1d737-979f-436f-992d-dfbfdb808451.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Using an Enum to Store Multiple Types\n\nAt the beginning of this chapter, we said that vectors can only store values that\nare the same type. This can be inconvenient; there are definitely use cases for\nneeding to store a list of items of different types. Fortunately, the variants of\nan enum are defined under the same enum type, so when we need to store\nelements of a different type in a vector, we can define and use an enum!\n\nFor example, say we want to get values from a row in a spreadsheet in\nwhich some of the columns in the row contain integers, some floating-\npoint numbers, and some strings. We can define an enum whose variants\nwill hold the different value types, and then all the enum variants will be\nconsidered the same type: that of the enum. Then we can create a vector\nthat holds that enum and so, ultimately, holds different types. We've dem-\nonstrated this in Listing 8-10.\n\nenum SpreadsheetCell {\nInt(i32),\nFloat (64),\nText (String),\n\n}\n\nlet row = vec![\nSpreadsheetCell: :Int(3),\nSpreadsheetCell: : Text (String: :from(\"blue\")),\nSpreadsheetCell::Float(10.12),\n\nFE\nListing 8-10: Defining an enum to store values of different types in one vector\n\nRust needs to know what types will be in the vector at compile time so it\nknows exactly how much memory on the heap will be needed to store each\nelement. A secondary advantage is that we can be explicit about what types\nare allowed in this vector. If Rust allowed a vector to hold any type, there\nwould be a chance that one or more of the types would cause errors with\nthe operations performed on the elements of the vector. Using an enum\nplus a match expression means that Rust will ensure at compile time that\nevery possible case is handled, as discussed in Chapter 6.\n\nWhen you're writing a program, if you don\u2019t know the exhaustive set of\ntypes the program will get at runtime to store in a vector, the enum tech-\nnique won't work, Instead, you can use a trait object, which we'll cover in\nChapter 17.\n\nNow that we've discussed some of the most common ways to use vectors,\nbe sure to review the API documentation for all the many useful methods\ndefined on Vec<T> by the standard library. For example, in addition to push, a\npop method removes and returns the last element. Let\u2019s move on to the next\ncollection type: String!\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 8.9,
                        "section_name": "Storing UTF-8 Encoded Text with Strings",
                        "section_path": "./screenshots-images-2/chapter_8/section_9",
                        "images": [
                            "./screenshots-images-2/chapter_8/section_9/29cad0ca-5995-4419-9c99-af5ea465a929.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Storing UTF-8 Encoded Text with Strings\n\nWe talked about strings in Chapter 4, but we'll look at them in more depth\nnow. New Rustaceans commonly get stuck on strings for a combination of\nthree reasons: Rust\u2019s propensity for exposing possible errors, strings being a\nmore complicated data structure than many programmers give them credit\nfor, and UTF-8. These factors combine in a way that can seem difficult when\nyou're coming from other programming languages.\n\nIt\u2019s useful to discuss strings in the context of collections because strings\nare implemented as a collection of bytes, plus some methods to provide use-\nful functionality when those bytes are interpreted as text. In this section, we'll\ntalk about the operations on String that every collection type has, such as\ncreating, updating, and reading. We'll also discuss the ways in which String\nis different from the other collections, namely how indexing into a String is\ncomplicated by the differences between how people and computers interpret\nString data.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 8.1,
                        "section_name": "What Is a String?",
                        "section_path": "./screenshots-images-2/chapter_8/section_10",
                        "images": [
                            "./screenshots-images-2/chapter_8/section_10/4adb0604-3119-427f-a959-f463ba2728b0.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "What Is a String?\n\nWe'll first define what we mean by the term string. Rust has only one string\ntype in the core language, which is the string slice str that is usually seen\nin its borrowed form &str. In Chapter 4, we talked about string slices, which\nare references to some UTF-8 encoded string data stored elsewhere. String\nliterals, for example, are stored in the program's binary and are therefore\nstring slices.\n\nThe String type, which is provided by Rust\u2019s standard library rather than\ncoded into the core language, is a growable, mutable, owned, UTF-8 encoded\nstring type. When Rustaceans refer to \u201cstrings\u201d in Rust, they usually mean the\nString and the string slice &str types, not just one of those types. Although\nthis section is largely about String, both types are used heavily in Rust\u2019s stan-\ndard library, and both String and string slices are UTF-8 encoded.\n\nRust\u2019s standard library also includes a number of other string types,\nsuch as OsString, OsStr, CString, and CStr. Library crates can provide even\nmore options for storing string data. See how those names all end in String\nor Str? They refer to owned and borrowed variants, just like the String and\nstr types you've seen previously. These string types can store text in differ-\nent encodings or be represented in memory in a different way, for example.\nWe won't discuss these other string types in this chapter; see their API doc-\numentation for more about how to use them and when each is appropriate.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 8.11,
                        "section_name": "Geating a New String",
                        "section_path": "./screenshots-images-2/chapter_8/section_11",
                        "images": [
                            "./screenshots-images-2/chapter_8/section_11/05f205eb-7f89-47be-849a-876e2bf28404.png",
                            "./screenshots-images-2/chapter_8/section_11/4c1b073f-0d4b-4b0a-b767-2956ba1025fe.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Creating a New String\n\nMany of the same operations available with Vec<T> are available with\nString as well, starting with the new function to create a string, shown in\nListing 8-11.\n\nlet mut s = String: :new();\n\nListing 8-11: Creating a new, empty String\n\nThis line creates a new, empty string called s, which we can then load\ndata into. Often, we'll have some initial data that we want to start the string\nwith. For that, we use the to_string method, which is available on any type\nthat implements the Display trait, as string literals do. Listing 8-12 shows two\nexamples.\n\nlet data = \"initial contents\";\nlet s = data.to_string();\n\n// the method also works on a literal directly:\nlet s = \u201cinitial contents\".to_string();\n\nListing 8-12: Using the to_string method to create a String from a string literal\n\nThis code creates a string containing initial contents.\n\nWe can also use the function String: : from to create a String from a string\nliteral. The code in Listing 8-13 is equivalent to the code from Listing 8-12\nthat uses to_string.\n\nlet s = String::from(\"initial contents\");\n\nListing 8-13: Using the String: : from function to create a String from a string literal\n\nBecause strings are used for so many things, we can use many different\ngeneric APIs for strings, providing us with a lot of options. Some of them\ncan seem redundant, but they all have their place! In this case, String: :from\nand to_string do the same thing, so which you choose is a matter of style.\n\nRemember that strings are UTF-8 encoded, so we can include any prop-\nerly encoded data in them, as shown in Listing 8-14.\n\nlet hello = String::from(\"pcsiic pruJ!\");\nlet hello = String::from(\"Dobry den\");\n\nlet hello = String: :from(\"Hello\");\n\nlet hello = String::from(\"oi2w\");\n\nlet hello = String: :from(\"TRIA\") ;\n\nlet hello = String::from(\"CAIZ6Ix\");\nlet hello = String::from(\"OtWotA|Q\");\nlet hello = String: :from(\"#R#F\");\n\nlet hello = String: :from(\"014\");\n\nlet hello = String::from(\"3apasctsyite\");\nlet hello = String::from(\"Hola\");\n\nListing 8-14: Storing greetings in different languages in strings\n\nAll of these are valid String values.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 8.12,
                        "section_name": "Updating a String",
                        "section_path": "./screenshots-images-2/chapter_8/section_12",
                        "images": [
                            "./screenshots-images-2/chapter_8/section_12/7a3f27da-80f1-482d-8167-8965a8cf0b4b.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Updating a String\n\nA String can grow in size and its contents can change, just like the contents\nof a Vec<T>, if you push more data into it. In addition, you can conveniently\nuse the + operator or the format! macro to concatenate String values.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 8.13,
                        "section_name": "Appending to a String with push_str and push",
                        "section_path": "./screenshots-images-2/chapter_8/section_13",
                        "images": [
                            "./screenshots-images-2/chapter_8/section_13/64ad30c7-2264-40f1-87fb-689ffeab5ee6.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Appending to a String with push_str and push\n\nWe can grow a String by using the push_str method to append a string slice,\nas shown in Listing 8-15.\n\nlet mut s = String::from(\"foo\");\ns.push_str(\"bar\");\n\nListing 8-15: Appending a string slice to a String using the push_str method\n\nAfter these two lines, s will contain foobar. The push_str method takes\na string slice because we don't necessarily want to take ownership of the\nparameter. For example, the code in Listing 8-16 shows that it would be\nunfortunate if we weren't able to use s2 after appending its contents to s1.\n\nlet mut si = String::from(\"foo\");\nlet s2 = \u201cbar\";\n\n$1.push_str(s2);\n\nprintln!(\"s2 is {}\", s2);\n\nListing 8-16: Using a string slice after appending its contents to a String\n\nIf the push_str method took ownership of s2, we wouldn't be able to print\nits value on the last line. However, this code works as we'd expect!\n\nThe push method takes a single character as a parameter and adds it to\nthe String. Listing 8-17 shows code that adds the letter /to a String using the\npush method.\n\nlet mut s\n\n= String: :from(\"lo\");\ns.push('1\");\n\nListing 8-17: Adding one character to a String value using push\n\nAs a result of this code, s will contain 1ol.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 8.14,
                        "section_name": "Concatenation with the + Operator or the format! Macro",
                        "section_path": "./screenshots-images-2/chapter_8/section_14",
                        "images": [
                            "./screenshots-images-2/chapter_8/section_14/12a396b9-0126-4d2e-b62a-40313ce0e1d6.png",
                            "./screenshots-images-2/chapter_8/section_14/374c6056-ed75-4f87-8415-558960a4fb61.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Concatenation with the + Operator or the format! Macro\n\nOften, you\u2019ll want to combine two existing strings. One way is to use the\n+ operator, as shown in Listing 8-18.\n\nlet si = String::from(\"Hello, \");\nlet s2 = String: :from(\"world!\");\nlet s3 = si + &s2; // note s1 has been moved here and can no longer be used\n\nListing 8-18: Using the + operator to combine two String values into a new String value\n\nThe string s3 will contain Hello, world! as a result of this code. The rea-\nson s1 is no longer valid after the addition and the reason we used a refer-\nence to s2 has to do with the signature of the method that gets called when\nwe use the + operator. The + operator uses the add method, whose signature\nlooks something like this:\n\nfn add(self, s: &str) -> String {\n\nThis isn\u2019t the exact signature that\u2019s in the standard library: in the\nstandard library, add is defined using generics. Here, we're looking at the\nsignature of add with concrete types substituted for the generic ones, which\nis what happens when we call this method with String values. We'll discuss\ngenerics in Chapter 10. This signature gives us the clues we need to under-\nstand the tricky bits of the + operator.\n\nFirst, s2 has an & meaning that we\u2019re adding a reference of the second\nstring to the first string because of the s parameter in the add function: we\ncan only add a &str to a String; we can\u2019t add two String values together. But\nwait\u2014the type of &s2 is String, not &str, as specified in the second param-\neter to add. So why does Listing 8-18 compile?\n\nThe reason we're able to use &s2 in the call to add is that the compiler\ncan coerce the &tring argument into a &str. When we call the add method,\nRust uses a deref coercion, which here turns &s2 into &s2[..]. We'll discuss\nderef coercion in more depth in Chapter 15. Because add does not take\nownership of the s parameter, s2 will still be a valid String after this\noperation.\n\nSecond, we can see in the signature that add takes ownership of self,\nbecause self does not have an & This means s1 in Listing 8-18 will be\nmoved into the add call and no longer be valid after that. So although let\n$3 = s1 + &s2; looks like it will copy both strings and create a new one, this\nstatement actually takes ownership of si, appends a copy of the contents\nof s2, and then returns ownership of the result. In other words, it looks\nlike it\u2019s making a lot of copies but isn\u2019t; the implementation is more effi-\ncient than copying.\n\nIf we need to concatenate multiple strings, the behavior of the + operator\ngets unwieldy:\n\nlet s1 = String::from(\"tic\");\nlet s2 = String::from(\"tac\");\nlet s3 = String::from(\"toe\");\n\nlet s = si + \"-\" + &s2 + \"-\" + 853;\n\nAt this point, s will be tic-tac-toe. With all of the + and \" characters, it\u2019s\ndifficult to see what's going on. For more complicated string combining, we\ncan use the format! macro:\n\nlet s1 = String::from(\"tic\");\nlet s2 =\nlet s3 = String::from(\"toe\");\n\nlet s = format! (\"{}-{}-{}\", $1, s2, 53);\n\nThis code also sets s to tic-tac-toe. The format! macro works in the same\nway as println!, but instead of printing the output to the screen, it returns a\nString with the contents. The version of the code using format! is much easier\nto read and doesn\u2019t take ownership of any of its parameters.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 8.15,
                        "section_name": "Indexing into Strings",
                        "section_path": "./screenshots-images-2/chapter_8/section_15",
                        "images": [
                            "./screenshots-images-2/chapter_8/section_15/1927c459-bf0c-4481-b9e1-a9c2a0cb08d1.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Indexing into Strings\n\nIn many other programming languages, accessing individual characters\n\nin a string by referencing them by index is a valid and common operation.\nHowever, if you try to access parts of a String using indexing syntax in Rust,\nyou'll get an error. Consider the invalid code in Listing 8-19.\n\nlet si = String: :from(\"hello\");\nlet h = s1fo];\n\nListing 8-19: Attempting to use indexing syntax with a String\nThis code will result in the following error:\n\nerror[E0277]: the trait bound ~std::string::String: std::ops::Index<{integer}>~ is not satisfied\n-->\n\n3 let h = s1[0];\n\n|\n| anna the type \u201cstd: :string::String\u2019 cannot be indexed by ~{integer}~\n|\n\nhelp: the trait ~std::ops::Index<{integer}>\u201d is not implemented for \u201cstd::string: :String\u201d\n\nThe error and the note tell the story: Rust strings don\u2019t support index-\ning. But why not? To answer that question, we need to discuss how Rust\nstores strings in memory.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 8.16,
                        "section_name": "Internal Representation",
                        "section_path": "./screenshots-images-2/chapter_8/section_16",
                        "images": [
                            "./screenshots-images-2/chapter_8/section_16/5ffccdaa-1911-412d-8306-6698108b1347.png",
                            "./screenshots-images-2/chapter_8/section_16/01332861-1d16-45d6-82a6-9c41815f94cf.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Internal Representation\n\nA String is a wrapper over a Vec<u8>. Let's look at some of our properly\nencoded UTF-8 example strings from Listing 8-14. First, this one:\n\nlet len = String::from(\"Hola\").len();\n\nIn this case, len will be 4, which means the vector storing the string\n\"Hola\" is 4 bytes long. Each of these letters takes 1 byte when encoded in\nUTFE-8. But what about the following line? (Note that this string begins\nwith the capital Cyrillic letter Ze, not the Arabic number 3.)\n\nlet len = String: :from(\"3apascteyite\").len();\n\nAsked how long the string is, you might say 12. However, Rust\u2019s answer\nis 24: that\u2019s the number of bytes it takes to encode \"3apascteyite\" in UTF-8,\nbecause each Unicode scalar value in that string takes 2 bytes of storage.\nTherefore, an index into the string\u2019s bytes will not always correlate to a valid\nUnicode scalar value. To demonstrate, consider this invalid Rust code:\n\nlet hello = \u201c3apasctsyite\";\nlet answer = &hello[o];\n\nWhat should the value of answer be? Should it be 3, the first letter?\nWhen encoded in UTF-8, the first byte of 3 is 208 and the second is 151,\n\nso answer should in fact be 208, but 208 is not a valid character on its own.\nReturning 208 is likely not what a user would want if they asked for the\nfirst letter of this string; however, that\u2019s the only data that Rust has at\nbyte index 0. Users generally don\u2019t want the byte value returned, even if\nthe string contains only Latin letters: if &\"hello\"[0] were valid code that\nreturned the byte value, it would return 104, not h. To avoid returning an\nunexpected value and causing bugs that might not be discovered imme-\ndiately, Rust doesn\u2019t compile this code at all and prevents misunderstand-\nings early in the development process.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 8.17,
                        "section_name": "Bytes and Scalar Values and Grapheme Clusters! Oh My!",
                        "section_path": "./screenshots-images-2/chapter_8/section_17",
                        "images": [
                            "./screenshots-images-2/chapter_8/section_17/0912d6bc-6447-480d-aba5-cd06f04842aa.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Bytes and Scalar Values and Grapheme Clusters! Oh My!\n\nAnother point about UTF-8 is that there are actually three relevant ways to\nlook at strings from Rust\u2019s perspective: as bytes, scalar values, and grapheme\nclusters (the closest thing to what we would call letters).\n\nIf we look at the Hindi word \u201cTH\u20ac@\u201d written in the Devanagari script,\nit is stored as a vector of u8 values that looks like this:\n\n(224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,\n224, 165, 135]\n\nThat\u2019s 18 bytes and is how computers ultimately store this data. If we\nlook at them as Unicode scalar values, which are what Rust\u2019s char type is,\nthose bytes look like this:\n\nThere are six char values here, but the fourth and sixth are not letters:\nthey\u2019re diacritics that don\u2019t make sense on their own. Finally, if we look at\nthem as grapheme clusters, we'd get what a person would call the four letters\nthat make up the Hindi word:\n\nca,\n\nRust provides different ways of interpreting the raw string data that\ncomputers store so that each program can choose the interpretation it\nneeds, no matter what human language the data is in.\n\nA final reason Rust doesn\u2019t allow us to index into a String to get a char-\nacter is that indexing operations are expected to always take constant time\n(O(1)). But it isn\u2019t possible to guarantee that performance with a String,\nbecause Rust would have to walk through the contents from the beginning\nto the index to determine how many valid characters there were.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 8.18,
                        "section_name": "Slicing Strings",
                        "section_path": "./screenshots-images-2/chapter_8/section_18",
                        "images": [
                            "./screenshots-images-2/chapter_8/section_18/3b9408a1-1d1b-414d-90cc-e0a2fdec3740.png",
                            "./screenshots-images-2/chapter_8/section_18/8dd5dee9-0b60-4a17-b1c5-7b0bc40f4b64.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Slicing Strings\nIndexing into a string is often a bad idea because it\u2019s not clear what the\n\nreturn type of the string-indexing operation should be: a byte value, a\ncharacter, a grapheme cluster, or a string slice. Therefore, Rust asks you\n\nto be more specific if you really need to use indices to create string slices.\nTo be more specific in your indexing and indicate that you want a string\nslice, rather than indexing using [] with a single number, you can use []\nwith a range to create a string slice containing particular bytes:\n\nlet hello = \"3apasctayiite\";\n\nlet s = &hello[o..4];\n\nHere, s will be a &str that contains the first 4 bytes of the string. Earlier,\nwe mentioned that each of these characters was 2 bytes, which means s will\nbe 3a.\n\nWhat would happen if we used &hello[0..1]? The answer: Rust would\npanic at runtime in the same way as if an invalid index were accessed in a\nvector:\n\nthread 'main' panicked at \u2018byte index 1 is not a char boundary; it is inside\n'3' (bytes 0..2) of \u201c3gpasctsyite\u2122', src/libcore/str/mod.rs:2188:4\n\nYou should use ranges to create string slices with caution, because\ndoing so can crash your program.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 8.19,
                        "section_name": "Methods for Iterating over Strings",
                        "section_path": "./screenshots-images-2/chapter_8/section_19",
                        "images": [
                            "./screenshots-images-2/chapter_8/section_19/296822cc-6503-4409-9a5c-51f2a0ba8b96.png",
                            "./screenshots-images-2/chapter_8/section_19/6c5d5cb1-9bb7-4419-83c2-e96b1a041937.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Methods for Iterating over Strings\nFortunately, you can access elements in a string in other ways.\n\nIf you need to perform operations on individual Unicode scalar values,\nthe best way to do so is to use the chars method. Calling chars on TR\"\nseparates out and returns six values of type char, and you can iterate over\nthe result to access each element:\n\nfor c in \"44a\" .chars() {\nprintln!(\"{}\", \u00a2);\n}\n\nThis code will print the following:\n\nans\n\n\u2018ay\u2019\n\nThe bytes method returns each raw byte, which might be appropriate\nfor your domain:\n\nfor b in \"AH\u00a5Ya\" .bytes() {\nprintln!(\"{}\", b);\n}\n\nThis code will print the 18 bytes that make up this String:\n\n224\n164\n// --snip--\n165\n135\n\nBut be sure to remember that valid Unicode scalar values may be made\nup of more than | byte.\n\nGetting grapheme clusters from strings is complex, so this functionality\nis not provided by the standard library. Crates are available on https://crates.io/\nif this is the functionality you need.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 8.2,
                        "section_name": "Strings Are Not So Simple",
                        "section_path": "./screenshots-images-2/chapter_8/section_20",
                        "images": [
                            "./screenshots-images-2/chapter_8/section_20/57094412-9de8-4396-83a5-7363a9bdc528.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Strings Are Not So Simple\n\nTo summarize, strings are complicated. Different programming languages\nmake different choices about how to present this complexity to the pro-\ngrammer. Rust has chosen to make the correct handling of String data the\ndefault behavior for all Rust programs, which means programmers have\nto put more thought into handling UTF-8 data up front. This trade-off\nexposes more of the complexity of strings than is apparent in other pro-\ngramming languages, but it prevents you from having to handle errors\ninvolving non-ASCII characters later in your development life cycle.\n\nLet\u2019s switch to something a bit less complex: hash maps!\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 8.21,
                        "section_name": "Storing Keys with Associated Values in Hash Maps",
                        "section_path": "./screenshots-images-2/chapter_8/section_21",
                        "images": [
                            "./screenshots-images-2/chapter_8/section_21/18f7e8ba-098a-484a-ae1b-2e21cf651793.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Storing Keys with Associated Values in Hash Maps\n\nThe last of our common collections is the hash map. The type HashMap<K, V>\nstores a mapping of keys of type K to values of type V. It does this via a hashing\nfunction, which determines how it places these keys and values into memory.\nMany programming languages support this kind of data structure, but they\noften use a different name, such as hash, map, object, hash table, dictionary,\nor associative array, just to name a few.\n\nHash maps are useful when you want to look up data not by using an\nindex, as you can with vectors, but by using a key that can be of any type.\nFor example, in a game, you could keep track of each team\u2019s score in a hash\nmap in which each key is a team\u2019s name and the values are each team\u2019s score.\nGiven a team name, you can retrieve its score.\n\nWe'll go over the basic API of hash maps in this section, but many\nmore goodies are hiding in the functions defined on HashMap<k, V> by the\nstandard library. As always, check the standard library documentation for\nmore information.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 8.22,
                        "section_name": "Geating a New Hash Map",
                        "section_path": "./screenshots-images-2/chapter_8/section_22",
                        "images": [
                            "./screenshots-images-2/chapter_8/section_22/11404cbb-a963-451e-be6c-8b47f92c920b.png",
                            "./screenshots-images-2/chapter_8/section_22/ae2c6816-c7b6-4bb0-9549-4535f2a51980.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Geating a New Hash Map\n\nYou can create an empty hash map with new and add elements with insert.\nIn Listing 8-20, we\u2019re keeping track of the scores of two teams whose names\n\nare Blue and Yellow. The Blue team starts with 10 points, and the Yellow\nteam starts with 50.\n\nuse std::collections: :HashMap;\nlet mut scores = HashMap: :new();\n\nscores. insert(String::from(\"Blue\"), 10);\nscores. insert (String: :from(\"Yellow\"), 50);\n\nListing 8-20: Creating a new hash map and inserting some keys and values\n\nNote that we need to first use the HashMap from the collections portion of\nthe standard library. Of our three common collections, this one is the least\noften used, so it's not included in the features brought into scope automati-\ncally in the prelude. Hash maps also have less support from the standard\nlibrary; there\u2019s no built-in macro to construct them, for example.\n\nJust like vectors, hash maps store their data on the heap. This HashMap\nhas keys of type String and values of type i32. Like vectors, hash maps are\nhomogeneous: all of the keys must have the same type, and all of the values\nmust have the same type.\n\nAnother way of constructing a hash map is by using the collect method\non a vector of tuples, where each tuple consists of a key and its value. The\ncollect method gathers data into a number of collection types, including\nHashMap. For example, if we had the team names and initial scores in two sep-\narate vectors, we could use the zip method to create a vector of tuples where\n\"Blue\" is paired with 10, and so forth. Then we could use the collect method\nto turn that vector of tuples into a hash map. as shown in Listing 8-21.\n\nuse std::collections: :HashMap;\n\nlet teams = vec![String::from(\"Blue\"), String::from(\"Yellow\")];\nlet initial_scores = vec![10, 50];\n\nlet scores: HashMap<_, _> = teams.iter().zip(initial_scores.iter()).collect();\n\nListing 8-21: Creating a hash map from a list of teams and a list of scores\n\nThe type annotation HashMap<_, _> is needed here because it\u2019s possible\nto collect into many different data structures and Rust doesn\u2019t know which\nyou want unless you specify. For the parameters for the key and value types,\nhowever, we use underscores, and Rust can infer the types that the hash\nmap contains based on the types of the data in the vectors.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 8.23,
                        "section_name": "Hash Maps and Ownership",
                        "section_path": "./screenshots-images-2/chapter_8/section_23",
                        "images": [
                            "./screenshots-images-2/chapter_8/section_23/b42895c2-e837-48fe-9b43-343dfdea7d10.png",
                            "./screenshots-images-2/chapter_8/section_23/3beedb8a-8a59-471d-8c11-d8d9feccb2d1.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Hash Maps and Ownership\n\nFor types that implement the Copy trait, such as i32, the values are copied\ninto the hash map. For owned values such as String, the values will be\nmoved and the hash map will be the owner of those values, as demon-\nstrated in Listing 8-22.\n\nuse std::collections: :HashMap;\n\nlet field_name = String::from(\"Favorite color\");\nlet field_value = String: :from(\"Blue\");\n\nlet mut map = HashMap: :new();\n\nmap.insert(field_name, field_value) ;\n\n// field_name and field_value are invalid at this point, try using them and\n// see what compiler error you get!\n\nListing 8-22: Showing that keys and values are owned by the hash map once they're\ninserted\n\nWe aren't able to use the variables field_name and field_value after\nthey've been moved into the hash map with the call to insert.\n\nIf we insert references to values into the hash map, the values won't be\nmoved into the hash map. The values that the references point to must\nbe valid for at least as long as the hash map is valid. We'll talk more about\nthese issues in \u201cValidating References with Lifetimes\u201d on page 192.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 8.24,
                        "section_name": "Accessing Valves in a Hash Map",
                        "section_path": "./screenshots-images-2/chapter_8/section_24",
                        "images": [
                            "./screenshots-images-2/chapter_8/section_24/279aeb09-af6f-406e-8123-2c06d25469d3.png",
                            "./screenshots-images-2/chapter_8/section_24/39af73ca-4064-4591-92ed-6a776aecca93.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Accessing Valves in a Hash Map\nWe can get a value out of the hash map by providing its key to the get\n\nmethod, as shown in Listing 8-23.\n\nuse std::collections: :HashMap;\nlet mut scores = HashMap: :new();\n\nscores. insert (String: :from(\"Blue\"), 10);\nscores. insert (String: :from(\"Yellow\"), 50);\n\nlet team_name = String::from(\"Blue\") ;\nlet score = scores.get(&team_name) ;\n\nListing 8-23: Accessing the score for the Blue team stored in the hash map\n\nHere, score will have the value that\u2019s associated with the Blue team, and\nthe result will be Some(&10). The result is wrapped in Some because get returns\nan Option<&V>; if there\u2019s no value for that key in the hash map, get will return\nNone. The program will need to handle the Option in one of the ways that we\ncovered in Chapter 6.\n\nWe can iterate over each key/value pair in a hash map in a similar man-\nner as we do with vectors, using a for loop:\n\nuse std::collections: :HashMap;\nlet mut scores = HashMap: :new();\n\nscores. insert (String: :from(\"Blue\"), 10);\nscores. insert (String: :from(\"Yellow\"), 50);\n\nfor (key, value) in &scores {\nprintln!(\"{}: {}\", key, value);\nThis code will print each pair in an arbitrary order:\n\nYellow: 50\nBlue: 10\n\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 8.25,
                        "section_name": "Updating a Hash Map",
                        "section_path": "./screenshots-images-2/chapter_8/section_25",
                        "images": [
                            "./screenshots-images-2/chapter_8/section_25/3f436511-cfb9-4e46-a901-f361541a532f.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Updating a Hash Map\n\nAlthough the number of keys and values is growable, each key can only have\none value associated with it at a time. When you want to change the data in\na hash map, you have to decide how to handle the case when a key already\nhas a value assigned. You could replace the old value with the new value,\ncompletely disregarding the old value. You could keep the old value and\nignore the new value, only adding the new value if the key doesn\u2019t already\nhave a value. Or you could combine the old value and the new value. Let\u2019s\nlook at how to do each of these!\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 8.26,
                        "section_name": "Overwriting a Value",
                        "section_path": "./screenshots-images-2/chapter_8/section_26",
                        "images": [
                            "./screenshots-images-2/chapter_8/section_26/5c6ec398-28c2-405e-88ef-76aa43ec36f0.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Overwriting a Value\n\nIf we insert a key and a value into a hash map and then insert that same key\nwith a different value, the value associated with that key will be replaced.\nEven though the code in Listing 8-24 calls insert twice, the hash map will\nonly contain one key/value pair because we're inserting the value for the\nBlue team\u2019s key both times.\n\nuse std::collections: :HashMap;\nlet mut scores = HashMap: :new();\n\nscores. insert (String: :from(\"Blue\"), 10);\nscores. insert (String: :from(\"Blue\"), 25);\n\nprintln!(\"{:?}\", scores);\n\nListing 8-24: Replacing a value stored with a particular key\n\nThis code will print {\"Blue\": 25}. The original value of 10 has been\noverwritten.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 8.27,
                        "section_name": "Only Inserting a Value If the Key Has No Value",
                        "section_path": "./screenshots-images-2/chapter_8/section_27",
                        "images": [
                            "./screenshots-images-2/chapter_8/section_27/611eee42-079a-4759-8b95-71fe0a9b5b69.png",
                            "./screenshots-images-2/chapter_8/section_27/874eb9b5-daeb-4eeb-b0cf-13b4cffe251d.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Only Inserting a Value If the Key Has No Value\n\nIt\u2019s common to check whether a particular key has a value and, if it doesn\u2019t,\ninsert a value for it. Hash maps have a special API for this called entry that\ntakes the key you want to check as a parameter. The return value of the entry\nmethod is an enum called Entry that represents a value that might or might\nnot exist. Let\u2019s say we want to check whether the key for the Yellow team has\na value associated with it. If it doesn\u2019t, we want to insert the value 50, and the\nsame for the Blue team. Using the entry API, the code looks like Listing 8-25.\n\nuse std::collections: :HashMap;\n\nlet mut scores = HashMap: :new();\nscores. insert (String: :from(\"Blue\"), 10);\n\nscores.entry(String::from(\"Yellow\")).or_insert(50);\nscores.entry (String: :from(\"Blue\")).or_insert(50);\n\nprintln!(\"{:?}\", scores);\n\nListing 8-25: Using the entry method to only insert if the key does not already have a value\n\nThe or_insert method on Entry is defined to return a mutable reference\nto the value for the corresponding Entry key if that key exists, and if not,\ninserts the parameter as the new value for this key and returns a mutable\nreference to the new value. This technique is much cleaner than writing the\nlogic ourselves and, in addition, plays more nicely with the borrow checker.\n\nRunning the code in Listing 8-25 will print {\"Yellow\": 50, \"Blue\": 10}.\nThe first call to entry will insert the key for the Yellow team with the value\n50 because the Yellow team doesn\u2019t have a value already. The second call to\n\nentry will not change the hash map because the Blue team already has the\nvalue 10.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 8.28,
                        "section_name": "Updating a Value Based on the Old Value",
                        "section_path": "./screenshots-images-2/chapter_8/section_28",
                        "images": [
                            "./screenshots-images-2/chapter_8/section_28/8661534b-be8f-4ffb-a43f-904bf44931b6.png",
                            "./screenshots-images-2/chapter_8/section_28/87265c82-4e3f-4cc0-971b-2e0ed9b1b3d8.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Updating a Value Based on the Old Value\n\nAnother common use case for hash maps is to look up a key\u2019s value and\nthen update it based on the old value. For instance, Listing 8-26 shows code\nthat counts how many times each word appears in some text. We use a hash\nmap with the words as keys and increment the value to keep track of how\nmany times we've seen that word. If it\u2019s the first time we've seen a word,\nwe'll first insert the value 0.\n\nuse std::collections: :HashMap;\nlet text = \"hello world wonderful world\";\nlet mut map = HashMap: :new();\nfor word in text.split_whitespace() {\nlet count = map.entry(word).or_insert(0);\n*count += 1;\n}\nprintln!(\"{:?}\", map);\nListing 8-26: Counting occurrences of words using a hash map that stores words and counts\n\nThis code will print {\"world\": 2, \"hello\": 1, \"wonderful\": 1}. The or_insert\nmethod actually returns a mutable reference (&mut V) to the value for this\nkey. Here we store that mutable reference in the count variable, so in order to\n\nassign to that value, we must first dereference count using the asterisk (*). The\nmutable reference goes out of scope at the end of the for loop, so all of these\nchanges are safe and allowed by the borrowing rules.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 8.29,
                        "section_name": "Hashing Functions",
                        "section_path": "./screenshots-images-2/chapter_8/section_29",
                        "images": [
                            "./screenshots-images-2/chapter_8/section_29/9f17e9ef-7aad-4fd4-ad1a-f9004c1b7c76.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Hashing Functions\n\nBy default, HashMap uses a cryptographically strong hashing function that can\nprovide resistance to Denial of Service (DoS) attacks. This is not the fastest\nhashing algorithm available, but the trade-off for better security that comes\nwith the drop in performance is worth it. If you profile your code and find\nthat the default hash function is too slow for your purposes, you can switch\nto another function by specifying a different hasher. A hasher is a type that\nimplements the BuildHasher trait. We'll talk about traits and how to imple-\nment them in Chapter 10. You don\u2019t necessarily have to implement your own\nhasher from scratch; Attps://crates.io/ has libraries shared by other Rust users\nthat provide hashers implementing many common hashing algorithms.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 8.3,
                        "section_name": "Summary",
                        "section_path": "./screenshots-images-2/chapter_8/section_30",
                        "images": [
                            "./screenshots-images-2/chapter_8/section_30/75e746eb-88ea-4ce2-a10f-7ec07f726b71.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Summary\n\nVectors, strings, and hash maps will provide a large amount of functional-\nity necessary in programs when you need to store, access, and modify data.\nHere are some exercises you should now be equipped to solve:\n\ne Given a list of integers, use a vector and return the mean (the average\nvalue), median (when sorted, the value in the middle position), and\nmode (the value that occurs most often; a hash map will be helpful\nhere) of the list.\n\ne Convert strings to pig latin. The first consonant of each word is moved\nto the end of the word and \u201cay\u201d is added, so \u201cfirst\u201d becomes \u201cirst-fay.\u201d\nWords that start with a vowel have \u201chay\u201d added to the end instead\n(\u201capple\u201d becomes \u201capple-hay\u201d). Keep in mind the details about UTF-8\nencoding!\n\ne Using a hash map and vectors, create a text interface to allow a user to\nadd employee names to a department in a company. For example, \u201cAdd\nSally to Engineering\u201d or \u201cAdd Amir to Sales.\u201d Then let the user retrieve\na list of all people in a department or all people in the company by\ndepartment, sorted alphabetically.\n\nThe standard library API documentation describes methods that vectors,\nstrings, and hash maps have that will be helpful for these exercises!\n\nWe're getting into more complex programs in which operations can\nfail, so, it\u2019s a perfect time to discuss error handling. We'll do that next!\n",
                        "extracted-code": ""
                    }
                ]
            },
            {
                "chapter_id": 9,
                "chapter_name": "ERROR HANDLING",
                "chapter_path": "./screenshots-images-2/chapter_9",
                "sections": [
                    {
                        "section_id": 9.1,
                        "section_name": "ERROR HANDLING",
                        "section_path": "./screenshots-images-2/chapter_9/section_1",
                        "images": [
                            "./screenshots-images-2/chapter_9/section_1/30f8607e-f67d-4b5d-82e0-ddadb0c590c2.png",
                            "./screenshots-images-2/chapter_9/section_1/aa4b47f9-9a2d-4b29-ad40-20844fcd21bf.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Rust\u2019s commitment to reliability extends to\nerror handling. Errors are a fact of life in\n\nsoftware, so Rust has a number of features\nfor handling situations in which something goes\n\nwrong. In many cases, Rust requires you to acknowl-\nedge the possibility of an error and take some action\nbefore your code will compile. This requirement\nmakes your program more robust by ensuring that\nyou'll discover errors and handle them appropriately\nbefore you've deployed your code to production!\n\nRust groups errors into two major categories: recoverable and unrecoverable\nerrors. For a recoverable error, such as a file not found error, it\u2019s reasonable\nto report the problem to the user and retry the operation. Unrecoverable\nerrors are always symptoms of bugs, like trying to access a location beyond\nthe end of an array.\n\nMost languages don\u2019t distinguish between these two kinds of errors and\nhandle both in the same way, using mechanisms such as exceptions. Rust\ndoesn\u2019t have exceptions. Instead, it has the type Result<T, E> for recoverable\nerrors and the panic! macro that stops execution when the program encoun-\nters an unrecoverable error. This chapter covers calling panic! first and then\ntalks about returning Result<T, E> values. Additionally, we'll explore consid-\nerations when deciding whether to try to recover from an error or to stop\nexecution.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 9.2,
                        "section_name": "Unrecoverable Errors with panic!",
                        "section_path": "./screenshots-images-2/chapter_9/section_2",
                        "images": [
                            "./screenshots-images-2/chapter_9/section_2/7000e675-bdb5-445c-9a17-12def261b077.png",
                            "./screenshots-images-2/chapter_9/section_2/dd678b41-b740-4096-8373-d8b7e23126fe.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Unrecoverable Errors with panic!\n\nSometimes, bad things happen in your code, and there\u2019s nothing you can\ndo about it. In these cases, Rust has the panic! macro. When the panic!\nmacro executes, your program will print a failure message, unwind and\nclean up the stack, and then quit. This most commonly occurs when a bug\nof some kind has been detected and it\u2019s not clear to the programmer how\nto handle the error.\n\nUNWINDING THE STACK OR ABORTING\nIN RESPONSE TO A PANIC\n\nBy default, when a panic occurs, the program starts unwinding, which means\nRust walks back up the stack and cleans up the data from each function it\nencounters. But this walking back and cleanup is a lot of work. The alternative\nis to immediately abort, which ends the program without cleaning up. Memory\n\nthat the program was using will then need to be cleaned up by the operating\nsystem. If in your project you need to make the resulting binary as small as\npossible, you can switch from unwinding to aborting upon a panic by adding\npanic = \u2018abort\u2019 to the appropriate [profile] sections in your Cargo.tom! file.\nFor example, if you want to abort on panic in release mode, add this:\n\n(profile.release]\npanic = \u2018abort\u2019\n\nLet's try calling panic! in a simple program:\n\nsrc/main.rs fn main() {\npanic!(\"crash and burn\");\n}\n\nWhen you run the program, you'll see something like this:\n\n$ cargo run\nCompiling panic v0.1.0 (file:///projects/panic)\nFinished dev [unoptimized + debuginfo] target(s) in 0.25 secs\nRunning \u2018target/debug/panic'\n\nthread 'main' panicked at \u2018crash and burn', src/main.rs:2:5\nnote: Run with 'RUST_BACKTRACE=1' for a backtrace.\n\nThe call to panic! causes the error message contained in the last two\nlines. The first line shows our panic message and the place in our source\ncode where the panic occurred: sr\u00a2/main.rs:2:5 indicates that it\u2019s the second\nline, fifth character of our sre/main.rs file.\n\nIn this case, the line indicated is part of our code, and if we go to that\nline, we see the panic! macro call. In other cases, the panic! call might be in\ncode that our code calls, and the filename and line number reported by the\nerror message will be someone else\u2019s code where the panic! macro is called,\nnot the line of our code that eventually led to the panic! call. We can use\nthe backtrace of the functions the panic! call came from to figure out the\npart of our code that is causing the problem. We'll discuss what a backtrace\nis in more detail next.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 9.3,
                        "section_name": "Using a panic! Backtrace",
                        "section_path": "./screenshots-images-2/chapter_9/section_3",
                        "images": [
                            "./screenshots-images-2/chapter_9/section_3/b3669f54-59bf-4f95-bad1-fe905364399b.png",
                            "./screenshots-images-2/chapter_9/section_3/20d5f9a9-1bc6-4e87-81d4-cf516f3e4532.png",
                            "./screenshots-images-2/chapter_9/section_3/7271fefb-995d-4b89-9244-b2b76084f82d.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nUsing a panic! Backtrace\n\nLet\u2019s look at another example to see what it\u2019s like when a panic! call comes\nfrom a library because of a bug in our code instead of from our code calling\nthe macro directly. Listing 9-1 has some code that attempts to access an ele-\nment by index in a vector.\n\nfn main() {\nlet v = vec![1, 2, 3];\n\nv[99];\n}\n\nListing 9-1: Attempting to access an element beyond the end of a vector, which will cause\na call to panic!\n\nHere, we're attempting to access the 100th element of our vector (which\nis at index 99 because indexing starts at zero), but it has only 3 elements. In\nthis situation, Rust will panic. Using [] is supposed to return an element,\nbut if you pass an invalid index, there\u2019s no element that Rust could return\nhere that would be correct.\n\nOther languages, like C, will attempt to give you exactly what you asked\nfor in this situation, even though it isn\u2019t what you want: you'll get whatever\nis at the location in memory that would correspond to that element in the\nvector, even though the memory doesn\u2019t belong to the vector. This is called\na buffer overread and can lead to security vulnerabilities if an attacker is able\nto manipulate the index in such a way as to read data they shouldn't be\nallowed to that is stored after the array.\n\nTo protect your program from this sort of vulnerability, if you try to\nread an element at an index that doesn\u2019t exist, Rust will stop execution and\nrefuse to continue. Let\u2019s try it and see:\n\n$ cargo run\nCompiling panic v0.1.0 (file:///projects/panic)\n\nFinished dev [unoptimized + debuginfo] target(s) in 0.27 secs\n\nRunning \u2018target/debug/panic'\nthread \u2018main' panicked at \u2018index out of bounds: the len is 3 but the index is\n99', libcore/slice/mod.rs:2448:10\nnote: Run with \"RUST BACKTRACE=1' for a backtrace.\n\nThis error points at a file we didn\u2019t write, libcore/slice/mod.rs. That's the\nimplementation of slice in the Rust source code. The code that gets run\nwhen we use [] on our vector v is in libcore/slice/mod.rs, and that is where the\npanic! is actually happening.\n\nThe next note line tells us that we can set the RUST_BACKTRACE environ-\nment variable to get a backtrace of exactly what happened to cause the\nerror. A backtrace is a list of all the functions that have been called to get to\nthis point. Backtraces in Rust work as they do in other languages: the key\nto reading the backtrace is to start from the top and read until you see files\nyou wrote. That's the spot where the problem originated. The lines above\nthe lines mentioning your files are code that your code called; the lines\nbelow are code that called your code. These lines might include core Rust\ncode, standard library code, or crates that you're using. Let's try getting a\nbacktrace by setting the RUST_BACKTRACE environment variable to any value\nexcept 0. Listing 9-2 shows output similar to what you'll see.\n\n$ RUST_BACKTRACE=1 cargo run\nFinished dev [unoptimized + debuginfo] target(s) in 0.00s\n\nRunning \u201ctarget/debug/panic\u201d\n\nthread \u2018main' panicked at \u2018index out of bounds: the len is 3 but the index is 99', libcore/\nslice/mod.rs:2448:10\nstack backtrace:\n\n0:\n\n1:\n\n10:\n\nstd::sys::unix: :backtrace: : tracing: :imp::unwind_backtrace\nat libstd/sys/unix/backtrace/tracing/gcec_s.1rs:49\nstd::sys_common: : backtrace: :print\nat libstd/sys_common/backtrace.rs:71\nat libstd/sys_common/backtrace.rs:59\n\n: std::panicking: :default_hook::{{closure}}\n\nat libstd/panicking.rs:211\n\n: std::panicking: :default_hook\n\nat libstd/panicking.rs:227\n\n: <std::panicking::begin_panic: :PanicPayload<A> as core::panic: :BoxMeUp>::get\n\nat libstd/panicking.rs:476\n\n: std::panicking::continue_panic_fmt\n\nat libstd/panicking.rs:390\n\n: std::panicking: :try::do_call\n\nat libstd/panicking.rs:325\n\n: core::ptr::drop_in place\n\nat libcore/panicking.rs:77\n\n: core::ptr::drop_in_ place\n\nat libcore/panicking.rs:59\n\n: <usize as core::slice::SliceIndex<[T]>>:: index\n\nat libcore/slice/mod.rs:2448\ncore: :slice::<impl core::ops::index::Index<I> for [T]>::index\nat libcore/slice/mod.rs:2316\n\n11: <alloc::vec::Vec<T> as core: :ops::index::Index<I>>::index\nat liballoc/vec.rs:1653\n12: panic::main\nat src/main.rs:4\n13: std::rt::lang_start::{{closure}}\nat libstd/rt.rs:74\n14: std::panicking::try::do_call\nat libstd/rt.rs:59\nat libstd/panicking.rs:310\n15: macho_symbol_ search\nat libpanic_unwind/lib.rs:102\n16: std::alloc::default_alloc_error_hook\nat libstd/panicking.rs:289\nat libstd/panic.rs:392\nat libstd/rt.rs:58\n17: std::rt::lang_start\nat libstd/rt.rs:74\n18: panic::main\n\nListing 9-2: The backtrace generated by a call to panic! displayed when the environment variable\n\nRUST_BACKTRACE is set\n\nThat's a lot of output! The exact output you see might be different\ndepending on your operating system and Rust version. In order to get\nbacktraces with this information, debug symbols must be enabled. Debug\nsymbols are enabled by default when using cargo build or cargo run without\nthe --release flag, as we have here.\n\nIn the output in Listing 9-2, line 12 of the backtrace points to the\nline in our project that\u2019s causing the problem: line 4 of sr\u00a2/main.rs. If\nwe don\u2019t want our program to panic, the location pointed to by the first\nline mentioning a file we wrote is where we should start investigating. In\nListing 9-1, where we deliberately wrote code that would panic in order\nto demonstrate how to use backtraces, the way to fix the panic is to not\nrequest an element at index 99 from a vector that only contains 3 items.\nWhen your code panics in the future, you'll need to figure out what action\nthe code is taking with what values to cause the panic and what the code\nshould do instead.\n\nWe'll come back to panic! and when we should and should not use panic!\nto handle error conditions in \u201cTo panic! or Not to panic!\u201d on page 164. Next,\nwe'll look at how to recover from an error using Result.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 9.4,
                        "section_name": "Recoverable Errors with Result",
                        "section_path": "./screenshots-images-2/chapter_9/section_4",
                        "images": [
                            "./screenshots-images-2/chapter_9/section_4/a439aa9a-05d1-46cd-865c-7e09ab87c0f7.png",
                            "./screenshots-images-2/chapter_9/section_4/c1081ee8-0f4b-47a6-8cfd-32ecda3fc156.png",
                            "./screenshots-images-2/chapter_9/section_4/26d23d8c-a257-4ae8-9fdc-214770439303.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Recoverable Errors with Result\n\nMost errors aren't serious enough to require the program to stop entirely.\nSometimes, when a function fails, it\u2019s for a reason that you can easily interpret\nand respond to. For example, if you try to open a file and that operation fails\nbecause the file doesn\u2019t exist, you might want to create the file instead of ter-\nminating the process.\n\nsrc/main.rs\n\nRecall from \u201cHandling Potential Failure with the Result Type\u201d on\npage 17 that the Result enum is defined as having two variants, 0k and\nErr, as follows:\n\nenum Result<T, E> {\nOk(T),\nErr(E),\n\nThe T and E are generic type parameters: we'll discuss generics in more\ndetail in Chapter 10. What you need to know right now is that T represents\nthe type of the value that will be returned in a success case within the 0k\nvariant, and E represents the type of the error that will be returned in a\nfailure case within the Err variant. Because Result has these generic type\nparameters, we can use the Result type and the functions that the standard\nlibrary has defined on it in many different situations where the successful\nvalue and error value we want to return may differ.\n\nLet's call a function that returns a Result value because the function\ncould fail. In Listing 9-3 we try to open a file.\n\nuse std::fs::File;\n\nfn main() {\n\nlet f = File: :open(\"hello.txt\");\n}\n\nListing 9-3: Opening a file\n\nHow do we know File: :open returns a Result? We could look at the stan-\ndard library API documentation, or we could ask the compiler! If we give\nf a type annotation that we know is nota return type of the function and\nthen try to compile the code, the compiler will tell us that the types don\u2019t\nmatch. The error message will then tell us what the type of f is. Let\u2019s try it!\nWe know that the return type of File: :open isn\u2019t of type u32, so let\u2019s change\nthe let f statement to this:\n\nlet f: u32 = File::open(\"hello.txt\");\nAttempting to compile now gives us the following output:\n\nerror[E0308]: mismatched types\n--> src/main.rs:4:18\n|\n4| let f: u32 = File::open(\u201chello.txt\");\n| AARARAARARAARAARAABARAAR expected u32, found enum\n\u201cstd: :result: :Result\u201d\n|\n= note: expected type ~u32\u00b0\nfound type \u201cstd::result::Result<std::fs::File, std::io::Error>~\n\nsr\u00a2/main.rs\n\nThis tells us the return type of the File::open function is a Result<T, E>.\nThe generic parameter T has been filled in here with the type of the success\nvalue, std::fs::File, which is a file handle. The type of E used in the error\nvalue is std::io::Error.\n\nThis return type means the call to File: :open might succeed and return\na file handle that we can read from or write to. The function call also might\nfail: for example, the file might not exist, or we might not have permission to\naccess the file. The File: :open function needs to have a way to tell us whether\nit succeeded or failed and at the same time give us either the file handle or\nerror information. This information is exactly what the Result enum conveys.\n\nIn the case where File: :open succeeds, the value in the variable f will be\nan instance of 0k that contains a file handle. In the case where it fails, the\nvalue in f will be an instance of Err that contains more information about\nthe kind of error that happened.\n\nWe need to add to the code in Listing 9-3 to take different actions\ndepending on the value File: :open returns. Listing 9-4 shows one way to\nhandle the Result using a basic tool, the match expression that we discussed\nin Chapter 6.\n\nuse std::fs::File;\n\nfn main() {\nlet f = File::open(\"hello.txt\");\nlet f = match f {\nOk(file) => file,\nErr(error) => {\npanic!(\"Problem opening the file: {:?}\", error)\n,\nhs\n}\n\nListing 9-4: Using a match expression to handle the Result variants that might be returned\n\nNote that, like the Option enum, the Result enum and its variants have\nbeen brought into scope by the prelude, so we don\u2019t need to specify Result: :\nbefore the 0k and Err variants in the match arms.\n\nHere we tell Rust that when the result is 0k, return the inner file value\nout of the 0k variant, and we then assign that file handle value to the variable\nf. After the match, we can use the file handle for reading or writing.\n\nThe other arm of the match handles the case where we get an Err value\nfrom File: :open. In this example, we've chosen to call the panic! macro. If\nthere\u2019s no file named hello.txt in our current directory and we run this code,\nwe'll see the following output from the panic! macro:\n\nthread 'main' panicked at \u2018Problem opening the file: Error { repr: Os { code:\n2, message: \"No such file or directory\" } }', src/main.rs:9:12\n\nAs usual, this output tells us exactly what has gone wrong.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 9.5,
                        "section_name": "Matching on Different Errors",
                        "section_path": "./screenshots-images-2/chapter_9/section_5",
                        "images": [
                            "./screenshots-images-2/chapter_9/section_5/cff1f77d-e156-408b-a4c6-2c27090f8d8e.png",
                            "./screenshots-images-2/chapter_9/section_5/5c576a5d-8c6b-471f-b0e1-299007350097.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nMatching on Different Errors\n\nThe code in Listing 9-4 will panic! no matter why File: :open failed. What we\nwant to do instead is take different actions for different failure reasons: if\nFile: :open failed because the file doesn\u2019t exist, we want to create the file and\nreturn the handle to the new file. If File: :open failed for any other reason\u2014\nfor example, because we didn\u2019t have permission to open the file\u2014we still\nwant the code to panic! in the same way as it did in Listing 9-4. Look\n\nat Listing 9-5, which adds an inner match expression.\n\nuse std::fs::File;\nuse std::io::ErrorKind;\n\nfn main() {\n\nlet f = File::open(\"hello. txt\");\n\nlet f = match f {\nOk(file) => file,\nErr(error) => match error.kind() {\nErrorKind: :NotFound => match File::create(\"hello.txt\") {\nOk(fc) => fe,\nErr(e) => panic!(\"Problem creating the file: {:?}\", e),\n\nother_error => panic! (\"Problem opening the file: {:?}\", other_error),\nhb\nhs\n}\n\nListing 9-5: Handling different kinds of errors in different ways\n\nThe type of the value that File: :open returns inside the Err variant is\nio: :Error, which is a struct provided by the standard library. This struct\nhas a method kind that we can call to get an io::ErrorKind value. The enum\nio: :ErrorKind is provided by the standard library and has variants represent-\ning the different kinds of errors that might result from an io operation. The\nvariant we want to use is ErrorKind::NotFound, which indicates the file we\u2019re\ntrying to open doesn\u2019t exist yet. So we match on f, but we also have an inner\nmatch on error.kind().\n\nThe condition we want to check in the inner match is whether the value\nreturned by error.kind() is the NotFound variant of the ErrorKind enum. If it is,\nwe try to create the file with File: :create.\n\nHowever, because File::create could also fail, we need a second arm in\nthe inner match expression. When the file can\u2019t be created, a different error\nmessage is printed. The second arm of the outer match stays the same, so the\nprogram panics on any error besides the missing file error.\n\nThat\u2019s a lot of match! The match expression is very useful but also very\nmuch a primitive. In Chapter 13, you'll learn about closures; the Result<T, E>\n\nsrc/main.rs\n\ntype has many methods that accept a closure and are implemented using\nmatch expressions. Using those methods will make your code more concise.\nA more seasoned Rustacean might write this code instead of Listing 9-5:\n\nuse std::fs::File;\nuse std::io::ErrorKind;\n\nfn main() {\nlet f = File::open(\"hello.txt\").unwrap_or_else({error| {\nif error.kind() == ErrorKind::NotFound {\nFile: :create(\"hello.txt\").unwrap_or_else(|error| {\npanic!(\"Problem creating the file: {:?}\", error);\n})\n\n} else {\npanic! (\"Problem opening the file: {:?}\", error);\n\nns\n\nAlthough this code has the same behavior as Listing 9-5, it doesn\u2019t con-\ntain any match expressions and is cleaner to read. Come back to this example\nafter you've read Chapter 13, and look up the unwrap_or_else method in the\nstandard library documentation. Many more of these methods can clean up\nhuge nested match expressions when you're dealing with errors.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 9.6,
                        "section_name": "Shortcuts for Panic on Error: unwrap and expect",
                        "section_path": "./screenshots-images-2/chapter_9/section_6",
                        "images": [
                            "./screenshots-images-2/chapter_9/section_6/7c02e410-2bde-4839-b071-2dc9b94f3600.png",
                            "./screenshots-images-2/chapter_9/section_6/92540309-d66e-4a26-8bed-1fe369f95048.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nShortcuts for Panic on Error: unwrap and expect\n\nUsing match works well enough, but it can be a bit verbose and doesn\u2019t always\ncommunicate intent well. The Result<T, \u00a3> type has many helper methods\ndefined on it to do various tasks. One of those methods, called unwrap, is a\nshortcut method that is implemented just like the match expression we wrote\nin Listing 9-4. If the Result value is the 0k variant, unwrap will return the value\ninside the Ok. If the Result is the Err variant, unwrap will call the panic! macro\nfor us. Here is an example of unwrap in action:\n\nuse std::fs::File;\n\nfn main() {\n\nlet f = File::open(\"hello.txt\").unwrap();\n}\n\nIf we run this code without a hello.txt file, we'll see an error message\nfrom the panic! call that the unwrap method makes:\n\nthread 'main' panicked at \u2018called 'Result::unwrap()' on an \u2018Err\u2019 value: Error\n{ repr: Os { code: 2, message: \"No such file or directory\" } }', /src/libcore/\nresult.rs:906:4\n\n\nsrc/main.rs\n\nAnother method, expect, which is similar to unwrap, lets us also choose\nthe panic! error message. Using expect instead of unwrap and providing good\nerror messages Can convey your intent and make tracking down the source\nofa panic easier. The syntax of expect looks like this:\n\nuse std::fs::File;\n\nfn main() {\nlet f = File::open(\"hello.txt\").expect(\"Failed to open hello. txt\");\n}\n\nWe use expect in the same way as unwrap: to return the file handle or call\nthe panic! macro. The error message used by expect in its call to panic! will\nbe the parameter that we pass to expect, rather than the default panic! mes-\nsage that unwrap uses. Here\u2019s what it looks like:\n\nthread 'main' panicked at \u2018Failed to open hello.txt: Error { repr: Os { code:\n2, message: \"No such file or directory\" } }', /src/libcore/result.rs:906:4\n\nBecause this error message starts with the text we specified, Failed to\nopen hello. txt, it will be easier to find where in the code this error message\nis coming from. If we use unwrap in multiple places, it can take more time to\nfigure out exactly which unwrap is causing the panic because all unwrap calls\nthat panic print the same message.\n\n- oe\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 9.7,
                        "section_name": "Propagating Errors",
                        "section_path": "./screenshots-images-2/chapter_9/section_7",
                        "images": [
                            "./screenshots-images-2/chapter_9/section_7/103a1263-48fa-4603-b83f-7fa7bb12e4b2.png",
                            "./screenshots-images-2/chapter_9/section_7/484f1dae-e01a-4e92-a6af-6a26dac6b219.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nPropagating Errors\n\nWhen you're writing a function whose implementation calls something\n\nthat might fail, instead of handling the error within this function, you can\n\nreturn the error to the calling code so that it can decide what to do. This is\n\nknown as propagating the error and gives more control to the calling code,\n\nwhere there might be more information or logic that dictates how the error\n\nshould be handled than what you have available in the context of your code.\nFor example, Listing 9-6 shows a function that reads a username from a\n\nfile. If the file doesn\u2019t exist or can\u2019t be read, this function will return those\n\nerrors to the code that called this function.\n\nfn read_username_from_file() -> Result<String, io::Error>\u00ae {\n\u00a9 let f = File::open(\"hello.txt\");\n\n\u00a9 let mut f = match f {\nOk(file) => file,\nErr(e) => return Err(e),\n\n3\n\n\u00a9 let mut s = String: :new();\n\n\u00a9 match f.read_to_string(&mut s)\u00ae {\nOk(_) => Ok(s)@,\nErr(e) => Err(e)\u00ae,\n\n}\n\nListing 9-6: A function that returns errors to the calling code using match\n\nThis function can be written in a much shorter way, but we\u2019re going to\nstart by doing a lot of it manually in order to explore error handling; at the\nend, we'll show the shorter way. Let\u2019s look at the return type of the function\nfirst: Result<String, io::Error> \u00ae. This means the function is returning a\nvalue of the type Result<T, E> where the generic parameter T has been filled\nin with the concrete type String and the generic type E has been filled in\nwith the concrete type io: :Error. If this function succeeds without any prob-\nlems, the code that calls this function will receive an 0k value that holds a\nString\u2014the username that this function read from the file @. If this func-\ntion encounters any problems, the code that calls this function will receive\nan Err value that holds an instance of io::Error that contains more informa-\ntion about what the problems were. We chose io: :Error as the return type\nof this function because that happens to be the type of the error value\nreturned from both of the operations we're calling in this function's body\nthat might fail: the File::open function and the read_to_string method.\n\nThe body of the function starts by calling the File::open function \u00ae.\nThen we handle the Result value returned with a match \u00a9 similar to the match\nin Listing 9-4, only instead of calling panic! in the Err case, we return early\nfrom this function and pass the error value from File: :open back to the call-\ning code as this function\u2019s error value \u00ae. If File: :open succeeds, we store the\nfile handle in the variable f and continue.\n\nThen we create a new String in variable s @ and call the read_to_string\nmethod on the file handle in f to read the contents of the file into s \u00a9.\nThe read_to_string method also returns a Result because it might fail,\neven though File: :open succeeded. So we need another match to handle\nthat Result: if read_to_string succeeds, then our function has succeeded,\nand we return the username from the file that\u2019s now in s wrapped in an\nOk @. If read_to_string fails, we return the error value in the same way that\nwe returned the error value in the match that handled the return value of\nFile: :open \u00ae. However, we don\u2019t need to explicitly say return, because this is\nthe last expression in the function.\n\nThe code that calls this code will then handle getting either an 0k value\nthat contains a username or an Err value that contains an io: :Error. We don\u2019t\nknow what the calling code will do with those values. If the calling code\ngets an Err value, it could call panic! and crash the program, use a default\nusername, or look up the username from somewhere other than a file, for\nexample. We don\u2019t have enough information on what the calling code is\nactually trying to do, so we propagate all the success or error information\nupward for it to handle appropriately.\n\nThis pattern of propagating errors is so common in Rust that Rust pro-\nvides the question mark operator ? to make this easier.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 9.8,
                        "section_name": "A Shortcut for Propagating Errors: the ? Operator",
                        "section_path": "./screenshots-images-2/chapter_9/section_8",
                        "images": [
                            "./screenshots-images-2/chapter_9/section_8/5f3e2e1d-1c2a-4ca2-9e26-78d578f40339.png",
                            "./screenshots-images-2/chapter_9/section_8/f4e4e5c9-5707-4798-ad85-9d66aa5af2b5.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "stc/main.rs\n\nsrc/main.rs\n\nA Shortcut for Propagating Errors: the ? Operator\n\nListing 9-7 shows an implementation of read_username_from_file that has the\nsame functionality as it had in Listing 9-6, but this implementation uses\nthe ? operator.\n\nuse std::io;\nuse std::io::Read;\nuse std::fs::File;\n\nfn read_username_from_file() -> Result<String, io::Error> {\nlet mut f = File::open(\"hello.txt\")?;\nlet mut s = String: :new();\nf.read_to_string(&mut s)?;\nOk(s)\n}\n\nListing 9-7: A function that returns errors to the calling code using the ? operator\n\nThe ? placed after a Result value is defined to work in almost the same\nway as the match expressions we defined to handle the Result values in\nListing 9-6. If the value of the Result is an Ok, the value inside the 0k will\nget returned from this expression, and the program will continue. If the\nvalue is an Err, the Err will be returned from the whole function as if we\nhad used the return keyword so the error value gets propagated to the call-\ning code.\n\nThere is a difference between what the match expression from Listing 9-6\nand the ? operator do: error values that have the ? operator called on them\ngo through the from function, defined in the From trait in the standard\nlibrary, which is used to convert errors from one type into another. When\nthe ? operator calls the from function, the error type received is converted\ninto the error type defined in the return type of the current function. This\nis useful when a function returns one error type to represent all the ways a\nfunction might fail, even if parts might fail for many different reasons. As\nlong as each error type implements the from function to define how to convert\nitself to the returned error type, the ? operator takes care of the conversion\nautomatically,\n\nIn the context of Listing 9-7, the ? at the end of the File: :open call\nwill return the value inside an Ok to the variable f. If an error occurs, the\n? operator will return early out of the whole function and give any Err\nvalue to the calling code. The same thing applies to the ? at the end of the\nread_to_string call.\n\nThe ? operator eliminates a lot of boilerplate and makes this function's\nimplementation simpler. We could even shorten this code further by chain-\ning method calls immediately after the ?, as shown in Listing 9-8.\n\nuse std::io;\nuse std::io::Read;\nuse std::fs::File;\n\nfn read_username_from_file() -> Result<String, io::Error> {\n\nsr/main.rs\n\nlet mut s = String: :new();\nFile: :open(\"hello.txt\")?.read_to_string(&mut s)?;\n\nOk(s)\n}\n\nListing 9-8: Chaining method calls after the ? operator\n\nWe've moved the creation of the new String in s to the beginning of the\nfunction; that part hasn\u2019t changed. Instead of creating a variable f, we\u2019ve\nchained the call to read_to_string directly onto the result of File: :open(\"hello\n.txt\")?. We still have a ? at the end of the read_to_string call, and we still\nreturn an Ok value containing the username in s when both File: :open and\nread_to_string succeed rather than returning errors. The functionality is\nagain the same as in Listing 9-6 and Listing 9-7; this is just a different, more\nergonomic way to write it.\n\nSpeaking of different ways to write this function, Listing 9-9 shows that\nthere\u2019s a way to make this even shorter.\n\nuse std::io;\nuse std::fs;\n\nfn read_username_from_file() -> Result<String, io::Error> {\nfs::read_to_string(\u201chello.txt\u201d)\n}\n\nListing 9-9: Using fs::xead_to_string instead of opening and then reading the file\n\nReading a file into a string is a fairly common operation, so Rust provides\nthe convenient fs: :read_to_string function that opens the file, creates a new\nString, reads the contents of the file, puts the contents into that String, and\nreturns it. Of course, using fs::read_to_string doesn\u2019t give us the opportunity\nto explain all the error handling, so we did it the longer way first.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 9.9,
                        "section_name": "The ? Operator Can Only Be Used in Functions That Return Result",
                        "section_path": "./screenshots-images-2/chapter_9/section_9",
                        "images": [
                            "./screenshots-images-2/chapter_9/section_9/990ab8a8-6e65-4fdb-9332-fe8762d3f8f0.png",
                            "./screenshots-images-2/chapter_9/section_9/c74053f5-7884-4b0f-a8d7-1da448ef2938.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "The ? Operator Can Only Be Used in Functions That Return Result\n\nThe ? operator can only be used in functions that have a return type of\nResult, because it is defined to work in the same way as the match expression\nwe defined in Listing 9-6. The part of the match that requires a return type of\nResult is return Err(e), so the return type of the function must be a Result to\nbe compatible with this return.\n\nLet's look at what happens if we use the ? operator in the main function,\nwhich you'll recall has a return type of ():\n\nuse std::fs::File;\n\nfn main() {\nlet f = File::open(\"hello.txt\")?;\n}\n\nWhen we compile this code, we get the following error message:\n\nerror[E0277]: the ~?\u00b0 operator can only be used in a function that returns\n\u201cResult\u201d or \u201cOption\u201d (or another type that implements ~std::ops::Try~)\n--> src/main.rs:4:13\n|\n4| let f = File: :open(\u201chello.txt\u201d)?;\n| AAAARAAAAAAAAAARAAAAAAAN Cannot use the ~?\u201d operator in a\nfunction that returns ~()~\n|\n= help: the trait \u201cstd::ops::Try\u201d is not implemented for ~()\nnote: required by ~std::ops::Try::from_error\u2122\n\nThis error points out that we\u2019re only allowed to use the ? operator in\na function that returns Result<T, \u2014>. When you're writing code in a func-\ntion that doesn\u2019t return Result<T, E>, and you want to use ? when you call\nother functions that return Result<T, \u00a3>, you have two choices to fix this\nproblem. One technique is to change the return type of your function to\nbe Result<T, E> if you have no restrictions preventing that. The other tech-\nnique is to use a match or one of the Result<T, E> methods to handle the\nResult<T, E> in whatever way is appropriate.\n\nThe main function is special, and there are restrictions on what its return\ntype must be. One valid return type for main is (), and conveniently, another\nvalid return type is Result<T, \u00a3>, as shown here:\n\nuse std::error::Error;\nuse std::fs::File;\n\nfn main() -> Result<(), Box<dyn Error>> {\nlet f = File: :open(\u201chello.txt\u201d)?;\n\n0k(())\n\nThe Box<dyn Error> type is called a trait object, which we'll talk about in\n\u201cUsing Trait Objects That Allow for Values of Different Types\u201d on page 375.\nFor now, you can read Box<dyn Error> to mean \u201cany kind of error.\u201d Using ? ina\nmain function with this return type is allowed.\n\nNow that we've discussed the details of calling panic! or returning Result,\nlet\u2019s return to the topic of how to decide which is appropriate to use in which\ncases.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 9.1,
                        "section_name": "To panic! or Not to panic!",
                        "section_path": "./screenshots-images-2/chapter_9/section_10",
                        "images": [
                            "./screenshots-images-2/chapter_9/section_10/82319443-c22d-4bbb-bcba-248fbbd1d207.png",
                            "./screenshots-images-2/chapter_9/section_10/f8a19589-e56e-44d4-b8c8-635b67e6cf33.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "To panic! or Not to panic!\n\nSo how do you decide when you should call panic! and when you should\nreturn Result? When code panics, there\u2019s no way to recover. You could call\npanic! for any error situation, whether there's a possible way to recover or\nnot, but then you\u2019re making the decision on behalf of the code calling your\ncode that a situation is unrecoverable. When you choose to return a Result\nvalue, you give the calling code options rather than making the decision\n\nfor it. The calling code could choose to attempt to recover in a way that\u2019s\nappropriate for its situation, or it could decide that an Err value in this case\nis unrecoverable, so it can call panic! and turn your recoverable error into\nan unrecoverable one. Therefore, returning Result is a good default choice\nwhen you're defining a function that might fail.\n\nIn rare situations, it\u2019s more appropriate to write code that panics\ninstead of returning a Result. Let\u2019s explore why it\u2019s appropriate to panic in\nexamples, prototype code, and tests. Then we'll discuss situations in which\nthe compiler can\u2019t tell that failure is impossible, but you as a human can.\nThe chapter will conclude with some general guidelines on how to decide\nwhether to panic in library code.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 9.11,
                        "section_name": "Examples, Prototype Code, and Tests",
                        "section_path": "./screenshots-images-2/chapter_9/section_11",
                        "images": [
                            "./screenshots-images-2/chapter_9/section_11/3f96b77f-c575-44cf-b5b8-a2680e429f09.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Examples, Prototype Code, and Tests\n\nWhen you're writing an example to illustrate some concept, having robust\nerror-handling code in the example as well can make the example less clear.\nIn examples, it\u2019s understood that a call to a method like unwrap that could\npanic is meant as a placeholder for the way you'd want your application to\nhandle errors, which can differ based on what the rest of your code is doing.\n\nSimilarly, the unwrap and expect methods are very handy when proto-\ntyping, before you're ready to decide how to handle errors. They leave\nclear markers in your code for when you're ready to make your program\nmore robust.\n\nIfa method call fails in a test, you'd want the whole test to fail, even if\nthat method isn\u2019t the functionality under test. Because panic! is how a test is\nmarked as a failure, calling unwrap or expect is exactly what should happen.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 9.12,
                        "section_name": "Cases in Which You Have More Information Than the Compiler",
                        "section_path": "./screenshots-images-2/chapter_9/section_12",
                        "images": [
                            "./screenshots-images-2/chapter_9/section_12/9783281f-891d-4e79-bc63-a5b7686484f4.png",
                            "./screenshots-images-2/chapter_9/section_12/c3d7c45f-66d7-4f21-9321-a44dfe5297be.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Cases in Which You Have More Information Than the Compiler\n\nIt would also be appropriate to call unwrap when you have some other logic\nthat ensures the Result will have an 0k value, but the logic isn\u2019t something\nthe compiler understands. You'll still have a Result value that you need to\nhandle: whatever operation you're calling still has the possibility of failing\nin general, even though it\u2019s logically impossible in your particular situation.\nIf you can ensure by manually inspecting the code that you'll never have an\nErr variant, it\u2019s perfectly acceptable to call unwrap. Here's an example:\n\nuse std::net::IpAddr;\n\nlet home: IpAddr = \"127.0.0.1\".parse().unwrap();\n\nWe're creating an IpAddr instance by parsing a hardcoded string. We\ncan see that 127.0.0.1 is a valid IP address, so it\u2019s acceptable to use unwrap\nhere. However, having a hardcoded, valid string doesn\u2019t change the return\ntype of the parse method: we still get a Result value, and the compiler will\nstill make us handle the Result as if the Err variant is a possibility because\nthe compiler isn\u2019t smart enough to see that this string is always a valid IP\n\naddress. If the IP address string came from a user rather than being hard-\ncoded into the program and therefore did have a possibility of failure, we'd\ndefinitely want to handle the Result in a more robust way instead.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 9.13,
                        "section_name": "Guidelines for Error Handling",
                        "section_path": "./screenshots-images-2/chapter_9/section_13",
                        "images": [
                            "./screenshots-images-2/chapter_9/section_13/f008432a-dcb9-4e2d-aacd-b99b801c2113.png",
                            "./screenshots-images-2/chapter_9/section_13/4001a29a-8eea-45b9-88f0-6656a4dea3f1.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Guidelines for Error Handling\n\nIt\u2019s advisable to have your code panic when it\u2019s possible that your code could\nend up in a bad state. In this context, a bad state is when some assumption,\nguarantee, contract, or invariant has been broken, such as when invalid\nvalues, contradictory values, or missing values are passed to your code\u2014plus\none or more of the following:\n\ne The bad state is not something that\u2019s expected to happen occasionally.\ne Your code after this point needs to rely on not being in this bad state.\ne  There\u2019s not a good way to encode this information in the types you use.\n\nIf someone calls your code and passes in values that don\u2019t make sense,\nthe best choice might be to call panic! and alert the person using your library\nto the bug in their code so they can fix it during development. Similarly,\npanic! is often appropriate if you're calling external code that is out of your\ncontrol and it returns an invalid state that you have no way of fixing.\n\nHowever, when failure is expected, it\u2019s more appropriate to return a\nResult than to make a panic! call. Examples include a parser being given mal-\nformed data or an HTTP request returning a status that indicates you have\nhit a rate limit. In these cases, returning a Result indicates that failure is an\nexpected possibility that the calling code must decide how to handle.\n\nWhen your code performs operations on values, your code should verify\nthe values are valid first and panic if the values aren't valid. This is mostly for\nsafety reasons: attempting to operate on invalid data can expose your code to\nvulnerabilities. This is the main reason the standard library will call panic! if\nyou attempt an out-of-bounds memory access: trying to access memory that\ndoesn\u2019t belong to the current data structure is a common security problem.\nFunctions often have contracts: their behavior is only guaranteed if the inputs\nmeet particular requirements. Panicking when the contract is violated makes\nsense because a contract violation always indicates a caller-side bug and it\u2019s\nnot a kind of error you want the calling code to have to explicitly handle. In\nfact, there\u2019s no reasonable way for calling code to recover; the calling pro-\ngrammers need to fix the code. Contracts for a function, especially when a\nviolation will cause a panic, should be explained in the API documentation\nfor the function.\n\nHowever, having lots of error checks in all of your functions would be\nverbose and annoying. Fortunately, you can use Rust\u2019s type system (and\nthus the type checking the compiler does) to do many of the checks for\nyou. If your function has a particular type as a parameter, you can proceed\nwith your code\u2019s logic knowing that the compiler has already ensured you\nhave a valid value. For example, if you have a type rather than an Option,\nyour program expects to have something rather than nothing. Your code then\ndoesn\u2019t have to handle two cases for the Some and None variants: it will only\n\nhave one case for definitely having a value. Code trying to pass nothing to\nyour function won't even compile, so your function doesn\u2019t have to check\nfor that case at runtime. Another example is using an unsigned integer type\nsuch as u32, which ensures the parameter is never negative.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 9.14,
                        "section_name": "Creating Custom Types for Validation",
                        "section_path": "./screenshots-images-2/chapter_9/section_14",
                        "images": [
                            "./screenshots-images-2/chapter_9/section_14/18417948-6846-4c0a-acfb-e06974cfb412.png",
                            "./screenshots-images-2/chapter_9/section_14/56ea7bc0-3510-44df-a6c0-5bd206368392.png",
                            "./screenshots-images-2/chapter_9/section_14/76cb510f-3cf2-4fad-a91a-40646289d66c.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Creating Custom Types for Validation\n\nLet\u2019s take the idea of using Rust\u2019s type system to ensure we have a valid\nvalue one step further and look at creating a custom type for validation.\nRecall the guessing game in Chapter 2 in which our code asked the user to\nguess a number between 1 and 100. We never validated that the user\u2019s guess\nwas between those numbers before checking it against our secret number;\nwe only validated that the guess was positive. In this case, the consequences\nwere not very dire: our output of \u201cToo high\u201d or \u201cToo low\u201d would still be cor-\nrect. But it would be a useful enhancement to guide the user toward valid\nguesses and have different behavior when a user guesses a number that's\nout of range versus when a user types, for example, letters instead.\n\nOne way to do this would be to parse the guess as an i32 instead of only\na u32 to allow potentially negative numbers, and then add a check for the\nnumber being in range, like so:\n\nloop {\n// --snip--\n\nlet guess: i32 = match guess.trim().parse() {\nOk(num) => num,\nErr(_) => continue,\n\nA\n\nif guess < 1 || guess > 100 {\nprintln!(\"The secret number will be between 1 and 100.\");\ncontinue;\n\n}\n\nmatch guess.cmp(&secret_number) {\n// ~-snip--\n\nThe if expression checks whether our value is out of range, tells the\nuser about the problem, and calls continue to start the next iteration of the\nloop and ask for another guess. After the if expression, we can proceed with\nthe comparisons between guess and the secret number knowing that guess is\nbetween 1 and 100.\n\nHowever, this is not an ideal solution: if it were absolutely critical that\nthe program only operated on values between 1 and 100, and it had many\nfunctions with this requirement, having a check like this in every function\nwould be tedious (and might impact performance).\n\nInstead, we can make a new type and put the validations in a function\nto create an instance of the type rather than repeating the validations every-\nwhere. That way, it\u2019s safe for functions to use the new type in their signatures\n\nand confidently use the values they receive. Listing 9-10 shows one way to\ndefine a Guess type that will only create an instance of Guess if the new function\nreceives a value between 1 and 100.\n\npub struct Guess {\nvalue: i32,\n}\n\nimpl Guess {\n\u00a9 pub fn new(value: 132) -> Guess {\n\u00a9 if value < 1 || value > 100 {\n\u00a9 panic!(\"Guess value must be between 1 and 100, got {}.\", value);\n\n}\n\n\u00a9 Guess {\nvalue\n}\n\n}\n\n\u00ae pub fn value(&self) -> i32 {\nself.value\n}\n\n}\n\nListing 9-10: A Guess type that will only continue with values between | and 100\n\nFirst, we define a struct named Guess that has a field named value that\nholds an i32 @. This is where the number will be stored.\n\nThen we implement an associated function named new on Guess that\ncreates instances of Guess values @. The new function is defined to have one\nparameter named value of type i32 and to return a Guess. The code in the\nbody of the new function tests value to make sure it\u2019s between 1 and 100 \u00ae.\nIf value doesn\u2019t pass this test, we make a panic! call 9, which will alert the\nprogrammer who is writing the calling code that they have a bug they need\nto fix, because creating a Guess with a value outside this range would violate\nthe contract that Guess: :new is relying on. The conditions in which Guess: :new\nmight panic should be discussed in its public-facing API documentation;\nwe'll cover documentation conventions indicating the possibility of a panic!\nin the API documentation that you create in Chapter 14. If value does pass\nthe test, we create a new Guess with its value field set to the value parameter\nand return the Guess \u00a9.\n\nNext, we implement a method named value that borrows self, doesn\u2019t\nhave any other parameters, and returns an i32 \u00ae. This kind of method is\nsometimes called a getter, because its purpose is to get some data from its\nfields and return it. This public method is necessary because the value field\nof the Guess struct is private. It\u2019s important that the value field be private so\ncode using the Guess struct is not allowed to set value directly: code outside\nthe module must use the Guess: :new function to create an instance of Guess,\nthereby ensuring there\u2019s no way for a Guess to have a value that hasn't been\nchecked by the conditions in the Guess: :new function.\n\nA function that has a parameter or returns only numbers between 1 and\n100 could then declare in its signature that it takes or returns a Guess rather\nthan an i32 and wouldn't need to do any additional checks in its body.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 9.15,
                        "section_name": "Summary",
                        "section_path": "./screenshots-images-2/chapter_9/section_15",
                        "images": [
                            "./screenshots-images-2/chapter_9/section_15/1a5be0b8-bd73-49b7-8dc3-a8ac53457952.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Summary\n\nRust\u2019s error-handling features are designed to help you write more robust\ncode. The panic! macro signals that your program is in a state it can\u2019t handle\nand lets you tell the process to stop instead of trying to proceed with invalid\nor incorrect values. The Result enum uses Rust\u2019s type system to indicate that\noperations might fail in a way that your code could recover from. You can use\nResult to tell code that calls your code that it needs to handle potential suc-\ncess or failure as well. Using panic! and Result in the appropriate situations\nwill make your code more reliable in the face of inevitable problems.\n\nNow that you've seen useful ways that the standard library uses generics\nwith the Option and Result enums, we'll talk about how generics work and\nhow you can use them in your code.\n",
                        "extracted-code": ""
                    }
                ]
            },
            {
                "chapter_id": 10,
                "chapter_name": "GENERIC TYPES, TRAITS,\nAND LIFETIMES",
                "chapter_path": "./screenshots-images-2/chapter_10",
                "sections": [
                    {
                        "section_id": 10.1,
                        "section_name": "GENERIC TYPES, TRAITS,\nAND LIFETIMES",
                        "section_path": "./screenshots-images-2/chapter_10/section_1",
                        "images": [
                            "./screenshots-images-2/chapter_10/section_1/6b8ff7cc-25b0-4568-8946-86d782bb784c.png",
                            "./screenshots-images-2/chapter_10/section_1/44d233e7-9a97-4952-ade5-18808dccbab8.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Every programming language has tools\nfor effectively handling the duplication of\nconcepts. In Rust, one such tool is generics.\n\nGenerics are abstract stand-ins for concrete\ntypes or other properties. When we\u2019re writing code,\nwe can express the behavior of generics or how they\nrelate to other generics without knowing what will be\n\nin their place when compiling and running the code.\n\nSimilar to the way a function takes parameters with unknown values to\nrun the same code on multiple concrete values, functions can take param-\neters of some generic type instead of a concrete type, like i32 or String. In\nfact, we've already used generics in Chapter 6 with Option<T>, Chapter 8 with\nVec<T> and HashMap<K, V>, and Chapter 9 with Result<T, E>. In this chapter,\nyou'll explore how to define your own types, functions, and methods with\ngenerics!\n\nFirst, we'll review how to extract a function to reduce code duplication.\nNext, we'll use the same technique to make a generic function from two func-\ntions that differ only in the types of their parameters. We'll also explain how\nto use generic types in struct and enum definitions.\n\nThen you'll learn how to use traits to define behavior in a generic way.\nYou can combine traits with generic types to constrain a generic type to only\nthose types that have a particular behavior, as opposed to just any type.\n\nFinally, we'll discuss lifetimes, a variety of generics that give the compiler\ninformation about how references relate to each other. Lifetimes allow us to\nborrow values in many situations while still enabling the compiler to check\nthat the references are valid.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 10.2,
                        "section_name": "Removing Duplication by Extracting a Function",
                        "section_path": "./screenshots-images-2/chapter_10/section_2",
                        "images": [
                            "./screenshots-images-2/chapter_10/section_2/fb9197bb-16b0-4f97-89a6-f348a776b6e6.png",
                            "./screenshots-images-2/chapter_10/section_2/e9ffdc7a-1a37-4a2f-b5fc-79b9ae2431ba.png",
                            "./screenshots-images-2/chapter_10/section_2/769c59ae-2359-4ddc-aee2-ccdb9fbc95ee.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Removing Duplication by Extracting a Function\n\nsrc/main.rs\n\nBefore diving into generics syntax, let\u2019s first look at how to remove duplica-\ntion that doesn\u2019t involve generic types by extracting a function. Then we'll\napply this technique to extract a generic function! In the same way that you\nrecognize duplicated code to extract into a function, you'll start to recognize\nduplicated code that can use generics.\n\nConsider a short program that finds the largest number in a list, as\nshown in Listing 10-1.\n\nfn main() {\n\n\u00a9 let number_list = vec![34, 50, 25, 100, 65];\n\n\u00a9 let mut largest = number_list[o];\n\n\u00a9 for number in number list {\n\u00a9 if number > largest {\n\u00a9 largest = number;\n\n}\n}\n\nprintln!(\"The largest number is {}\", largest);\n}\n\nListing 10-1: Code to find the largest number in a list of numbers\n\nThis code stores a list of integers in the variable number_list @ and\nplaces the first number in the list in a variable named largest \u00ae. Then it\niterates through all the numbers in the list \u00a9, and if the current number is\ngreater than the number stored in largest \u00ae, it replaces the number in that\nvariable \u00a9. However, if the current number is less than the largest number\nseen so far, the variable doesn\u2019t change, and the code moves on to the next\nnumber in the list. After considering all the numbers in the list, largest\nshould hold the largest number, which in this case is 100.\n\nTo find the largest number in two different lists of numbers, we can\nduplicate the code in Listing 10-1 and use the same logic at two different\nplaces in the program, as shown in Listing 10-2.\n\nsrc/main.rs\n\nsrc/main.rs\n\nt = number;\n\nprintln!(\"The largest number is {}\", largest);\nlet number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];\nlet mut largest = number_list[0];\nfor number in number_list {\nif number > largest {\n\nlargest = number;\n}\n\n}\n\nprintln!(\"The largest number is {}\", largest);\n\nListing 10-2: Code to find the largest number in two lists of numbers\n\nAlthough this code works, duplicating code is tedious and error\nprone. We also have to update the code in multiple places when we want\nto change it.\n\nTo eliminate this duplication, we can create an abstraction by defining\na function that operates on any list of integers given to it in a parameter.\nThis solution makes our code clearer and lets us express the concept of\nfinding the largest number in a list abstractly.\n\nIn Listing 10-3, we extracted the code that finds the largest number\ninto a function named largest. Unlike the code in Listing 10-1, which can\nfind the largest number in only one particular list, this program can find\nthe largest number in two different lists.\n\nfn largest(list: &[132]) -> 132 {\nlet mut largest = list[o];\n\nfor &item in list.iter() {\nif item > largest {\nlargest = item;\n}\n}\n\nlargest\n\nmain\n\nlet number list vec!|34, 50, 25, 100, 65];\n\nlet result = largest(&number_list);\nprintln!(\"The largest number is {}\", result);\n\nlet number list vec!|102, 34, 6000, 89, 54, 2, 43, 8];\n\nlet result = largest (&number_list);\nprintln!(\"The largest number is {}\", result);\n}\n\nListing 10-3: Abstracted code to find the largest number in two lists\n\nThe largest function has a parameter called list, which represents\nany concrete slice of 132 values that we might pass into the function. As a\nresult, when we call the function, the code runs on the specific values that\nwe pass in.\n\nIn sum, here are the steps we took to change the code from Listing 10-2\nto Listing 10-3:\n\n1. Identify duplicate code.\n\n2. Extract the duplicate code into the body of the function and specify the\ninputs and return values of that code in the function signature.\n\n3. Update the two instances of duplicated code to call the function\ninstead.\n\nNext, we'll use these same steps with generics to reduce code duplica-\ntion in different ways. In the same way that the function body can operate on\nan abstract list instead of specific values, generics allow code to operate on\nabstract types.\n\nFor example, say we had two functions: one that finds the largest item\nin a slice of i32 values and one that finds the largest item in a slice of char\nvalues. How would we eliminate that duplication? Let's find out!\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 10.3,
                        "section_name": "Generic Data Types",
                        "section_path": "./screenshots-images-2/chapter_10/section_3",
                        "images": [
                            "./screenshots-images-2/chapter_10/section_3/c703b9cd-ee15-417b-aa26-ec312d1a1807.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Generic Data Types\n\nWe can use generics to create definitions for items like function signatures\nor structs, which we can then use with many different concrete data types.\nLet\u2019s first look at how to define functions, structs, enums, and methods\nusing generics. Then we'll discuss how generics affect code performance.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 10.4,
                        "section_name": "In Function Definitions",
                        "section_path": "./screenshots-images-2/chapter_10/section_4",
                        "images": [
                            "./screenshots-images-2/chapter_10/section_4/ee60868b-a78c-4822-8932-a49ec7350a76.png",
                            "./screenshots-images-2/chapter_10/section_4/d79c3920-a8a6-405e-a554-4e1fc0a0095b.png",
                            "./screenshots-images-2/chapter_10/section_4/1ef9cdea-bf05-404e-90b3-06130a566a06.png",
                            "./screenshots-images-2/chapter_10/section_4/07c56e90-2920-4fba-85df-995df0aff6b7.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "In Function Definitions\n\nWhen defining a function that uses generics, we place the generics in the\nsignature of the function where we would usually specify the data types of\nthe parameters and return value. Doing so makes our code more flexible\nand provides more functionality to callers of our function while preventing\ncode duplication.\n\nsrc/main.rs\n\nContinuing with our largest function, Listing 10-4 shows two functions\nthat both find the largest value in a slice.\n\nfn largest_i32(list: &[i32]) -> i32 {\nlet mut largest = list[o];\n\nfor &item in list.iter() {\nif item > largest {\nlargest = item;\n}\n\n}\n\nlargest\n}\n\nfn largest_char(list: &[char]) -> char {\nlet mut largest = list[o];\n\nfor &item in list.iter() {\nif item > largest {\nlargest = item;\n\n}\n}\nlargest\n}\nfn main() {\nlet number_list = vec![34, 50, 25, 100, 65];\nlet result = largest_i32(&number_list);\nprintln!(\"The largest number is {}\", result);\nlet char_list = vec!['y', 'm', \u2018a', 'q'];\nlet result = largest_char(&char_list);\nprintln!(\"The largest char is {}\", result);\n}\n\nListing 10-4: Two functions that differ only in their names and the types in their signatures\n\nThe largest_i32 function is the one we extracted in Listing 10-3 that finds\nthe largest i32 in a slice. The largest_char function finds the largest char in a\nslice. The function bodies have the same code, so let's eliminate the duplica-\ntion by introducing a generic type parameter in a single function.\n\nTo parameterize the types in the new function we'll define, we need to\nname the type parameter, just as we do for the value parameters to a func-\ntion. You can use any identifier as a type parameter name. But we'll use T\nbecause, by convention, parameter names in Rust are short, often just a letter,\nand Rust\u2019s type-naming convention is CamelCase. Short for \u201ctype,\u201d T is the\ndefault choice of most Rust programmers.\n\nWhen we use a parameter in the body of the function, we have to declare\nthe parameter name in the signature so the compiler knows what that name\n\nsrc/main.rs\n\nmeans. Similarly, when we use a type parameter name in a function sig-\n\nnature, we have to declare the type parameter name before we use it. To\ndefine the generic largest function, place type name declarations inside\nangle brackets, <>, between the name of the function and the parameter\nlist, like this:\n\nfn largest<T>(list: &[T]) -> T {\n\nWe read this definition as: the function largest is generic over some type\nT. This function has one parameter named list, which is a slice of values of\ntype T. The largest function will return a value of the same type T.\n\nListing 10-5 shows the combined largest function definition using the\ngeneric data type in its signature. The listing also shows how we can call the\nfunction with either a slice of i32 values or char values. Note that this code\nwon't compile yet, but we'll fix it later in this chapter.\n\nfn largest<T>(list: &[T]) >T {\n\nlet mut largest = list[o];\n\nfor &item in list.iter() {\nitem > largest {\n\nt\n\nitem;\n\nla\n\nlargest\n\nfn main(\nlet number list = vec![34, 50, 25, 100, 65];\n\nlet result = largest (&number_list);\n\nprintln!(\"The largest number is {}\", result);\nlet char_list = vec!['y', \u2018m', \u2018a\u2019, \u2018q'];\n\nlet result = largest(&char_list);\nprintln!(\"The largest char is {}\", result);\n\n}\n\nListing 10-5: A definition of the largest function that uses generic type parameters but\ndoesn\u2019t compile yet\n\nIf we compile this code right now, we'll get this error:\n\nerror[E0369]: binary operation ~>~ cannot be applied to type ~T\n--> src/main.rs:5:12\n\n|\n5] if item > largest {\n\n| AARAARARAARAAA\n\n|\n= note: an implementation of ~std::cmp::PartialOrd\u2019 might be missing for ~T\n\nThe note mentions std: : cmp: :PartialOrd, which is a \u00a2rait. We'll talk about\ntraits in \u201cTraits: Defining Shared Behavior\u201d on page 182. For now, this error\nstates that the body of largest won't work for all possible types that T could\nbe. Because we want to compare values of type T in the body, we can only\nuse types whose values can be ordered. To enable comparisons, the standard\nlibrary has the std: :cmp: :PartialOrd trait that you can implement on types (see\nAppendix C for more on this trait). You'll learn how to specify that a generic\ntype has a particular trait in \u201cTraits as Parameters\u201d on page 186, but let\u2019s\nfirst explore other ways of using generic type parameters.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 10.5,
                        "section_name": "In Struct Definitions",
                        "section_path": "./screenshots-images-2/chapter_10/section_5",
                        "images": [
                            "./screenshots-images-2/chapter_10/section_5/80d6ae41-3059-448f-acd2-6c077ec62858.png",
                            "./screenshots-images-2/chapter_10/section_5/6661507f-0d1b-48f1-97e6-9fef9564bd79.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nsrc/main.rs\n\nIn Struct Definitions\n\nWe can also define structs to use a generic type parameter in one or more\nfields using the <> syntax. Listing 10-6 shows how to define a Point<T> struct\nto hold x and y coordinate values of any type.\n\nstruct Point<T>\u00ae {\n\nx: T8,\ny: TO,\n}\nfn main() {\nlet integer = Point { x: 5, y: 10 };\nlet float = Point { x: 1.0, y: 4.0 };\n}\n\nListing 10-6: A Point<T> struct that holds x and y values of type T\n\nThe syntax for using generics in struct definitions is similar to that used\nin function definitions. First, we declare the name of the type parameter\ninside angle brackets just after the name of the struct @. Then we can use\nthe generic type in the struct definition where we would otherwise specify\nconcrete data types @\u00ae.\n\nNote that because we've used only one generic type to define Point<T>,\nthis definition says that the Point<T> struct is generic over some type T, and\nthe fields x and y are both that same type, whatever that type may be. If\nwe create an instance of a Point<T> that has values of different types, as in\nListing 10-7, our code won't compile.\n\nstruct Point<T> {\n\nx: T,\n\ny: Ty\n}\nfn main() {\n\nlet wont_work = Point { x: 5, y: 4.0 };\n}\n\nlisting 10-7: The fields x and y must be the same type because both have the same\ngeneric data type T.\n\nsrc/main.rs\n\nIn this example, when we assign the integer value 5 to x, we let the\ncompiler know that the generic type T will be an integer for this instance\nof Point<T>. Then when we specify 4.0 for y, which we've defined to have the\nsame type as x, we'll get a type mismatch error like this:\n\nerror[E0308]: mismatched types\n--> src/main.rs:7:38\n\n|\n7| let wont_work = Point { x: 5, y: 4.0 };\n\n| \u201c** expected integral variable, found\nfloating-point variable\n\n|\n= note: expected type ~{integer}>\n\nfound type ~ {float}\n\nTo define a Point struct where x and y are both generics but could have\ndifferent types, we can use multiple generic type parameters. For example,\nin Listing 10-8, we can change the definition of Point to be generic over\ntypes T and U where x is of type T and y is of type U.\n\nstruct Point<T, U> {\n\nx: T,\n\ny: U,\n}\nfn main() {\n\nlet both_integer = Point { x: 5, y: 10 };\n\nlet both_float = Point { x: 1.0, y: 4.0 };\n\nlet integer_and_float = Point { x: 5, y: 4.0 };\n}\n\nListing 10-8: A Point<T, U> generic over two types so that x and y can be values of\ndifferent types\n\nNow all the instances of Point shown are allowed! You can use as many\ngeneric type parameters in a definition as you want, but using more than a\nfew makes your code hard to read. When you need lots of generic types in\nyour code, it could indicate that your code needs restructuring into smaller\npieces.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 10.6,
                        "section_name": "In Enum Definitions",
                        "section_path": "./screenshots-images-2/chapter_10/section_6",
                        "images": [
                            "./screenshots-images-2/chapter_10/section_6/341e24fd-cece-448b-9e63-20e86c14e268.png",
                            "./screenshots-images-2/chapter_10/section_6/24078764-8eb9-4668-9dbc-385508f3e91c.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "In Enum Definitions\n\nAs we did with structs, we can define enums to hold generic data types in\ntheir variants. Let\u2019s take another look at the Option<T> enum that the stan-\ndard library provides, which we used in Chapter 6:\n\nenum Option<T> {\nSome(T) ,\nNone,\n\nThis definition should now make more sense to you. As you can see,\nOption<T> is an enum that is generic over type T and has two variants: Some,\nwhich holds one value of type T, and a None variant that doesn\u2019t hold any\nvalue. By using the Option<T> enum, we can express the abstract concept of\nhaving an optional value, and because Option<T> is generic, we can use this\nabstraction no matter what the type of the optional value is.\n\nEnums can use multiple generic types as well. The definition of the\nResult enum that we used in Chapter 9 is one example:\n\nenum Result<T, E> {\nOk(T),\nErr(E),\n\nThe Result enum is generic over two types, T and E, and has two variants:\n0k, which holds a value of type T, and Err, which holds a value of type E. This\ndefinition makes it convenient to use the Result enum anywhere we have\nan operation that might succeed (return a value of some type 1) or fail\n(return an error of some type E). In fact, this is what we used to open a file\nin Listing 9-3 on page 156, where T was filled in with the type std: :fs::File\nwhen the file was opened successfully and E was filled in with the type\nstd::io::Error when there were problems opening the file.\n\nWhen you recognize situations in your code with multiple struct or\nenum definitions that differ only in the types of the values they hold, you\ncan avoid duplication by using generic types instead.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 10.7,
                        "section_name": "In Method Definitions",
                        "section_path": "./screenshots-images-2/chapter_10/section_7",
                        "images": [
                            "./screenshots-images-2/chapter_10/section_7/10498f30-92a4-4c5d-814c-8d650771b511.png",
                            "./screenshots-images-2/chapter_10/section_7/7448c8c5-581e-4ee7-9915-333058b05e5e.png",
                            "./screenshots-images-2/chapter_10/section_7/bbc87483-764d-42df-b18d-6156696ba689.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nIn Method Definitions\n\nWe can implement methods on structs and enums (as we did in Chapter 5)\nand use generic types in their definitions, too. Listing 10-9 shows the Point<T>\nstruct we defined in Listing 10-6 with a method named x implemented on it.\n\nstruct Point<T> {\nx: Ty\nyi Ty\n\n}\n\nimpl<T> Point<T> {\nfn x(&self) -> &T {\n\naself.x\n}\n}\nfn main() {\nlet p = Point { x: 5, y: 10 };\nprintln!(\"p.x = {}\", p-x());\n}\n\nListing 10-9: Implementing a method named x on the Point<T> struct that will return a\nreference to the x field of type T\n\nsrc/main.rs\n\nHere, we've defined a method named x on Point<T> that returns a refer-\nence to the data in the field x.\n\nNote that we have to declare T just after imp] so we can use it to specify\nthat we\u2019re implementing methods on the type Point<T>. By declaring T as a\ngeneric type after impl, Rust can identify that the type in the angle brackets\nin Point is a generic type rather than a concrete type.\n\nWe could, for example, implement methods only on Point<f32> instances\nrather than on Point<T> instances with any generic type. In Listing 10-10, we\nuse the concrete type f32, meaning we don\u2019t declare any types after imp].\n\nimp] Point<f32> {\nfn distance_from_origin(&self) -> \u00a332 {\n(self.x.powi(2) + self.y.powi(2)).sqrt()\n\n}\n\nListing 10-10; An imp] block that only applies to a struct with a particular concrete type\nfor the generic type parameter T\n\nThis code means the type Point<f32> will have a method named\ndistance_from_origin and other instances of Point<T> where T is not of type\n#32 will not have this method defined. The method measures how far our\npoint is from the point at coordinates (0.0, 0.0) and uses mathematical\noperations that are available only for floating point types.\n\nGeneric type parameters in a struct definition aren't always the same as\nthose you use in that struct\u2019s method signatures. For example, Listing 10-11\ndefines the method mixup on the Point<T, U> struct from Listing 10-8. The\nmethod takes another Point as a parameter, which might have different\ntypes than the self Point we're calling mixup on. The method creates a new\nPoint instance with the x value from the self Point (of type T) and the y\nvalue from the passed-in Point (of type W).\n\nstruct Point<T, U> {\nx: T,\ny: U,\n\n}\n\nimpl<T, U>\u00ae Point<T, U> {\nfn mixup<V, W>@(self, other: Point<V, W>) -> Point<T, Wo {\nPoint {\nx: self.x,\ny: other.y,\n\n}\nfn main() {\n\n\u00a9 let pi\n\u00ae let p2\n\nPoint { x: 5, y: 10.4 };\nPoint { x: \"Hello\", y: \u2018c'};\n\n\u00a9 let p3\n\np1.mixup(p2);\n\n@ println!(\"p3.x = {}, p3-y = {}\", p3-x, p3.y);\n\nListing 10-11: A method that uses different generic types than its struct\u2019s definition\n\nIn main, we've defined a Point that has an i32 for x (with value 5) and an\n64 for y (with value 10.4 \u00ae). The p2 variable is a Point struct that has a string\nslice for x (with value \"Hello\") and a char for y (with value \u00a2 \u00ae). Calling mixup\non p1 with the argument p2 gives us p3 \u00a9, which will have an i32 for x, because\nx came from p1. The p3 variable will have a char for y, because y came from p2.\nThe println! macro call \u00a9 will print p3.x = 5, p3.y = \u00a2.\n\nThe purpose of this example is to demonstrate a situation in which some\ngeneric parameters are declared with imp] and some are declared with the\nmethod definition. Here, the generic parameters T and U are declared after\nimp1 @, because they go with the struct definition. The generic parameters\nV and Ware declared after fn mixup @, because they're only relevant to the\nmethod.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 10.8,
                        "section_name": "Performance of Code Using Generics",
                        "section_path": "./screenshots-images-2/chapter_10/section_8",
                        "images": [
                            "./screenshots-images-2/chapter_10/section_8/d344c9c6-685b-47e7-af0d-17a3d8f98ca0.png",
                            "./screenshots-images-2/chapter_10/section_8/021717c3-5849-4d65-8d78-158df98bc6ba.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nPerformance of Code Using Generics\n\nYou might be wondering whether there is a runtime cost when you're using\ngeneric type parameters. The good news is that Rust implements generics in\nsuch a way that your code doesn\u2019t run any slower using generic types than it\nwould with concrete types.\n\nRust accomplishes this by performing monomorphization of the code\nthat is using generics at compile time. Monomorphization is the process of\nturning generic code into specific code by filling in the concrete types that\nare used when compiled.\n\nIn this process, the compiler does the opposite of the steps we used to\ncreate the generic function in Listing 10-5: the compiler looks at all the\nplaces where generic code is called and generates code for the concrete\ntypes the generic code is called with.\n\nLet's look at how this works with an example that uses the standard\nlibrary\u2019s Option<T> enum:\n\nlet integer = Some(5);\nlet float = Some(5.0);\n\nWhen Rust compiles this code, it performs monomorphization. During\nthat process, the compiler reads the values that have been used in Option<T>\ninstances and identifies two kinds of Option<T>: one is i32 and the other is f64.\nAs such, it expands the generic definition of Option<T> into Option_i32 and\nOption_f64, thereby replacing the generic definition with the specific ones.\n\nThe monomorphized version of the code looks like the following. The\ngeneric Option<T> is replaced with the specific definitions created by the\ncompiler:\n\nenum Option_i32 {\nSome (i32),\nNone,\n\nenum Option _f64 {\n\nSome (#64)\nNone,\n}\nfn main() {\nlet integer = Option_i32::Some(S);\nlet float = Option_f64::Some(5.0);\n}\n\nBecause Rust compiles generic code into code that specifies the type in\neach instance, we pay no runtime cost for using generics. When the code\nruns, it performs just as it would if we had duplicated each definition by\nhand. The process of monomorphization makes Rust\u2019s generics extremely\nefficient at runtime.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 10.9,
                        "section_name": "Traits: Defining Shared Behavior",
                        "section_path": "./screenshots-images-2/chapter_10/section_9",
                        "images": [
                            "./screenshots-images-2/chapter_10/section_9/0adfd35b-2fe1-465e-bf9e-6e062e6b9333.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Traits: Defining Shared Behavior\n\nA trait tells the Rust compiler about functionality a particular type has and\ncan share with other types. We can use traits to define shared behavior in\nan abstract way. We can use trait bounds to specify that a generic can be\nany type that has certain behavior.\n\n/NOTE | Traits are similar to a feature often called interfaces in other languages, although\nwith some differences.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 10.1,
                        "section_name": "Defining a Trait",
                        "section_path": "./screenshots-images-2/chapter_10/section_10",
                        "images": [
                            "./screenshots-images-2/chapter_10/section_10/dfb12a54-49ac-46a8-8943-53140e339c12.png",
                            "./screenshots-images-2/chapter_10/section_10/05f3e54c-3a28-4de8-a52b-7dd32140d7dd.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "sre/lib.rs\n\nDefining a Trait\n\nA type\u2019s behavior consists of the methods we can call on that type. Different\ntypes share the same behavior if we can call the same methods on all of those\ntypes. Trait definitions are a way to group method signatures together to\ndefine a set of behaviors necessary to accomplish some purpose.\n\nFor example, let\u2019s say we have multiple structs that hold various kinds\nand amounts of text: a NewsArticle struct that holds a news story filed in a\nparticular location and a Tweet that can have at most 280 characters along\nwith metadata that indicates whether it was a new tweet, a retweet, or a reply\nto another tweet.\n\nWe want to make a media aggregator library that can display summaries\nof data that might be stored in a NewsArticle or Tweet instance. To do this, we\nneed a summary from each type, and we need to request that summary by\ncalling a summarize method on an instance. Listing 10-12 shows the definition\nof a Summary trait that expresses this behavior.\n\npub trait Summary {\nfn summarize(&self) -> String;\n}\n\nListing 10-12: A Summary trait that consists of the behavior provided by a summarize method\n\nHere, we declare a trait using the trait keyword and then the trait\u2019s\nname, which is Summary in this case. Inside the curly brackets, we declare the\nmethod signatures that describe the behaviors of the types that implement\nthis trait, which in this case is fn summarize(&self) -> String.\n\nAfter the method signature, instead of providing an implementation\nwithin curly brackets, we use a semicolon. Each type implementing this trait\nmust provide its own custom behavior for the body of the method. The com-\npiler will enforce that any type that has the Summary trait will have the method\nsummarize defined with this signature exactly.\n\nA trait can have multiple methods in its body: the method signatures\nare listed one per line and each line ends in a semicolon.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 10.11,
                        "section_name": "Implementing a Trait on a Type",
                        "section_path": "./screenshots-images-2/chapter_10/section_11",
                        "images": [
                            "./screenshots-images-2/chapter_10/section_11/dc6248f5-87c2-4f5c-b194-c93392031201.png",
                            "./screenshots-images-2/chapter_10/section_11/27e60350-5b63-4550-9263-bcdd3de08c6b.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/lib.rs\n\nImplementing a Trait on a Type\n\nNow that we've defined the desired behavior using the Summary trait, we can\nimplement it on the types in our media aggregator. Listing 10-13 shows an\nimplementation of the Summary trait on the NewsArticle struct that uses the\nheadline, the author, and the location to create the return value of summarize.\nFor the Tweet struct, we define summarize as the username followed by the\nentire text of the tweet, assuming that tweet content is already limited to\n280 characters.\n\npub struct NewsArticle {\npub headline: String,\npub location: String,\npub author: String,\npub content: String,\n}\n\nimpl Summary for NewsArticle {\nfn summarize(&self) -> String {\nformat!(\"{}, by {} ({})\", self.headline, self.author, self.location)\n}\n\n}\n\npub struct Tweet {\npub username: String,\npub content: String,\npub reply: bool,\npub retweet: bool,\n\n}\n\nimpl Summary for Tweet {\nfn summarize(&self) -> String {\nformat!(\"{}: {}\", self.username, self.content)\n}\n\n}\n\nListing 10-13: Implementing the Summary trait on the NewsArticle and Tweet types\n\nImplementing a trait on a type is similar to implementing regular\nmethods. The difference is that after impl1, we put the trait name that we\n\nwant to implement, then use the for keyword, and then specify the name\nof the type we want to implement the trait for. Within the imp] block, we\nput the method signatures that the trait definition has defined. Instead\nof adding a semicolon after each signature, we use curly brackets and fill\nin the method body with the specific behavior that we want the methods of\nthe trait to have for the particular type.\n\nAfter implementing the trait, we can call the methods on instances of\nNewsArticle and Tweet in the same way we call regular methods, like this:\n\nlet tweet = Tweet {\nusername: String: :from(\"horse ebooks\"),\ncontent: String::from(\"of course, as you probably already know, people\"),\nreply: false,\nretweet: false,\n\nA\n\nprintln!(\"1 new tweet: {}\", tweet.summarize());\n\nThis code prints 1 new tweet: horse_ebooks: of course, as you probably\nalready know, people.\n\nNote that because we defined the Summary trait and the NewsArticle\nand Tweet types in the same lib.rs in Listing 10-13, they're all in the same\nscope. Let\u2019s say this lib.rs is for a crate we've called aggregator and some-\none else wants to use our crate\u2019s functionality to implement the Summary\ntrait on a struct defined within their library's scope. They would need to\nbring the trait into their scope first. They would do so by specifying use\naggregator: :Summary;, which then would enable them to implement Summary\nfor their type. The Summary trait would also need to be a public trait for\nanother crate to implement it, which it is because we put the pub keyword\nbefore trait in Listing 10-12.\n\nOne restriction to note with trait implementations is that we can\nimplement a trait on a type only if either the trait or the type is local to\nour crate. For example, we can implement standard library traits like\nDisplay on a custom type like Tweet as part of our aggregator crate func-\ntionality, because the type Tweet is local to our aggregator crate. We can\nalso implement Summary on Vec<T> in our aggregator crate, because the trait\nSummary is local to our aggregator crate.\n\nBut we can\u2019t implement external traits on external types. For example,\nwe can\u2019t implement the Display trait on Vec<T> within our aggregator crate,\nbecause Display and Vec<T> are defined in the standard library and aren\u2019t\nlocal to our aggregator crate. This restriction is part of a property of pro-\ngrams called coherence, and more specifically the orphan rule, so named\nbecause the parent type is not present. This rule ensures that other\npeople\u2019s code can\u2019t break your code and vice versa. Without the rule,\ntwo crates could implement the same trait for the same type, and Rust\nwouldn't know which implementation to use.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 10.12,
                        "section_name": "Default Implementations",
                        "section_path": "./screenshots-images-2/chapter_10/section_12",
                        "images": [
                            "./screenshots-images-2/chapter_10/section_12/99fc41d2-d554-4781-b3a4-8bb1c692323e.png",
                            "./screenshots-images-2/chapter_10/section_12/1415a5f3-84f1-4448-9f2a-7adc4dee4074.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/lib.rs\n\nDefault Implementations\n\nSometimes it\u2019s useful to have default behavior for some or all of the methods\nin a trait instead of requiring implementations for all methods on every\ntype. Then, as we implement the trait on a particular type, we can keep or\noverride each method's default behavior.\n\nListing 10-14 shows how to specify a default string for the summarize\nmethod of the Summary trait instead of only defining the method signature,\nas we did in Listing 10-12.\n\npub trait Summary {\nfn summarize(&self) -> String {\nString::from(\"(Read more...)\")\n\n}\n\nListing 10-14: Definition of a Summary trait with a default implementation of the summarize\nmethod\n\nTo use a default implementation to summarize instances of NewsArticle\ninstead of defining a custom implementation, we specify an empty imp] block\nwith impl Summary for NewsArticle {}.\n\nEven though we\u2019re no longer defining the summarize method on\nNewsArticle directly, we\u2019ve provided a default implementation and speci-\nfied that NewsArticle implements the Summary trait. As a result, we can still\ncall the summarize method on an instance of NewsArticle, like this:\n\nlet article = NewsArticle {\nheadline: String: :from(\"Penguins win the Stanley Cup Championship!\"),\nlocation: String::from(\"Pittsburgh, PA, USA\"),\nauthor: String::from(\"Iceburgh\"),\ncontent: String::from(\"The Pittsburgh Penguins once again are the best\nhockey team in the NHL.\"),\n\n}s\n\nprintln!(\"New article available! {}\", article.summarize());\n\nThis code prints New article available! (Read more...).\n\nCreating a default implementation for summarize doesn\u2019t require us to\nchange anything about the implementation of Summary on Tweet in Listing 10-13.\nThe reason is that the syntax for overriding a default implementation is\nthe same as the syntax for implementing a trait method that doesn\u2019t have a\ndefault implementation.\n\nDefault implementations can call other methods in the same trait, even\nif those other methods don\u2019t have a default implementation. In this way, a\ntrait can provide a lot of useful functionality and only require implemen-\ntors to specify a small part of it. For example, we could define the Summary\ntrait to have a summarize_author method whose implementation is required,\n\nand then define a summarize method that has a default implementation that\ncalls the summarize_author method:\n\npub trait Summary {\nfn summarize author(&self) -> String;\n\nfn summarize(&self) -> String {\nformat!(\"(Read more from {}...)\", self.summarize_author())\n\nTo use this version of Summary, we only need to define summarize_author\nwhen we implement the trait on a type:\n\nimpl Summary for Tweet {\nfn summarize_author(&self) -> String {\nformat! (\"@{}\", self.username)\n}\n\nAfter we define summarize_author, we can call summarize on instances of\nthe Tweet struct, and the default implementation of summarize will call the\ndefinition of summarize_author that we've provided. Because we've imple-\nmented summarize_author, the Summary trait has given us the behavior of the\nsummarize method without requiring us to write any more code.\n\nlet tweet = Tweet {\nusername: String: :from(\"horse_ebooks\"),\ncontent: String::from(\"of course, as you probably already know, people\"),\nreply: false,\nretweet: false,\n\niH\nprintln!(\"1 new tweet: {}\", tweet.summarize());\nThis code prints 1 new tweet: (Read more from @horse_ebooks...).\n\nNote that it isn\u2019t possible to call the default implementation from an\noverriding implementation of that same method.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 10.13,
                        "section_name": "Traits as Parameters",
                        "section_path": "./screenshots-images-2/chapter_10/section_13",
                        "images": [
                            "./screenshots-images-2/chapter_10/section_13/578cea3d-9261-46a5-a62c-2889cadcc52c.png",
                            "./screenshots-images-2/chapter_10/section_13/0eeb17d8-3598-4f21-9b9a-f5f425a92319.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Traits as Parameters\n\nNow that you know how to define and implement traits, we can explore how\nto use traits to define functions that accept many different types.\n\nFor example, in Listing 10-13, we implemented the Summary trait on the\nNewsArticle and Tweet types. We can define a notify function that calls the\nsummarize method on its item parameter, which is of some type that imple-\nments the Summary trait. To do this, we can use the imp] Trait syntax, like this:\n\npub fn notify(item: imp] Summary) {\nprintln! (\"Breaking news! {}\", item.summarize());\n}\n\n\nInstead of a concrete type for the item parameter, we specify the impl\nkeyword and the trait name. This parameter accepts any type that imple-\nments the specified trait. In the body of notify, we can call any methods on\nitem that come from the Summary trait, such as summarize. We can call notify\nand pass in any instance of NewsArticle or Tweet. Code that calls the function\nwith any other type, such as a String or an i32, won't compile because those\ntypes don\u2019t implement Summary.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 10.14,
                        "section_name": "Trait Bound Syntax",
                        "section_path": "./screenshots-images-2/chapter_10/section_14",
                        "images": [
                            "./screenshots-images-2/chapter_10/section_14/25a3fa93-a273-44fa-b372-91f02b596071.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Trait Bound Syntax\n\nThe impl Trait syntax works for straightforward cases but is actually syntax\nsugar for a longer form, which is called a trait bound; it looks like this:\n\npub fn notify<T: Summary>(item: T) {\nprintln!(\"Breaking news! {}\", item.summarize());\n}\n\nThis longer form is equivalent to the example in the previous section\nbut is more verbose. We place trait bounds with the declaration of the\ngeneric type parameter after a colon and inside angle brackets.\n\nThe impl Trait syntax is convenient and makes for more concise code in\nsimple cases. The trait bound syntax can express more complexity in other\ncases. For example, we can have two parameters that implement Summary.\nUsing the imp] Trait syntax looks like this:\n\npub fn notify(item1: imp] Summary, item2: impl Summary) {\n\nIf we wanted this function to allow item and item2 to have different\ntypes, using imp] Trait would be appropriate (as long as both types imple-\nment Summary). If we wanted to force both parameters to have the same type,\nthat\u2019s only possible to express using a trait bound, like this:\n\npub fn notify<T: Summary>(item1: T, item2: T) {\n\nThe generic type T specified as the type of the item1 and item2 parame-\nters constrains the function such that the concrete type of the value passed\nas an argument for item1 and item2 must be the same.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 10.15,
                        "section_name": "Specifying Multiple Trait Bounds with the + Syntax",
                        "section_path": "./screenshots-images-2/chapter_10/section_15",
                        "images": [
                            "./screenshots-images-2/chapter_10/section_15/07feb91c-7759-4901-8a9c-fdd9aae941fb.png",
                            "./screenshots-images-2/chapter_10/section_15/7de3c2af-7d02-4537-a78e-3d678f149d2f.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Specifying Multiple Trait Bounds with the + Syntax\n\nWe can also specify more than one trait bound. Say we wanted notify to use\ndisplay formatting on item as well as the summarize method: we specify in the\nnotify definition that item must implement both Display and Summary. We can\ndo so using the + syntax:\n\npub fn notify(item: imp] Summary + Display) {\nThe + syntax is also valid with trait bounds on generic types:\n\npub fn notify<T: Summary + Display>(item: T) {\n\nWith the two trait bounds specified, the body of notify can call summa-\nrize and use {} to format item.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 10.16,
                        "section_name": "Clearer Trait Bounds with where Clauses",
                        "section_path": "./screenshots-images-2/chapter_10/section_16",
                        "images": [
                            "./screenshots-images-2/chapter_10/section_16/bce786aa-f385-4b63-8228-f798276c9937.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Clearer Trait Bounds with where Clauses\n\nUsing too many trait bounds has its downsides. Each generic has its own\ntrait bounds, so functions with multiple generic type parameters can con-\ntain lots of trait bound information between the function\u2019s name and its\nparameter list, making the function signature hard to read. For this reason,\nRust has alternate syntax for specifying trait bounds inside a where clause\nafter the function signature. So instead of writing this:\n\nfn some_function<T: Display + Clone, U: Clone + Debug>(t: T, u: U) -> 132 {\nwe can use a where clause, like this:\nfn some_function<T, U>(t: T, uz U) -> i32\n\nwhere T: Display + Clone,\nU: Clone + Debug\n\nThis function\u2019s signature is less cluttered: the function name, param-\neter list, and return type are close together, similar to a function without\nlots of trait bounds.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 10.17,
                        "section_name": "Returning Types that Implement Traits",
                        "section_path": "./screenshots-images-2/chapter_10/section_17",
                        "images": [
                            "./screenshots-images-2/chapter_10/section_17/6db2ec15-e6bc-495c-b324-2de1caa8c9ab.png",
                            "./screenshots-images-2/chapter_10/section_17/a8255e85-f0ab-45a9-8a99-284b5d90ab82.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Returning Types that Implement Traits\n\nWe can also use the imp] Trait syntax in the return position to return a\nvalue of some type that implements a trait, as shown here:\n\nfn returns summarizable() -> impl Summary {\nTweet {\nusername: String: :from(\"horse_ebooks\"),\ncontent: String::from(\"of course, as you probably already know, people\"),\nreply: false,\nretweet: false,\n\nBy using imp] Summary for the return type, we specify that the returns\n_summarizable function returns some type that implements the Summary trait\nwithout naming the concrete type. In this case, returns_summarizable returns\na Tweet, but the code calling this function doesn\u2019t know that.\n\nThe ability to return a type that is only specified by the trait it imple-\nments is especially useful in the context of closures and iterators, which we\ncover in Chapter 13. Closures and iterators create types that only the com-\npiler knows or types that are very long to specify. The imp] Trait syntax lets\nyou concisely specify that a function returns some type that implements the\nIterator trait without needing to write out a very long type.\n\nHowever, you can only use imp] Trait if you're returning a single type.\nFor example, this code that returns either a NewsArticle or a Tweet with the\nreturn type specified as imp] Summary wouldn\u2019t work:\n\nfn returns _summarizable(switch: bool) -> impl Summary {\nif switch {\nNewsArticle {\nheadline: String: :from(\"Penguins win the Stanley Cup Championship!\"),\nlocation: String: :from(\"Pittsburgh, PA, USA\"),\nauthor: String: :from(\"Iceburgh\"),\ncontent: String::from(\"The Pittsburgh Penguins once again are the best\nhockey team in the NHL.\"),\n\n} else {\nTweet {\nusername: String: :from(\"horse_ebooks\"),\ncontent: String::from(\"of course, as you probably already know, people\"),\nreply: false,\nretweet: false,\n\n}\n\nReturning either a NewsArticle or a Tweet isn\u2019t allowed due to restrictions\naround how the imp] Trait syntax is implemented in the compiler. We'll\ncover how to write a function with this behavior in \u201cUsing Trait Objects\nThat Allow for Values of Different Types\u201d on page 375.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 10.18,
                        "section_name": "Fixing the largest Function with Trait Bounds",
                        "section_path": "./screenshots-images-2/chapter_10/section_18",
                        "images": [
                            "./screenshots-images-2/chapter_10/section_18/50d1c8a3-5b42-4f7f-aec5-fa140e258372.png",
                            "./screenshots-images-2/chapter_10/section_18/12058ce1-ec00-40de-89af-dc1ee12acb8a.png",
                            "./screenshots-images-2/chapter_10/section_18/a18cf4fd-1fba-464d-98b4-5e1cb691e7d2.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Fixing the largest Function with Trait Bounds\n\nNow that you know how to specify the behavior you want to use using the\ngeneric type parameter\u2019s bounds, let\u2019s return to Listing 10-5 to fix the defi-\nnition of the largest function that uses a generic type parameter! Last time\nwe tried to run that code, we received this error:\n\nerror[E0369]: binary operation \u201c>> cannot be applied to type ~T~\n--> src/main.rs:5:12\n\n|\nif item > largest {\n\n|\n| ARARAAABARARAA\n|\n\n5\n\nnote: an implementation of ~std::cmp::PartialOrd\u2019 might be missing for ~T~\n\nIn the body of largest, we wanted to compare two values of type T using\nthe greater than (>) operator. Because that operator is defined as a default\nmethod on the standard library trait std: :cmp: :PartialOrd, we need to specify\nPartial0rd in the trait bounds for T so the largest function can work on slices\nof any type that we can compare. We don\u2019t need to bring Partial0rd into scope\nbecause it\u2019s in the prelude. Change the signature of largest to look like this:\n\nfn largest<T: PartialOrd>(list: &[T]) -> T {\n\nThis time when we compile the code, we get a different set of errors:\n\nerror[E0508]: cannot move out of type ~[T]~, a non-copy slice\n--> src/main.rs:2:23\n\n2 let mut largest = list[0];\n\n|\n\n| AARARAA\n\n| |\n\n| cannot move out of here\n\n| help: consider using a reference instead: \u201c&list[o]\u00b0\n\nerror[E0507]: cannot move out of borrowed content\n--> src/main.rs:4:9\n\n4 for &item in list.iter() {\n\nA\n\n|\n\n| ----\n| |\n\n| |hint: to prevent move, use \u201cref item or \u201cref mut item\n| cannot move out of borrowed content\n\nThe key line in this error is cannot move out of type [T], a non-copy slice.\nWith our non-generic versions of the largest function, we were only trying\nto find the largest i32 or char. As discussed in \u201cStack-Only Data: Copy\u201d on\npage 67, types like i32 and char that have a known size can be stored on the\nstack, so they implement the Copy trait. But when we made the largest func-\ntion generic, it became possible for the list parameter to have types in it that\ndon\u2019t implement the Copy trait. Consequently, we wouldn't be able to move the\nvalue out of list[0] and into the largest variable, resulting in this error.\n\nTo call this code with only those types that implement the Copy trait, we\ncan add Copy to the trait bounds of T! Listing 10-15 shows the complete code\nof a generic largest function that will compile as long as the types of the\nvalues in the slice that we pass into the function implement the PartialOrd\nand Copy traits, as i32 and char do.\n\nsrc\u00a2/main.rs fn largest<T: PartialOrd + Copy>(list: &[T]) -> T {\nlet mut largest = list[o];\n\nfor &item in list.iter() {\nif item > largest {\nlargest = item;\n\n}\n}\nlargest\n}\nfn main() {\n\nlet number_list = vec![34, 50, 25, 100, 65];\n\nlet result = largest(&number_list);\nprintln!(\"The largest number is {}\", result);\n\nlet char_list = vec!['y', 'm', \u2018a', 'q'];\n\nlet result = largest(&char_list);\nprintln!(\"The largest char is {}\", result);\n\nListing 10-15: A working definition of the largest function that works on any generic type\nthat implements the Partial0rd and Copy traits\n\nIf we don\u2019t want to restrict the largest function to the types that imple-\nment the Copy trait, we could specify that T has the trait bound Clone instead\nof Copy. Then we could clone each value in the slice when we want the largest\nfunction to have ownership. Using the clone function means we're potentially\nmaking more heap allocations in the case of types that own heap data like\nString, and heap allocations can be slow if we're working with large amounts\nof data.\n\nAnother way we could implement largest is for the function to return a\nreference to a T value in the slice. If we change the return type to &T instead\nof T, thereby changing the body of the function to return a reference, we\nwouldn't need the Clone or Copy trait bounds and we could avoid heap allo-\ncations. Try implementing these alternate solutions on your own!\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 10.19,
                        "section_name": "Using Trait Bounds to Conditionally Implement Methods",
                        "section_path": "./screenshots-images-2/chapter_10/section_19",
                        "images": [
                            "./screenshots-images-2/chapter_10/section_19/02f5e8e6-8b6a-49e6-865c-9217eb9567ef.png",
                            "./screenshots-images-2/chapter_10/section_19/5c4c7f47-5c56-46d4-a51e-a7ee5876d68f.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Lf bad - \u00a2\n\nUsing Trait Bounds to Conditionally Implement Methods\n\nBy using a trait bound with an imp] block that uses generic type parameters,\nwe can implement methods conditionally for types that implement the spec-\nified traits. For example, the type Pair<T> in Listing 10-16 always implements\nthe new function. But Pair<T> only implements the cmp_display method if its\ninner type T implements the PartialOrd trait that enables comparison and\nthe Display trait that enables printing.\n\nuse std:: fmt: :Display;\n\nstruct Pair<T> {\nx: Ty\ny:T,\n\n}\n\nimpl<T> Pair<T> {\nfn new(x: T, y: T) -> Self {\n\nSelf {\nx,\nYs\n}\n\n}\n\nimpl<T: Display + PartialOrd> Pair<T> {\nfn cmp_display(&self) {\nif self.x >= self.y {\nprintln!(\"The largest member is x = {}\", self.x);\n} else {\n\nprintln!(\"The largest member is y = {}\", self.y);\n\n}\nListing 10-16: Conditionally implement methods on a generic type depending on trait bounds\n\nWe can also conditionally implement a trait for any type that implements\nanother trait. Implementations of a trait on any type that satisfies the trait\nbounds are called blanket implementations and are extensively used in the Rust\nstandard library. For example, the standard library implements the ToString\ntrait on any type that implements the Display trait. The imp] block in the stan-\ndard library looks similar to this code:\n\nimpl<T: Display> ToString for T {\n// --snip--\n}\n\nBecause the standard library has this blanket implementation, we can\ncall the to_string method defined by the ToString trait on any type that\nimplements the Display trait. For example, we can turn integers into their\ncorresponding String values like this because integers implement Display:\n\nlet s = 3.to_string();\n\nBlanket implementations appear in the documentation for the trait in\nthe \u201cImplementors\u201d section.\n\nTraits and trait bounds let us write code that uses generic type param-\neters to reduce duplication but also specify to the compiler that we want the\ngeneric type to have particular behavior. The compiler can then use the trait\nbound information to check that all the concrete types used with our code\nprovide the correct behavior. In dynamically typed languages, we would\nget an error at runtime if we called a method on a type that the type didn\u2019t\nimplement. But Rust moves these errors to compile time so we're forced to\nfix the problems before our code is even able to run. Additionally, we don\u2019t\nhave to write code that checks for behavior at runtime because we've already\nchecked at compile time. Doing so improves performance without having to\ngive up the flexibility of generics.\n\nAnother kind of generic that we've already been using is called lifetimes.\nRather than ensuring that a type has the behavior we want, lifetimes ensure\nthat references are valid as long as we need them to be. Let's look at how\nlifetimes do that.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 10.2,
                        "section_name": "Validating References with Lifetimes",
                        "section_path": "./screenshots-images-2/chapter_10/section_20",
                        "images": [
                            "./screenshots-images-2/chapter_10/section_20/0e538410-c6f4-4687-98c0-2febd384c54d.png",
                            "./screenshots-images-2/chapter_10/section_20/4f6f9e94-c97a-440a-86b0-f6f5fc2ce21d.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Validating References with Lifetimes\n\nOne detail we didn\u2019t discuss in \u201cReferences and Borrowing\u201d on page 70 is\nthat every reference in Rust has a lifetime, which is the scope for which that\nreference is valid. Most of the time, lifetimes are implicit and inferred, just\nlike most of the time, types are inferred. We must annotate types when\nmultiple types are possible. In a similar way, we must annotate lifetimes\n\nwhen the lifetimes of references could be related in a few different ways.\nRust requires us to annotate the relationships using generic lifetime param-\neters to ensure the actual references used at runtime will definitely be valid.\n\nThe concept of lifetimes is somewhat different from tools in other pro-\ngramming languages, arguably making lifetimes Rust\u2019s most distinctive\nfeature. Although we won't cover lifetimes in their entirety in this chapter,\nwe'll discuss common ways you might encounter lifetime syntax so you can\nbecome familiar with the concepts.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 10.21,
                        "section_name": "Preventing Dangling References with Lifetimes",
                        "section_path": "./screenshots-images-2/chapter_10/section_21",
                        "images": [
                            "./screenshots-images-2/chapter_10/section_21/3a82de6c-ad77-4317-94e6-9c7b2c2ddec3.png",
                            "./screenshots-images-2/chapter_10/section_21/95d58216-a84f-4b04-a00b-abe0afd617ae.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Preventing Dangling References with Lifetimes\n\nThe main aim of lifetimes is to prevent dangling references, which cause a pro-\ngram to reference data other than the data it\u2019s intended to reference. Consider\nthe program in Listing 10-17, which has an outer scope and an inner scope.\n\n{\n\u00a9 let r;\n\n{\n@ le 53\nOr\n\nad\n\nX=\n&x;\n0}\n\n\u00a9 println!(\"r: {}\", x);\n\nListing 10-17: An attempt to use a reference whose value has gone out of scope\n\nThe examples in Listings 10-17, 10-18, and 10-24 declare variables without giving\nthem an initial value, so the variable name exists in the outer scope. At first glance,\nthis might appear to be in conflict with Rust\u2019s having no null values. However, if\nwe try to use a variable before giving it a value, we'll get a compile-time error, which\nshows that Rust indeed does not allow null values.\n\nThe outer scope declares a variable named r with no initial value 0,\nand the inner scope declares a variable named x with the initial value of 5 @.\nInside the inner scope, we attempt to set the value of r as a reference to x 6.\nThen the inner scope ends O, and we attempt to print the value in r \u00a9. This\ncode won't compile because the value r is referring to has gone out of scope\nbefore we try to use it. Here is the error message:\n\nerror[E0597]: \u201cx does not live long enough\n--> src/main.rs:7:5\n\n6 | r= &;\n\n| - borrow occurs here\n7 | }\n\n| * \u201cx dropped here while still borrowed\n10 | }\n\n| - borrowed value needs to live until here\n\nThe variable x doesn\u2019t \u201clive long enough.\u201d The reason is that x will\nbe out of scope when the inner scope ends at 9. But r is still valid for\nthe outer scope; because its scope is larger, we say that it \u201clives longer.\u201d If\nRust allowed this code to work, r would be referencing memory that was\ndeallocated when x went out of scope, and anything we tried to do with\nr wouldn\u2019t work correctly. So how does Rust determine that this code is\ninvalid? It uses a borrow checker.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 10.22,
                        "section_name": "The Borrow Checker",
                        "section_path": "./screenshots-images-2/chapter_10/section_22",
                        "images": [
                            "./screenshots-images-2/chapter_10/section_22/4f9de2c4-973f-4a27-bfc6-83310e49dcc3.png",
                            "./screenshots-images-2/chapter_10/section_22/43383f3e-0095-44b5-8093-123e01ff1293.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "The Borrow Checker\n\nThe Rust compiler has a borrow checker that compares scopes to determine\nwhether all borrows are valid. Listing 10-18 shows the same code as\nListing 10-17 but with annotations showing the lifetimes of the variables.\n\nprintin!(\"r: {}\", x); //\n\nListing 10-18: Annotations of the lifetimes of r and x, named \u2018a and 'b, respectively\n\nHere, we've annotated the lifetime of r with 'a and the lifetime of x with\n\u2018b. As you can see, the inner 'b block is much smaller than the outer \u2018a life-\ntime block. At compile time, Rust compares the size of the two lifetimes and\nsees that r has a lifetime of 'a but that it refers to memory with a lifetime of\n\u2018b. The program is rejected because 'b is shorter than \u2018a: the subject of the\nreference doesn\u2019t live as long as the reference.\n\nListing 10-19 fixes the code so it doesn\u2019t have a dangling reference and\ncompiles without any errors.\n\n{\n\nlet x = 5; || ----------\n\u2018\n\n+\n|\nlet r = &; // --+-- \u2018a |\n|\n|\n|\n\n|\nprintin!(\"r: {}\", r); // |\nM] --+\n} If ---------- +\n\nListing 10-19: A valid reference because the data has a longer lifetime than the reference\n\nHere, x has the lifetime 'b, which in this case is larger than \u2018a. This\nmeans r can reference x because Rust knows that the reference in r will\nalways be valid while x is valid.\n\nNow that you know where the lifetimes of references are and how Rust\nanalyzes lifetimes to ensure references will always be valid, let's explore\ngeneric lifetimes of parameters and return values in the context of functions.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 10.23,
                        "section_name": "Generic Lifetimes in Functions",
                        "section_path": "./screenshots-images-2/chapter_10/section_23",
                        "images": [
                            "./screenshots-images-2/chapter_10/section_23/3f32cd24-f001-4b7d-bffb-ac9e833a4c77.png",
                            "./screenshots-images-2/chapter_10/section_23/703655e6-bad7-4982-b318-a39d080bc3ca.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nsrc/main.rs\n\nGeneric Lifetimes in Functions\n\nLet\u2019s write a function that returns the longer of two string slices. This\nfunction will take two string slices and return a string slice. After we've\nimplemented the longest function, the code in Listing 10-20 should print\nThe longest string is abcd.\n\nfn main() {\nlet string1 = String: :from(\"abcd\");\nlet string2 = \"xyz\";\n\nlet result = longest(string1.as_str(), string2);\nprintln!(\"The longest string is {}\", result);\n\n}\n\nListing 10-20: A main function that calls the longest function to find the longer of two\nstring slices\n\nNote that we want the function to take string slices, which are refer-\nences, because we don\u2019t want the longest function to take ownership of its\nparameters. We want to allow the function to accept slices of a String (the\ntype stored in the variable string1) as well as string literals (which is what\nvariable string2 contains).\n\nRefer to \u201cString Slices as Parameters\u201d on page 80 for more discussion\nabout why the parameters we use in Listing 10-20 are the ones we want.\n\nIf we try to implement the longest function as shown in Listing 10-21, it\nwon't compile.\n\nfn longest(x: &str, y: &str) -> &str {\nif x.len() > y.len() {\nx\n} else {\ny\n}\n}\n\nListing 10-21: An implementation of the longest function that returns the longer of two\nstring slices but does not yet compile\n\nInstead, we get the following error that talks about lifetimes:\n\nerror[E0106]: missing lifetime specifier\n--> src/main.rs:1:33\n\n1 | fn longest(x: &str, y: &str) -> &str {\n\n|\n| * expected lifetime parameter\n|\n\n= help: this function's return type contains a borrowed value, but the\nsignature does not say whether it is borrowed from \u201cx\u201d or \u201cy\u201d\n\nThe help text reveals that the return type needs a generic lifetime\nparameter on it because Rust can\u2019t tell whether the reference being returned\nrefers to x or y. Actually, we don\u2019t know either, because the if block in the\nbody of this function returns a reference to x and the else block returns a\nreference to y!\n\nWhen we're defining this function, we don\u2019t know the concrete values\nthat will be passed into this function, so we don\u2019t know whether the if case\nor the else case will execute. We also don\u2019t know the concrete lifetimes of\nthe references that will be passed in, so we can\u2019t look at the scopes as we did\nin Listings 10-18 and 10-19 to determine whether the reference we return\nwill always be valid. The borrow checker can\u2019t determine this either, because\nit doesn\u2019t know how the lifetimes of x and y relate to the lifetime of the return\nvalue. To fix this error, we'll add generic lifetime parameters that define the\nrelationship between the references so the borrow checker can perform its\nanalysis.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 10.24,
                        "section_name": "Lifetime Annotation Syntax",
                        "section_path": "./screenshots-images-2/chapter_10/section_24",
                        "images": [
                            "./screenshots-images-2/chapter_10/section_24/39763cb9-3e4c-4de1-a4a7-43052babc4c0.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Lifetime Annotation Syntax\n\nLifetime annotations don\u2019t change how long any of the references live. Just\nas functions can accept any type when the signature specifies a generic type\nparameter, functions can accept references with any lifetime by specifying a\ngeneric lifetime parameter. Lifetime annotations describe the relationships\nof the lifetimes of multiple references to each other without affecting the\nlifetimes.\n\nLifetime annotations have a slightly unusual syntax: the names of\nlifetime parameters must start with a single quote (') and are usually all\nlowercase and very short, like generic types. Most people use the name \u2018a.\nWe place lifetime parameter annotations after the & of a reference, using a\nspace to separate the annotation from the reference\u2019s type.\n\nHere are some examples: a reference to an i32 without a lifetime\nparameter, a reference to an i32 that has a lifetime parameter named \u2018a,\nand a mutable reference to an i32 that also has the lifetime \u2018a.\n\n&i32 // a reference\n&'a 132 // a reference with an explicit lifetime\n&'a mut i32 // a mutable reference with an explicit lifetime\n\nOne lifetime annotation by itself doesn\u2019t have much meaning, because\nthe annotations are meant to tell Rust how generic lifetime parameters of\nmultiple references relate to each other. For example, let\u2019s say we have a\nfunction with the parameter first that is a reference to an i32 with lifetime\n\u2018a. The function also has another parameter named second that is another\nreference to an i32 that also has the lifetime 'a. The lifetime annotations\nindicate that the references first and second must both live as long as that\ngeneric lifetime.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 10.25,
                        "section_name": "Lifetime Annotations in Function Signatures",
                        "section_path": "./screenshots-images-2/chapter_10/section_25",
                        "images": [
                            "./screenshots-images-2/chapter_10/section_25/c29bd967-67ef-4105-92fa-3cdd15e779fb.png",
                            "./screenshots-images-2/chapter_10/section_25/28c71ed9-d0db-41d7-9aba-c2f8f5ad8bee.png",
                            "./screenshots-images-2/chapter_10/section_25/61cc4887-bc4a-427b-80e6-bb40d19fb969.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nLifetime Annotations in Function Signatures\n\nNow let's examine lifetime annotations in the context of the longest function.\nAs with generic type parameters, we need to declare generic lifetime param-\neters inside angle brackets between the function name and the parameter\nlist. The constraint we want to express in this signature is that all the refer-\nences in the parameters and the return value must have the same lifetime.\nWe'll name the lifetime 'a and then add it to each reference, as shown in\nListing 10-22.\n\nfn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n\nif x.le > y.le\n\nListing 10-22: The longest function definition specifying that all the references in the\nsignature must have the same lifetime 'a\n\nThis code should compile and produce the result we want when we use\nit with the main function in Listing 10-20.\n\nThe function signature now tells Rust that for some lifetime \u2018a, the\nfunction takes two parameters, both of which are string slices that live at\nleast as long as lifetime 'a. The function signature also tells Rust that the\nstring slice returned from the function will live at least as long as lifetime\n\u2018a. These constraints are what we want Rust to enforce. Remember, when we\nspecify the lifetime parameters in this function signature, we're not chang-\ning the lifetimes of any values passed in or returned. Rather, we're speci-\nfying that the borrow checker should reject any values that don\u2019t adhere\nto these constraints. Note that the longest function doesn\u2019t need to know\nexactly how long x and y will live, only that some scope can be substituted\nfor \u2018a that will satisfy this signature.\n\nWhen annotating lifetimes in functions, the annotations go in the func-\ntion signature, not in the function body. Rust can analyze the code within\nthe function without any help. However, when a function has references to\nor from code outside that function, it becomes almost impossible for Rust\nto figure out the lifetimes of the parameters or return values on its own.\nThe lifetimes might be different each time the function is called. This is\nwhy we need to annotate the lifetimes manually.\n\nWhen we pass concrete references to longest, the concrete lifetime that is\nsubstituted for \u2018a is the part of the scope of x that overlaps with the scope of\ny. In other words, the generic lifetime \u2018a will get the concrete lifetime that is\nequal to the smaller of the lifetimes of x and y. Because we've annotated the\nreturned reference with the same lifetime parameter \u2018a, the returned refer-\nence will also be valid for the length of the smaller of the lifetimes of x and y.\n\nLet's look at how the lifetime annotations restrict the longest function\nby passing in references that have different concrete lifetimes. Listing 10-23\nis a straightforward example.\n\nsrc/main.rs\n\nsrc/main.rs\n\nfn main() {\nlet string1 = String: :from(\"long string is long\");\n\n{\nlet string2 = String::from(\"xyz\");\nlet result = longest(stringi.as_str(), string2.as_str());\nprintln!(\"The longest string is {}\", result);\n\n}\n\nListing 10-23: Using the longest function with references to String values that have different\nconcrete lifetimes\n\nIn this example, string1 is valid until the end of the outer scope, string2\nis valid until the end of the inner scope, and result references something\nthat is valid until the end of the inner scope. Run this code, and you'll see that\nthe borrow checker approves of this code; it will compile and print The longest\nstring is long string is long.\n\nNext, let\u2019s try an example that shows that the lifetime of the reference\nin result must be the smaller lifetime of the two arguments. We'll move\nthe declaration of the result variable outside the inner scope but leave the\nassignment of the value to the result variable inside the scope with string2.\nThen we'll move the println! that uses result outside the inner scope, after\nthe inner scope has ended. The code in Listing 10-24 will not compile.\n\nfn main() {\nlet string1 = String: :from(\"long string is long\");\nlet result;\n\n{\nlet string2 = String::from(\"xyz\");\nresult = longest(stringi.as_ str(), string2.as_str());\n\n}\nprintln!(\"The longest string is {}\", result);\n\nListing 10-24: Attempting to use result after string2 has gone out of scope\n\nWhen we try to compile this code, we'll get this error:\n\nerror[E0597]: \u201cstring2\u201d does not live long enough\n--> src/main.rs:15:5\n\n14 | result = longest(stringi.as str(), string2.as_str());\nPe borrow occurs here\n15 | }\n| * ~string2~ dropped here while still borrowed\n16 | println!(\"The longest string is {}\", result);\n17 | }\n|\n\n- borrowed value needs to live until here\n\nThe error shows that for result to be valid for the println! statement,\nstring2 would need to be valid until the end of the outer scope. Rust knows\nthis because we annotated the lifetimes of the function parameters and\nreturn values using the same lifetime parameter \u2018a.\n\nAs humans, we can look at this code and see that string1 is longer than\nstring2 and therefore result will contain a reference to string1. Because\nstringi has not gone out of scope yet, a reference to string1 will still be valid\nfor the println! statement. However, the compiler can\u2019t see that the refer-\nence is valid in this case. We've told Rust that the lifetime of the reference\nreturned by the longest function is the same as the smaller of the lifetimes\nof the references passed in. Therefore, the borrow checker disallows the\ncode in Listing 10-24 as possibly having an invalid reference.\n\nTry designing more experiments that vary the values and lifetimes of the\nreferences passed in to the longest function and how the returned reference\nis used. Make hypotheses about whether or not your experiments will pass\nthe borrow checker before you compile; then check to see if you're right!\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 10.26,
                        "section_name": "Thinking in Terms of Lifetimes",
                        "section_path": "./screenshots-images-2/chapter_10/section_26",
                        "images": [
                            "./screenshots-images-2/chapter_10/section_26/cb999aad-4550-4f54-8a00-4517f69a6fee.png",
                            "./screenshots-images-2/chapter_10/section_26/f65a5188-8d63-4fc0-9698-f206dc3bedb7.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nsrc/main.rs\n\nThinking in Terms of Lifetimes\n\nThe way in which you need to specify lifetime parameters depends on what\nyour function is doing. For example, if we changed the implementation of\nthe longest function to always return the first parameter rather than the\nlongest string slice, we wouldn't need to specify a lifetime on the y param-\neter. The following code will compile:\n\nfn longest<'a>(x: &'a str, y: &str) -> &'a str {\n\nx\n}\n\nIn this example, we've specified a lifetime parameter \u2018a for the param-\neter x and the return type, but not for the parameter y, because the lifetime\nof y does not have any relationship with the lifetime of x or the return value.\n\nWhen returning a reference from a function, the lifetime parameter for\nthe return type needs to match the lifetime parameter for one of the param-\neters. If the reference returned does not refer to one of the parameters, it\nmust refer to a value created within this function, which would be a dangling\nreference because the value will go out of scope at the end of the function.\n\nConsider this attempted implementation of the longest function that won't\ncompile:\n\nfn longest<'a>(x: &str, y: &str) -> &'a str {\nlet result = String::from(\"really long string\");\nresult.as_str()\n\n\nHere, even though we've specified a lifetime parameter \u2018a for the\nreturn type, this implementation will fail to compile because the return\nvalue lifetime is not related to the lifetime of the parameters at all. Here\nis the error message we get:\n\nerror[E0597]: \u201cresult~ does not live long enough\n--> src/main.rs:3:5\n\n|\nresult.as_str()\n\n3 |\n| aaeane does not live long enough\n|\n|\n\n4\n\ntw\n\nborrowed value only lives until here\n\n|\nnote: borrowed value must be valid for the lifetime 'a as defined on the\nfunction body at 1:1...\n--> src/main.rs:1:1\n\n1 | / fn longest<'a>(x: &str, y: &str) -> &'a str {\n\n2 |] let result = String::from(\"really long string\");\n\n3] | result.as_str()\n\n4\\ |\n|\n\nThe problem is that result goes out of scope and gets cleaned up at the\nend of the longest function. We're also trying to return a reference to result\nfrom the function. There is no way we can specify lifetime parameters that\nwould change the dangling reference, and Rust won't let us create a dangling\nreference. In this case, the best fix would be to return an owned data type\nrather than a reference so the calling function is then responsible for clean-\ning up the value.\n\nUltimately, lifetime syntax is about connecting the lifetimes of various\nparameters and return values of functions. Once they\u2019re connected, Rust has\nenough information to allow memory-safe operations and disallow opera-\ntions that would create dangling pointers or otherwise violate memory safety.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 10.27,
                        "section_name": "Lifetime Annotations in Struct Definitions",
                        "section_path": "./screenshots-images-2/chapter_10/section_27",
                        "images": [
                            "./screenshots-images-2/chapter_10/section_27/e99f5f45-0a23-4a59-87b7-1dd9eac04636.png",
                            "./screenshots-images-2/chapter_10/section_27/ea03ed25-c269-478e-9627-6c76d63200d5.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nLifetime Annotations in Struct Definitions\n\nSo far, we've only defined structs to hold owned types. It\u2019s possible for structs\nto hold references, but in that case we would need to add a lifetime annota-\ntion on every reference in the struct\u2019s definition. Listing 10-25 has a struct\nnamed ImportantExcerpt that holds a string slice.\n\n\u00a9 struct ImportantExcerpt<'a> {\n\u00a9 part: &'a str,\n}\n\nfn main() {\n\u00a9 let novel = String::from(\"Call me Ishmael. Some years ago...\");\n\u00a9 let first_sentence = novel.split('.')\n\n-next()\n\n-expect(\"Could not find a '.'\");\n\n\u00a9 let i = ImportantExcerpt { part: first_sentence };\n}\n\nListing 10-25: A struct that holds a reference, so its definition needs a lifetime annotation\n\nThis struct has one field, part, that holds a string slice, which is a refer-\nence \u00ae. As with generic data types, we declare the name of the generic\nlifetime parameter inside angle brackets after the name of the struct so we\ncan use the lifetime parameter in the body of the struct definition @. This\nannotation means an instance of ImportantExcerpt can\u2019t outlive the reference\nit holds in its part field.\n\nThe main function here creates an instance of the ImportantExcerpt\nstruct @ that holds a reference to the first sentence of the String @ owned\nby the variable novel \u00a9. The data in novel exists before the ImportantExcerpt\ninstance is created. In addition, novel doesn\u2019t go out of scope until after the\nImportantExcerpt goes out of scope, so the reference in the ImportantExcerpt\ninstance is valid.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 10.28,
                        "section_name": "Lifetime Elision",
                        "section_path": "./screenshots-images-2/chapter_10/section_28",
                        "images": [
                            "./screenshots-images-2/chapter_10/section_28/970e8e35-7eb5-45b4-9957-e45d6d2c52e7.png",
                            "./screenshots-images-2/chapter_10/section_28/c3659695-0820-439f-b544-9c0a7f437292.png",
                            "./screenshots-images-2/chapter_10/section_28/3d05a652-78f8-4018-a025-94215604f074.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/lib.rs\n\nLifetime Elision\n\nYou've learned that every reference has a lifetime and that you need to\nspecify lifetime parameters for functions or structs that use references.\nHowever, we had a function in Listing 4-9 on page 80, which is shown\nagain in Listing 10-26, that compiled without lifetime annotations.\n\nfn first_word(s: &str) -> &str {\nlet bytes = s.as_bytes();\n\nfor (i, &item) in bytes. iter().enumerate() {\nif item == b' ' {\nreturn &s[0..i];\n}\n\n}\n\n&s[..]\n}\n\nListing 10-26: A function we defined in Listing 4-9 that compiled without lifetime annota-\ntions, even though the parameter and return type are references\n\nThe reason this function compiles without lifetime annotations is his-\ntorical: in early versions (pre-1.0) of Rust, this code wouldn\u2019t have compiled\nbecause every reference needed an explicit lifetime. At that time, the func-\ntion signature would have been written like this:\n\nfn first_word<'a>(s: &'a str) -> &'a str {\n\nAfter writing a lot of Rust code, the Rust team found that Rust program-\nmers were entering the same lifetime annotations over and over in particular\nsituations. These situations were predictable and followed a few deterministic\n\npatterns. The developers programmed these patterns into the compiler\u2019s\ncode so the borrow checker could infer the lifetimes in these situations and\nwouldn't need explicit annotations.\n\nThis piece of Rust history is relevant because it\u2019s possible that more\ndeterministic patterns will emerge and be added to the compiler. In the\nfuture, even fewer lifetime annotations might be required.\n\nThe patterns programmed into Rust\u2019s analysis of references are called\nthe lifetime elision rules. These aren't rules for programmers to follow; they're\na set of particular cases that the compiler will consider, and if your code fits\nthese cases, you don\u2019t need to write the lifetimes explicitly.\n\nThe elision rules don\u2019t provide full inference. If Rust deterministically\napplies the rules but there is still ambiguity as to what lifetimes the references\nhave, the compiler won't guess what the lifetime of the remaining references\nshould be. In this case, instead of guessing, the compiler will give you an\nerror that you can resolve by adding the lifetime annotations that specify\nhow the references relate to each other.\n\nLifetimes on function or method parameters are called input lifetimes,\nand lifetimes on return values are called output lifetimes.\n\nThe compiler uses three rules to figure out what lifetimes references\nhave when there aren't explicit annotations. The first rule applies to input\nlifetimes, and the second and third rules apply to output lifetimes. If the\ncompiler gets to the end of the three rules and there are still references\nfor which it can\u2019t figure out lifetimes, the compiler will stop with an error.\nThese rules apply to fn definitions as well as imp] blocks.\n\nThe first rule is that each parameter that is a reference gets its own life-\ntime parameter. In other words, a function with one parameter gets one\nlifetime parameter: fn foo<'a>(x: &'a 132); a function with two parameters\ngets two separate lifetime parameters: fn foo<'a, 'b>(x: &'a 132, y: &'b 132);\nand so on.\n\nThe second rule is if there is exactly one input lifetime parameter, that\nlifetime is assigned to all output lifetime parameters: fn foo<'a>(x: &'a i32)\n-> Ba 132.\n\nThe third rule is if there are multiple input lifetime parameters, but one\nof them is &self or &mut self because this is a method, the lifetime of self is\nassigned to all output lifetime parameters. This third rule makes methods\nmuch nicer to read and write because fewer symbols are necessary.\n\nLet's pretend we're the compiler. We'll apply these rules to figure out\nwhat the lifetimes of the references in the signature of the first_word func-\ntion in Listing 10-26 are. The signature starts without any lifetimes associ-\nated with the references:\n\nfn first_word(s: &str) -> &str {\n\nThen the compiler applies the first rule, which specifies that each param-\neter gets its own lifetime. We'll call it 'a as usual, so now the signature is this:\n\nfn first_word<'a>(s: &'a str) -> &str {\n\nThe second rule applies because there is exactly one input lifetime.\nThe second rule specifies that the lifetime of the one input parameter gets\nassigned to the output lifetime, so the signature is now this:\n\nfn first_word<'a>(s: &'a str) -> &'a str {\n\nNow all the references in this function signature have lifetimes, and\nthe compiler can continue its analysis without needing the programmer to\nannotate the lifetimes in this function signature.\n\nLet's look at another example, this time using the longest function\nthat had no lifetime parameters when we started working with it in\nListing 10-21:\n\nfn longest(x: &str, y: &str) -> &str {\n\nLet's apply the first rule: each parameter gets its own lifetime. This time\nwe have two parameters instead of one, so we have two lifetimes:\n\nfn longest<'a, \u2018b>(x: &'a str, y: &'b str) -> &str {\n\nYou can see that the second rule doesn\u2019t apply because there is more\nthan one input lifetime. The third rule doesn\u2019t apply either, because longest\nis a function rather than a method, so none of the parameters are self. After\nworking through all three rules, we still haven\u2019t figured out what the return\ntype\u2019s lifetime is. This is why we got an error trying to compile the code in\nListing 10-21: the compiler worked through the lifetime elision rules but still\ncouldn't figure out all the lifetimes of the references in the signature.\n\nBecause the third rule really only applies in method signatures, we'll\nlook at lifetimes in that context next to see why the third rule means we\ndon\u2019t have to annotate lifetimes in method signatures very often.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 10.29,
                        "section_name": "Lifetime Annotations in Method Definitions",
                        "section_path": "./screenshots-images-2/chapter_10/section_29",
                        "images": [
                            "./screenshots-images-2/chapter_10/section_29/096645dc-6d9a-4ef7-a2f7-66af159c50c3.png",
                            "./screenshots-images-2/chapter_10/section_29/a6359e70-fd68-4f78-a44c-67cabf6dd3e7.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Lifetime Annotations in Method Definitions\n\nWhen we implement methods on a struct with lifetimes, we use the same\nsyntax as that of generic type parameters shown in Listing 10-11. Where we\ndeclare and use the lifetime parameters depends on whether they're related\nto the struct fields or the method parameters and return values.\n\nLifetime names for struct fields always need to be declared after the impl\nkeyword and then used after the struct\u2019s name, because those lifetimes are\npart of the struct\u2019s type.\n\nIn method signatures inside the imp] block, references might be\ntied to the lifetime of references in the struct\u2019s fields, or they might be\nindependent. In addition, the lifetime elision rules often make it so that\nlifetime annotations aren\u2019t necessary in method signatures. Let\u2019s look at\nsome examples using the struct named ImportantExcerpt that we defined in\nListing 10-25.\n\nFirst, we'll use a method named level whose only parameter is a refer-\nence to self and whose return value is an i32, which is not a reference to\nanything:\n\nimpl<'a> ImportantExcerpt<'a> {\nfn level(&self) -> 132 {\n\n3\n}\n\nThe lifetime parameter declaration after imp] and use after the type\nname is required, but we\u2019re not required to annotate the lifetime of the\nreference to self because of the first elision rule.\n\nHere is an example where the third lifetime elision rule applies:\n\nimpl<'a> ImportantExcerpt<'a> {\nfn announce_and_return_part(&self, announcement: &str) -> &str {\nprintln!(\"Attention please: {}\", announcement) ;\nself.part\n\nThere are two input lifetimes, so Rust applies the first lifetime elision\nrule and gives both &self and announcement their own lifetimes. Then, because\none of the parameters is &self, the return type gets the lifetime of &self, and\nall lifetimes have been accounted for.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 10.3,
                        "section_name": "The Static Lifetime",
                        "section_path": "./screenshots-images-2/chapter_10/section_30",
                        "images": [
                            "./screenshots-images-2/chapter_10/section_30/d1cc8e89-a0d1-4f44-9608-bb682108d2f3.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "The Static Lifetime\n\nOne special lifetime we need to discuss is \u2018static, which denotes the entire\nduration of the program. All string literals have the 'static lifetime, which\nwe can annotate as follows:\n\nlet s: &' static str = \"I have a static lifetime.\";\n\nThe text of this string is stored directly in the binary of your program,\nwhich is always available. Therefore, the lifetime of all string literals is \u2018static.\nYou might see suggestions to use the 'static lifetime in error messages.\nBut before specifying 'static as the lifetime for a reference, think about\nwhether the reference you have actually lives the entire lifetime of your\nprogram or not. You might consider whether you want it to live that long,\neven if it could. Most of the time, the problem results from attempting\nto create a dangling reference or a mismatch of the available lifetimes.\nIn such cases, the solution is fixing those problems, not specifying the\n\u2018static lifetime.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 10.31,
                        "section_name": "Generic Type Parameters, Trait Bounds, and Lifetimes Together",
                        "section_path": "./screenshots-images-2/chapter_10/section_31",
                        "images": [
                            "./screenshots-images-2/chapter_10/section_31/a46dcf21-a7f3-40cc-af54-ae8d3f1b05cc.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Generic Type Parameters, Trait Bounds, and Lifetimes Together\n\nLet's briefly look at the syntax of specifying generic type parameters, trait\nbounds, and lifetimes all in one function!\n\nuse std:: fmt: :Display;\nfn longest_with_an_announcement<'a, T>(x: &'a str, y: &'a str, ann: T) -> &'a\n\nstr\nwhere T: Display\n\n{\nprintln!(\"Announcement! {}\", ann);\nif x.len() > y.len() {\nx\n} else {\ny\n}\n}\n\nThis is the longest function from Listing 10-22 that returns the longer of\ntwo string slices. But now it has an extra parameter named ann of the generic\ntype T, which can be filled in by any type that implements the Display trait as\nspecified by the where clause. This extra parameter will be printed before the\nfunction compares the lengths of the string slices, which is why the Display\ntrait bound is necessary. Because lifetimes are a type of generic, the declara-\ntions of the lifetime parameter 'a and the generic type parameter T go in the\nsame list inside the angle brackets after the function name.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 10.32,
                        "section_name": "Summary",
                        "section_path": "./screenshots-images-2/chapter_10/section_32",
                        "images": [
                            "./screenshots-images-2/chapter_10/section_32/d29f3cbb-ed6e-4246-b760-9e039b43f5df.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Summary\n\nWe covered a lot in this chapter! Now that you know about generic type\nparameters, traits and trait bounds, and generic lifetime parameters, you're\nready to write code without repetition that works in many different situa-\ntions. Generic type parameters let you apply the code to different types.\nTraits and trait bounds ensure that even though the types are generic,\nthey'll have the behavior the code needs. You learned how to use lifetime\nannotations to ensure that this flexible code won't have any dangling refer-\nences. And all of this analysis happens at compile time, which doesn\u2019t affect\nruntime performance!\n\nBelieve it or not, there is much more to learn on the topics we discussed\nin this chapter: Chapter 17 discusses trait objects, which are another way\nto use traits. Chapter 19 covers more complex scenarios involving lifetime\nannotations as well as some advanced type system features. But next, you'll\nlearn how to write tests in Rust so you can make sure your code is working the\nway it should.\n",
                        "extracted-code": ""
                    }
                ]
            },
            {
                "chapter_id": 11,
                "chapter_name": "WRITING AUTOMATED TESTS",
                "chapter_path": "./screenshots-images-2/chapter_11",
                "sections": [
                    {
                        "section_id": 11.1,
                        "section_name": "WRITING AUTOMATED TESTS",
                        "section_path": "./screenshots-images-2/chapter_11/section_1",
                        "images": [
                            "./screenshots-images-2/chapter_11/section_1/738ddfd9-413c-4c5c-b12d-3f3335188056.png",
                            "./screenshots-images-2/chapter_11/section_1/78d6d9e2-9a5b-4eae-bb0a-e8662f9b3611.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "In his 1972 essay \u201cThe Humble Program-\nmer,\u201d Edsger W. Dijkstra said that \u201cProgram\ntesting can be a very effective way to show\nthe presence of bugs, but it is hopelessly inad-\nequate for showing their absence.\u201d That doesn\u2019t mean\nwe shouldn\u2019t try to test as much as we can!\n\nCorrectness in our programs is the extent to which our code does what\nwe intend it to do. Rust is designed with a high degree of concern about the\ncorrectness of programs, but correctness is complex and not easy to prove.\nRust\u2019s type system shoulders a huge part of this burden, but the type system\ncannot catch every kind of incorrectness. As such, Rust includes support for\nwriting automated software tests within the language.\n\nAs an example, say we write a function called add_two that adds 2 to what-\never number is passed to it. This function\u2019s signature accepts an integer as\na parameter and returns an integer as a result. When we implement and\ncompile that function, Rust does all the type checking and borrow check-\ning that you've learned so far to ensure that, for instance, we aren't passing\na String value or an invalid reference to this function. But Rust can\u2019t check\n\n\nthat this function will do precisely what we intend, which is return the\nparameter plus 2 rather than, say, the parameter plus 10 or the parameter\nminus 50! That\u2019s where tests come in.\n\nWe can write tests that assert, for example, that when we pass 3 to the\nadd_two function, the returned value is 5. We can run these tests whenever\nwe make changes to our code to make sure any existing correct behavior\nhas not changed.\n\nTesting is a complex skill: although we can\u2019t cover every detail about how\nto write good tests in one chapter, we'll discuss the mechanics of Rust\u2019s test-\ning facilities. We'll talk about the annotations and macros available to you\nwhen writing your tests, the default behavior and options provided for run-\nning your tests, and how to organize tests into unit tests and integration tests.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 11.2,
                        "section_name": "How to Write Tests",
                        "section_path": "./screenshots-images-2/chapter_11/section_2",
                        "images": [
                            "./screenshots-images-2/chapter_11/section_2/4ea4cc8c-0a03-44a9-adef-eb0c1f650142.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "How to Write Tests\n\nTests are Rust functions that verify that the non-test code is functioning in\nthe expected manner. The bodies of test functions typically perform these\nthree actions:\n\nSet up any needed data or state.\n\nN\n\nRun the code you want to test.\nAssert the results are what you expect.\nLet's look at the features Rust provides specifically for writing tests that\n\ntake these actions, which include the test attribute, a few macros, and the\nshould_panic attribute.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 11.3,
                        "section_name": "The Anatomy of a Test Function",
                        "section_path": "./screenshots-images-2/chapter_11/section_3",
                        "images": [
                            "./screenshots-images-2/chapter_11/section_3/0deed2f1-f451-4119-8bea-f0ca41f8d640.png",
                            "./screenshots-images-2/chapter_11/section_3/f7fbab75-6f0c-4725-a13b-00b0e59c3908.png",
                            "./screenshots-images-2/chapter_11/section_3/16fc5ffa-bc45-44d7-b202-18b9a50443ff.png",
                            "./screenshots-images-2/chapter_11/section_3/f0941ae6-feee-4c2a-99b1-e197a2af6ff1.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "The Anatomy of a Test Function\n\nAt its simplest, a test in Rust is a function that\u2019s annotated with the test\nattribute. Attributes are metadata about pieces of Rust code; one example\nis the derive attribute we used with structs in Chapter 5. To change a func-\ntion into a test function, add #[test] on the line before fn. When you run\nyour tests with the cargo test command, Rust builds a test runner binary\nthat runs the functions annotated with the test attribute and reports on\nwhether each test function passes or fails.\n\nWhen we make a new library project with Cargo, a test module with a\ntest function in it is automatically generated for us. This module helps you\nstart writing your tests so you don\u2019t have to look up the exact structure and\nsyntax of test functions every time you start a new project. You can add as\nmany additional test functions and as many test modules as you want!\n\nWe'll explore some aspects of how tests work by experimenting with the\ntemplate test generated for us without actually testing any code. Then we'll\nwrite some real-world tests that call some code that we've written and assert\nthat its behavior is correct.\n\nLet's create a new library project called adder:\n\n$ cargo new adder --lib\nCreated library \u201cadder\u201d project\n$ cd adder\n\nThe contents of the src/lib.rs file in your adder library should look like\nListing 11-1.\n\nsro/lib.rs #[cfg(test) ]\nmod tests {\n\u00a9 f[test]\nfn it_works() {\n\u00a9 assert_eq!(2 + 2, 4);\n}\n}\n\nListing 11-1: The test module and function generated automatically by cargo new\n\nFor now, let\u2019s ignore the top two lines and focus on the function to see\nhow it works. Note the #[test] annotation @: this attribute indicates this\nis a test function, so the test runner knows to treat this function as a test.\nWe could also have non-test functions in the tests module to help set up\ncommon scenarios or perform common operations, so we need to indicate\nwhich functions are tests by using the #[test] attribute.\n\nThe function body uses the assert_eq! macro @ to assert that 2 + 2\nequals 4. This assertion serves as an example of the format for a typical\ntest. Let\u2019s run it to see that this test passes.\n\nThe cargo test command runs all tests in our project, as shown in\nListing 11-2.\n$ cargo test\n\nCompiling adder v0.1.0 (file:///projects/adder)\nFinished dev [unoptimized + debuginfo] target(s) in 0.22 secs\nRunning target/debug/deps/adder-ce99bcc2479f4607\n\n@ running 1 test\n@ test tests::it_works ... ok\n\n@ test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n\u00a9 Doc-tests adder\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n\nlisting 11-2: The output from running the automatically generated test\n\nCargo compiled and ran the test. After the Compiling, Finished, and\nRunning lines is the line running 1 test @. The next line shows the name of\nthe generated test function, called it_works, and the result of running that\n\nsrc/lib.rs\n\nsrc/lib.rs\n\ntest, ok @. The overall summary of running the tests appears next. The\ntext test result: ok. \u00a9 means that all the tests passed, and the portion that\nreads 1 passed; 0 failed totals the number of tests that passed or failed.\n\nBecause we don\u2019t have any tests we\u2019ve marked as ignored, the summary\nshows 0 ignored. We also haven't filtered the tests being run, so the end of\nthe summary shows 0 filtered out. We'll talk about ignoring and filtering\nout tests in \u201cControlling How Tests Are Run\u201d on page 221.\n\nThe 0 measured statistic is for benchmark tests that measure performance.\nBenchmark tests are, as of this writing, only available in nightly Rust. See\nthe documentation about benchmark tests at https://doc.rust-lang.org/nightly/\nunstable-book/library-features/test.html to learn more.\n\nThe next part of the test output, which starts with Doc-tests adder @, is\nfor the results of any documentation tests. We don\u2019t have any documentation\ntests yet, but Rust can compile any code examples that appear in our API doc-\numentation. This feature helps us keep our docs and our code in sync! We'll\ndiscuss how to write documentation tests in \u201cDocumentation Comments as\nTests\u201d on page 295. For now, we'll ignore the Doc-tests output.\n\nLet's change the name of our test to see how that changes the test output.\nChange the it_works function to a different name, such as exploration, like so:\n\nfn exploration() {\n\nsrt eal(2 +2. 4\nassert_eq!(2 + 2, 4);\n\nThen run cargo test again. The output now shows exploration instead of\nit_works:\n\nrunning 1 test\ntest tests::exploration ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n\nLet\u2019s add another test, but this time we'll make a test that fails! Tests\nfail when something in the test function panics. Each test is run in a new\nthread, and when the main thread sees that a test thread has died, the test\nis marked as failed. We talked about the simplest way to cause a panic in\nChapter 9, which is to call the panic! macro. Enter the new test, another, so\nyour src/lib.rs file looks like Listing 11-3.\n\n\n#[test]\nfn another() {\n\npanic!(\"Make this test fail\");\n}\n\nListing 11-3: Adding a second test that will fail because we call the panic! macro\n\nRun the tests again using cargo test. The output should look like\nListing 11-4, which shows that our exploration test passed and another failed.\n\nrunning 2 tests\ntest tests::exploration ... ok\ntest tests::another ... FAILED\n\nfailures:\n\n---- tests::another stdout ----\nthread \u2018tests::another' panicked at 'Make this test fail\u2019, src/lib.rs:10:8\nnote: Run with ~RUST_BACKTRACE=1\u00b0 for a backtrace.\n\nfailures:\ntests: :another\n\ntest result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out\n\nerror: test failed\n\nListing 11-4: Test results when one test passes and one test fails\n\nInstead of ok, the line test tests: :another shows FAILED \u00ae. Two new sec-\ntions appear between the individual results and the summary: the first\nsection @ displays the detailed reason for each test failure. In this case,\nanother failed because it panicked at 'Make this test fail', which happened\non line 10 in the src/lib.rs file. The next section \u00a9 lists just the names of\nall the failing tests, which is useful when there are lots of tests and lots of\ndetailed failing test output. We can use the name of a failing test to run\njust that test to more easily debug it; we'll talk more about ways to run\ntests in \u201cControlling How Tests Are Run\u201d on page 221.\n\nThe summary line displays at the end @: overall, our test result is FAILED.\nWe had one test pass and one test fail.\n\nNow that you've seen what the test results look like in different scenarios,\nlet's look at some macros other than panic! that are useful in tests.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 11.4,
                        "section_name": "Checking Results with the assert! Macro",
                        "section_path": "./screenshots-images-2/chapter_11/section_4",
                        "images": [
                            "./screenshots-images-2/chapter_11/section_4/25fe3a70-635c-4ef5-b508-8be4754be3b2.png",
                            "./screenshots-images-2/chapter_11/section_4/3e0fde6e-983b-4452-93b0-9a9b5234ab2d.png",
                            "./screenshots-images-2/chapter_11/section_4/2a039513-1cef-4a6a-a748-03062cfda2ef.png",
                            "./screenshots-images-2/chapter_11/section_4/8374f758-91f7-435f-b64a-532bcbba7e9d.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Checking Results with the assert! Macro\n\nThe assert! macro, provided by the standard library, is useful when you want\nto ensure that some condition in a test evaluates to true. We give the assert!\nmacro an argument that evaluates to a Boolean. If the value is true, assert!\ndoes nothing and the test passes. If the value is false, the assert! macro calls\nthe panic! macro, which causes the test to fail. Using the assert! macro helps\nus check that our code is functioning in the way we intend.\n\nsrc/lib.rs\n\nsrc/lib.rs\n\nIn Listing 5-15 on page 95, we used a Rectangle struct and a can_hold\nmethod, which are repeated here in Listing 11-5. Let\u2019s put this code in the\nsrc/lib.rs file and write some tests for it using the assert! macro.\n\n#[derive(Debug) ]\n\npub struct Rectangle {\nlength: u32,\nwidth: u32,\n\n}\n\nimpl Rectangle {\npub fn can_hold(&self, other: &Rectangle) -> bool {\nself.length > other.length && self.width > other.width\n}\n\n}\n\nListing 11-5: Using the Rectangle struct and its can_hold method from Chapter 5\n\nThe can_hold method returns a Boolean, which means it\u2019s a perfect use\ncase for the assert! macro. In Listing 11-6, we write a test that exercises the\ncan_hold method by creating a Rectangle instance that has a length of 8 anda\nwidth of 7 and asserting that it can hold another Rectangle instance that has\na length of 5 and a width of 1.\n\n#[cfg(test)]\nmod tests {\n@ use super: :*;\n\n#[test]\n\u00a9 fn larger_can_hold_smaller() {\n\u00a9 let larger = Rectangle { length: 8, width: 7 };\nlet smaller = Rectangle { length: 5, width: 1 };\n\n\u00a9 assert! (larger.can_hold(&smaller)) ;\n\n}\n}\n\nListing 11-6: A test for can_hold that checks whether a larger rectangle can indeed hold a\nsmaller rectangle\n\nNote that we've added a new line inside the tests module: use super: :*; \u00a9.\nThe tests module is a regular module that follows the usual visibility rules\nwe covered in \u201cPaths for Referring to an Item in the Module Tree\u201d on\npage 115. Because the tests module is an inner module, we need to bring\nthe code under test in the outer module into the scope of the inner module.\nWe use a glob here so anything we define in the outer module is available to\nthis tests module.\n\nWe've named our test larger_can_hold_smaller @, and we've created the\ntwo Rectangle instances that we need \u00ae. Then we called the assert! macro\nand passed it the result of calling larger.can_hold(&smaller) \u00ae. This expres-\nsion is supposed to return true, so our test should pass. Let\u2019s find out!\n\nsrc/lib.rs\n\nrunning 1 test\ntest tests::larger_can_hold_smaller ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n\nIt does pass! Let\u2019s add another test, this time asserting that a smaller\nrectangle cannot hold a larger rectangle:\n\n#[test]\n\nfn smaller_cannot_hold_larger() {\nlet larger = Rectangle { length: 8, width: 7 };\nlet smaller = Rectangle { length: 5, width: 1 };\n\nassert! (!smaller.can_hold(&larger)) ;\n\nBecause the correct result of the can_hold function in this case is false,\nwe need to negate that result before we pass it to the assert! macro. As a\nresult, our test will pass if can_hold returns false:\n\nrunning 2 tests\ntest tests::smaller_cannot_hold larger ... ok\ntest tests::larger_can_hold_smaller ... ok\n\ntest result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n\nTwo tests that pass! Now let\u2019s see what happens to our test results when\nwe introduce a bug in our code. Let\u2019s change the implementation of the\ncan_hold method by replacing the greater than sign with a less than sign\nwhen it compares the lengths:\n\n{{ --snip--\n\nimpl Rectangle {\npub fn can hold(&self, other: &Rectangle) -> bool {\nself.length < other.length && self.width > other.width\n}\n\nRunning the tests now produces the following:\n\nrunning 2 tests\ntest tests::smaller cannot_hold larger ... ok\ntest tests::larger_can_hold smaller ... FAILED\n\nfailures:\n\n---- tests::larger_can_hold_smaller stdout ----\nthread 'tests::larger_can_hold_smaller\u2019 panicked at \u2018assertion failed:\nlarger.can_hold(&smaller)', src/lib.rs:22:8\n\nnote: Run with ~RUST_BACKTRACE=1\u00b0 for a backtrace.\n\nfailures:\ntests::larger_can_hold_smaller\n\ntest result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out\n\nOur tests caught the bug! Because larger. length is 8 and smaller. length is 5,\nthe comparison of the lengths in can_hold now returns false: 8 is not less than 5.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 11.5,
                        "section_name": "Testing Equality with the assert_eq! and assert_ne! Macros",
                        "section_path": "./screenshots-images-2/chapter_11/section_5",
                        "images": [
                            "./screenshots-images-2/chapter_11/section_5/e1c71ffb-c9be-4277-8320-9281fcd6f1fb.png",
                            "./screenshots-images-2/chapter_11/section_5/040c755e-b01c-4d92-9ed1-d8f55c6d078a.png",
                            "./screenshots-images-2/chapter_11/section_5/5132d67e-54db-4d0e-b201-6ad7049daa2a.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/lib.rs\n\nTesting Equality with the assert_eq! and assert_ne! Macros\n\nA common way to test functionality is to compare the result of the code\nunder test to the value you expect the code to return to make sure they're\nequal. You could do this using the assert! macro and passing it an expression\nusing the == operator. However, this is such a common test that the standard\nlibrary provides a pair of macros\u2014assert_eq! and assert_ne!\u2014to perform this\ntest more conveniently. These macros compare two arguments for equality or\ninequality, respectively. They'll also print the two values if the assertion fails,\nwhich makes it easier to see why the test failed; conversely, the assert! macro\nonly indicates that it got a false value for the == expression, not the values that\nlead to the false value.\n\nIn Listing 11-7, we write a function named add_two that adds 2 to its\nparameter and returns the result. Then we test this function using the\nassert_eq! macro.\n\npub fn add_two(a: i32) -> i32 {\n\na+2\n}\n#[cfg(test)]\nmod tests {\nuse super::*;\n#[test]\nfn it_adds_two() {\nassert_eq!(4, add_two(2));\n}\n}\n\nListing 11-7: Testing the function add_two using the assert_eq! macro\n\nLet\u2019s check that it passes!\n\nrunning 1 test\ntest tests::it_adds two ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n\nThe first argument we gave to the assert_eq! macro, 4, is equal to the\nresult of calling add_two(2). The line for this test is test tests::it_adds_two\n. ok, and the ok text indicates that our test passed!\nLet's introduce a bug into our code to see what it looks like when a test\nthat uses assert_eq! fails. Change the implementation of the add_two func-\ntion to instead add 3:\n\nRun the tests again:\n\nrunning 1 test\ntest tests::it_adds_two ... FAILED\n\nfailures:\n\n---- tests::it_adds_two stdout ----\n@ thread \u2018tests::it_adds_two' panicked at \u2018assertion failed:\n\u201c(left == right)\n@ left: \u201c4,\n@ right: ~5\u00b0', src/lib.rs:11:8\nnote: Run with \u201cRUST_BACKTRACE=1\u00b0 for a backtrace.\n\nfailures:\ntests::it_adds two\n\ntest result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out\n\nOur test caught the bug! The it_adds_two test failed, displaying the mes-\nsage assertion failed: \u201c(left == right)\u201d \u00ae and showing that left was 4 @\nand right was 5 \u00a9. This message is useful and helps us start debugging: it\nmeans the left argument to assert_eq! was 4 but the right argument, where\nwe had add_two(2), was 5.\n\nNote that in some languages and test frameworks, the parameters to\nthe functions that assert two values are equal are called expected and actual,\nand the order in which we specify the arguments matters. However, in Rust,\nthey're called left and right, and the order in which we specify the value\nwe expect and the value that the code under test produces doesn\u2019t matter.\nWe could write the assertion in this test as assert_eq!(add_two(2), 4), which\nwould result in a failure message that displays assertion failed: \u201c(left ==\nright)* and that left was 5 and right was 4.\n\nThe assert_ne! macro will pass if the two values we give it are not equal\nand fail if they're equal. This macro is most useful for cases when we're not\nsure what a value will be, but we know what the value definitely won't be if our\ncode is functioning as we intend. For example, if we're testing a function that\nis guaranteed to change its input in some way, but the way in which the input is\nchanged depends on the day of the week that we run our tests, the best thing\nto assert might be that the output of the function is not equal to the input.\n\nUnder the surface, the assert_eq! and assert_ne! macros use the operators\n== and !=, respectively. When the assertions fail, these macros print their argu-\nments using debug formatting, which means the values being compared must\nimplement the PartialEq and Debug traits. All the primitive types and most of\nthe standard library types implement these traits. For structs and enums that\nyou define, you'll need to implement Partial\u00a3g to assert that values of those\ntypes are equal or not equal. You'll need to implement Debug to print the values\nwhen the assertion fails. Because both traits are derivable traits, as mentioned\nin Listing 5-12 on page 91, this is usually as straightforward as adding the\n#[derive(PartialEq, Debug)] annotation to your struct or enum definition. See\nAppendix C for more details about these and other derivable traits.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 11.6,
                        "section_name": "Adding Custom Failure Messages",
                        "section_path": "./screenshots-images-2/chapter_11/section_6",
                        "images": [
                            "./screenshots-images-2/chapter_11/section_6/7a924208-f778-4501-89e4-f42b024a040c.png",
                            "./screenshots-images-2/chapter_11/section_6/170b6eb4-17d1-4876-8163-a7696dc858c0.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "sre/lib.rs\n\nAdding Custom Failure Messages\n\nYou can also add a custom message to be printed with the failure message\nas optional arguments to the assert!, assert_eq!, and assert_ne! macros.\nAny arguments specified after the one required argument to assert! or\nthe two required arguments to assert_eq! and assert_ne! are passed along\nto the format! macro (discussed in \u201cConcatenation with the + Operator\nor the format! Macro\u201d on page 139), so you can pass a format string that\ncontains {} placeholders and values to go in those placeholders. Custom\nmessages are useful to document what an assertion means; when a test\nfails, you'll have a better idea of what the problem is with the code.\n\nFor example, let\u2019s say we have a function that greets people by name and\nwe want to test that the name we pass into the function appears in the output:\n\npub fn greeting(name: &str) -> String {\nformat! (\"Hello {}!\", name)\n\n}\n#[cfg(test)]\nmod tests {\nuse super::*;\n#[test]\nfn greeting contains name() {\nlet result = greeting(\"Carol\");\nassert! (result.contains(\"Carol\"));\n}\n}\n\nThe requirements for this program haven't been agreed upon yet, and\nwe're pretty sure the Hello text at the beginning of the greeting will change.\n\nWe decided we don\u2019t want to have to update the test when the requirements\nchange, so instead of checking for exact equality to the value returned from\nthe greeting function, we'll just assert that the output contains the text of the\ninput parameter.\n\nLet's introduce a bug into this code by changing greeting to not include\nname to see what this test failure looks like:\n\npub fn greeting(name: &str) -> String {\nString: :from(\"Hello!\")\n}\n\nRunning this test produces the following:\n\nrunning 1 test\ntest tests::greeting_ contains name ... FAILED\n\nfailures:\n\n---- tests::greeting contains_name stdout ----\n\nthread 'tests::greeting contains name\u2019 panicked at \u2018assertion failed:\nresult.contains(\"Carol\")', src/lib.rs:12:8\nnote: Run with ~RUST_BACKTRACE=1\u00b0 for a backtrace.\n\nfailures:\ntests: :greeting_contains_name\n\nThis result just indicates that the assertion failed and which line the\nassertion is on. A more useful failure message in this case would print the\nvalue we got from the greeting function. Let's change the test function,\ngiving it a custom failure message made from a format string with a place-\nholder filled in with the actual value we got from the greeting function:\n\n[test]\nfn greeting contains_name() {\nlet result = greeting(\"Carol\");\nassert! (\nresult.contains(\"Carol\"),\n\"Greeting did not contain name, value was \u201c{}\u00b0\", result\n\n)s\n\nNow when we run the test, we'll get a more informative error message:\n\n---- tests::greeting contains_name stdout ----\n\nthread 'tests::greeting_contains_name' panicked at \u2018Greeting did not\ncontain name, value was \u201cHello!~', src/lib.rs:12:8\nnote: Run with \u201cRUST_BACKTRACE=1\u00b0 for a backtrace.\n\nWe can see the value we actually got in the test output, which would\nhelp us debug what happened instead of what we were expecting to happen.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 11.7,
                        "section_name": "Checking for Panics with should_panic",
                        "section_path": "./screenshots-images-2/chapter_11/section_7",
                        "images": [
                            "./screenshots-images-2/chapter_11/section_7/3691e3b0-6af6-4b11-9a6b-a3838882129e.png",
                            "./screenshots-images-2/chapter_11/section_7/0ea12a5d-e670-4c2d-b3ab-6ab1988bbd2c.png",
                            "./screenshots-images-2/chapter_11/section_7/aa72602e-c0db-4f95-927a-860c38999077.png",
                            "./screenshots-images-2/chapter_11/section_7/b41796cf-a9c6-4b52-99b7-2be86b221f9d.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/lib.rs\n\nChecking for Panics with should_panic\n\nIn addition to checking that our code returns the correct values we expect,\nit\u2019s also important to check that our code handles error conditions as we\nexpect. For example, consider the Guess type that we created in Listing 9-10\non page 168. Other code that uses Guess depends on the guarantee that\nGuess instances will contain only values between 1 and 100. We can write a\ntest that ensures that attempting to create a Guess instance with a value out-\nside that range panics.\n\nWe do this by adding another attribute, should_panic, to our test func-\ntion. This attribute makes a test pass if the code inside the function panics;\nthe test will fail if the code inside the function doesn\u2019t panic.\n\nListing 11-8 shows a test that checks that the error conditions of\nGuess: :new happen when we expect them to.\n\npub struct Guess {\nvalue: i32,\n}\n\nimpl Guess {\npub fn new(value: i32) -> Guess {\nif value < 1 || value > 100 {\npanic!(\"Guess value must be between 1 and 100, got {}.\", value);\n}\n\nGuess {\nvalue\n}\n\n}\n\n#[cfg(test)]\nmod tests {\nuse super::*;\n\n#[test]\n\n#[should_panic]\n\nfn greater_than_100() {\nGuess: :new(200) ;\n\n}\n\n}\n\nListing 11-8: Testing that a condition will cause a panic!\n\nWe place the #[should_panic] attribute after the #[test] attribute and before\nthe test function it applies to. Let\u2019s look at the result when this test passes:\n\nrunning 1 test\ntest tests: :greater_than_100 ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n\nsrc/lib.rs\n\nLooks good! Now let's introduce a bug in our code by removing the\n\ncondition that the new function will panic if the value is greater than 100:\n\nsnip\n\nGuess {\n\npub fn new(value: i132) -> Guess {\nif value<1 {\n\npanic! ( must be between 1 and 100, got {}.\", value);\n\nWhen we run the test in Listing 11-8, it will fail:\n\nrunning 1 test\ntest tests::greater_than_100 ... FAILED\n\nfailures:\n\nfailures:\ntests: :greater_than_100\n\ntest result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out\n\nWe don\u2019t get a very helpful message in this case, but when we look at\nthe test function, we see that it\u2019s annotated with #[should_panic]. The failure\nwe got means that the code in the test function did not cause a panic.\n\nTests that use should_panic can be imprecise because they only indicate\nthat the code has caused some panic. A should_panic test would pass even if\nthe test panics for a different reason than the one we were expecting to hap-\npen. To make should _panic tests more precise, we can add an optional expected\nparameter to the should_panic attribute. The test harness will make sure that\nthe failure message contains the provided text. For example, consider the\nmodified code for Guess in Listing 11-9 where the new function panics with dif-\nferent messages depending on whether the value is too small or too large.\n\npub fn new(value: 132) -> Guess {\nif value <1 {\npanic!(\"Guess value must be greater than or equal to 1, got {}.\",\nvalue) ;\n} else if value > 100 {\npanic!(\"Guess value must be less than or equal to 100, got {}.\",\nvalue);\n\nGuess {\n\nvalue\n\nuse super: :*;\n#[test]\n#[should_panic(expected = \"Guess value must be less than or equal to 100\")]\nfn r_than_100() {\n\nListing 11-9: Testing that a condition will cause a panic! with a particular panic message\n\nThis test will pass because the value we put in the should_panic attribute\u2019s\nexpected parameter is a substring of the message that the Guess: :new function\npanics with. We could have specified the entire panic message that we expect,\nwhich in this case would be Guess value must be less than or equal to 100, got\n200. What you choose to specify in the expected parameter for should_panic\ndepends on how much of the panic message is unique or dynamic and how\nprecise you want your test to be. In this case, a substring of the panic message\nis enough to ensure that the code in the test function executes the else if\nvalue > 100 case.\n\nTo see what happens when a should_panic test with an expected message\nfails, let\u2019s again introduce a bug into our code by swapping the bodies of\nthe if value < 1 and the else if value > 100 blocks:\n\nif value < 1 {\n\npanic!(\"Guess value must be less than or equal to 100, got {}.\", value);\n} else if value > 100 {\n\npanic!(\"Guess value must be greater than or equal to 1, got {}.\", value);\n}\n\nThis time when we run the should_panic test, it will fail:\n\nrunning 1 test\ntest tests: :greater_than_100 ... FAILED\n\nfailures:\n\n---- tests::greater_than_100 stdout ----\n\nthread \u2018tests::greater_than_100' panicked at \u2018Guess value must be\ngreater than or equal to 1, got 200.', src/lib.rs:11:12\nnote: Run with ~RUST_BACKTRACE=1\u00b0 for a backtrace.\nnote: Panic did not include expected string 'Guess value must be less than or\nequal to 100.\"\n\nfailures:\ntests: :greater_than_100\n\ntest result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out\n\nThe failure message indicates that this test did indeed panic as we\nexpected, but the panic message did not include the expected string 'Guess\nvalue must be less than or equal to 100'. The panic message that we did get\nin this case was Guess value must be greater than or equal to 1, got 200. Now\nwe can start figuring out where our bug is!\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 11.8,
                        "section_name": "Using Result<T, E> in Tests",
                        "section_path": "./screenshots-images-2/chapter_11/section_8",
                        "images": [
                            "./screenshots-images-2/chapter_11/section_8/42d8433e-63ae-4c81-8d3f-ef4e1bd7b1c3.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Using Result<T, E> in Tests\n\nSo far, we've written tests that panic when they fail. We can also write tests\nthat use Result<T, \u00a3>! Here\u2019s the test from Listing 11-1, rewritten to use\nResult<T, E> and return an Err instead of panicking:\n\n#[cfg(test)]\nmod tests {\n#[test]\nfn it_works() -> Result<(), String> {\nif2+2-=4{\nOk(())\n} else {\nErr(String::from(\"two plus two does not equal four\"))\n}\n\nThe it_works function now has a return type, Result<(), String>. In the\nbody of the function, rather than calling the assert_eq! macro, we return\n0k(()) when the test passes and an Err with a String inside when the test fails.\n\nWriting tests so they return a Result<T, E> enables you to use the question\nmark operator in the body of tests, which can be a convenient way to write\ntests that should fail if any operation within them returns an Err variant.\n\nYou can\u2019t use the #[should_panic] annotation on tests that use Result<T, E>.\nInstead, you should return an Err value directly when the test should fail.\n\nNow that you know several ways to write tests, let\u2019s look at what is hap-\npening when we run our tests and explore the different options we can use\nwith cargo test.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 11.9,
                        "section_name": "Controlling How Tests Are Run",
                        "section_path": "./screenshots-images-2/chapter_11/section_9",
                        "images": [
                            "./screenshots-images-2/chapter_11/section_9/cf487cfc-d324-4759-b0a4-755e16137bab.png",
                            "./screenshots-images-2/chapter_11/section_9/b2445739-4593-4bbd-899c-e94df00a1072.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Controlling How Tests Are Run\n\nJust as cargo run compiles your code and then runs the resulting binary, cargo\ntest compiles your code in test mode and runs the resulting test binary. You\ncan specify command line options to change the default behavior of cargo\ntest. For example, the default behavior of the binary produced by cargo test\nis to run all the tests in parallel and capture output generated during test\n\nruns, preventing the output from being displayed and making it easier to\nread the output related to the test results.\n\nSome command line options go to cargo test, and some go to the result-\ning test binary. To separate these two types of arguments, you list the argu-\nments that go to cargo test followed by the separator -- and then the ones\nthat go to the test binary. Running cargo test --help displays the options\nyou can use with cargo test, and running cargo test -- --help displays the\noptions you can use after the separator --.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 11.1,
                        "section_name": "Running Tests in Parallel or Consecutively",
                        "section_path": "./screenshots-images-2/chapter_11/section_10",
                        "images": [
                            "./screenshots-images-2/chapter_11/section_10/12fd1796-2fcc-4fd7-bb58-19a5f86ad006.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Running Tests in Parallel or Consecutively\n\nWhen you run multiple tests, by default they run in parallel using threads.\nThis means the tests will finish running faster so you can get feedback\nquicker on whether or not your code is working. Because the tests are run-\nning at the same time, make sure your tests don\u2019t depend on each other\nor on any shared state, including a shared environment, such as the cur-\nrent working directory or environment variables.\n\nFor example, say each of your tests runs some code that creates a file\non disk named test-output.txt and writes some data to that file. Then each\ntest reads the data in that file and asserts that the file contains a particu-\nlar value, which is different in each test. Because the tests run at the same\ntime, one test might overwrite the file between when another test writes and\nreads the file. The second test will then fail, not because the code is incor-\nrect but because the tests have interfered with each other while running\nin parallel. One solution is to make sure each test writes to a different file;\nanother solution is to run the tests one at a time.\n\nIf you don\u2019t want to run the tests in parallel or if you want more\nfine-grained control over the number of threads used, you can send the\n--test-threads flag and the number of threads you want to use to the test\nbinary. Take a look at the following example:\n\n$ cargo test -- --test-threads=1\n\nWe set the number of test threads to 1, telling the program not to use\nany parallelism. Running the tests using one thread will take longer than\nrunning them in parallel, but the tests won't interfere with each other if\nthey share state.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 11.11,
                        "section_name": "Showing Function Output",
                        "section_path": "./screenshots-images-2/chapter_11/section_11",
                        "images": [
                            "./screenshots-images-2/chapter_11/section_11/075259e1-65a2-412c-98c0-9b349dc6f46e.png",
                            "./screenshots-images-2/chapter_11/section_11/70d13b20-0058-4bb6-b829-f7b86100a14c.png",
                            "./screenshots-images-2/chapter_11/section_11/7d494efe-8d14-49cb-83ae-fb47d262b1aa.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/lib.rs\n\nShowing Function Output\n\nBy default, if a test passes, Rust\u2019s test library captures anything printed\nto standard output. For example, if we call println! in a test and the test\npasses, we won't see the println! output in the terminal; we'll see only the\nline that indicates the test passed. If a test fails, we'll see whatever was\nprinted to standard output with the rest of the failure message.\n\nAs an example, Listing 11-10 has a silly function that prints the value of\nits parameter and returns 10, as well as a test that passes and a test that fails.\n\nfn prints_and_returns_10(a: 132) -> 132 {\nprintln!(\"I got the value {}\", a);\n10\n\n}\n\n#[cfg(test)]\nmod tests {\nuse super::*;\n\n#[test]\n\nfn this_test_will_pass() {\nlet value = prints_and_returns_10(4);\nassert_eq!(10, value);\n\n#[test]\n\nfn this_test_will fail() {\nlet value = prints_and_returns_10(8);\nassert_eq!(5, value);\n\n}\n\nListing 11-10: Tests for a function that calls print1n!\n\nWhen we run these tests with cargo test, we'll see the following output:\n\nrunning 2 tests\ntest tests::this_test_will_pass ... ok\ntest tests::this_test_will fail ... FAILED\n\nfailures:\n\n---- tests::this_test_will fail stdout ----\n@ I got the value 8\nthread 'tests::this_test_will fail' panicked at \u2018assertion failed: \u201c(left ==\nright)~\nleft: \u201c5\u00b0,\nright: \u201c10\u00b0', src/lib.rs:19:8\nnote: Run with ~RUST_BACKTRACE=1\u00b0 for a backtrace.\n\nfailures:\ntests::this_test_will fail\n\ntest result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out\n\nNote that nowhere in this output do we see I got the value 4, which is\nwhat is printed when the test that passes runs. That output has been cap-\ntured. The output from the test that failed, I got the value 8 0, appears in\nthe section of the test summary output, which also shows the cause of the\ntest failure.\n\nIf we want to see printed values for passing tests as well, we can disable\nthe output capture behavior by using the --nocapture flag:\n\n$ cargo test -- --nocapture\n\nWhen we run the tests in Listing 11-10 again with the --nocapture flag,\nwe see the following output:\n\nrunning 2 tests\nI got the value 4\nI got the value 8\ntest tests::this_test_will pass ... ok\nthread \u2018tests::this_test_will fail\u2019 panicked at \u2018assertion failed: \u201c(left ==\nright)\u201d\nleft: \u201cS\u2019,\nright: ~10\u00b0', src/lib.rs:19:8\nnote: Run with ~RUST_BACKTRACE=1\u00b0 for a backtrace.\ntest tests::this_test_will fail ... FAILED\n\nfailures:\n\nfailures:\ntests::this_test_will_ fail\n\ntest result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out\n\nNote that the output for the tests and the test results are interleaved;\nthe reason is that the tests are running in parallel, as we talked about in the\nprevious section. Try using the --test-threads=1 option and the --nocapture\nflag and see what the output looks like then!\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 11.12,
                        "section_name": "Running a Subset of Tests by Name",
                        "section_path": "./screenshots-images-2/chapter_11/section_12",
                        "images": [
                            "./screenshots-images-2/chapter_11/section_12/4e02ee32-11ca-4a0a-91e9-8b7279f77fdd.png",
                            "./screenshots-images-2/chapter_11/section_12/9ac005cc-d72e-4f88-8d94-e4ccc38fc964.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/lib.rs\n\nRunning a Subset of Tests by Name\n\nSometimes, running a full test suite can take a long time. If you're working\non code in a particular area, you might want to run only the tests pertain-\ning to that code. You can choose which tests to run by passing cargo test the\nname or names of the test(s) you want to run as an argument.\n\nTo demonstrate how to run a subset of tests, we'll create three tests for\nour add_two function, as shown in Listing 11-11, and choose which ones to run.\n\npub fn add_two(a: i32) -> i32 {\na+2\n}\n\n#[cfg(test)]\nmod tests {\nuse super: :*;\n\n#[test]\n\nfn add_two_and_two() {\nassert_eq!(4, add_two(2));\n\n}\n\n#[test]\nfn add_three_and_two() {\nassert_eq!(5, add_two(3));\n\n#[test]\n\nfn one_hundred() {\nassert_eq!(102, add_two(100));\n\n}\n\n}\n\nListing 11-1]: Three tests with three different names\n\nIf we run the tests without passing any arguments, as we saw earlier, all\nthe tests will run in parallel:\n\nrunning 3 tests\n\ntest tests::add_two_and_two ... ok\ntest tests::add_three_and_two ... ok\ntest tests::one_hundred ... ok\n\ntest result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 11.13,
                        "section_name": "Running Single Tests",
                        "section_path": "./screenshots-images-2/chapter_11/section_13",
                        "images": [
                            "./screenshots-images-2/chapter_11/section_13/2f0d07c7-9bf9-4663-ba5b-215d584e2ccd.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Running Single Tests\n\nWe can pass the name of any test function to cargo test to run only that test:\n\n$ cargo test one_hundred\nFinished dev [unoptimized + debuginfo] target(s) in 0.0 secs\nRunning target/debug/deps/adder-06a75b4a1f2515e9\n\nrunning 1 test\ntest tests::one_hundred ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out\n\nOnly the test with the name one_hundred ran; the other two tests didn\u2019t\nmatch that name. The test output lets us know we had more tests than what\nthis command ran by displaying 2 filtered out at the end of the summary line.\n\nWe can\u2019t specify the names of multiple tests in this way; only the first\nvalue given to cargo test will be used. But there is a way to run multiple tests.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 11.14,
                        "section_name": "Filtering to Run Multiple Tests",
                        "section_path": "./screenshots-images-2/chapter_11/section_14",
                        "images": [
                            "./screenshots-images-2/chapter_11/section_14/9aab530f-3639-458d-b763-c3d8015cb79d.png",
                            "./screenshots-images-2/chapter_11/section_14/be2d0589-704b-4184-81c2-1ed43dc7766f.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Filtering to Run Multiple Tests\n\nWe can specify part of a test name, and any test whose name matches that\nvalue will be run. For example, because two of our tests\u2019 names contain add,\nwe can run those two by running cargo test add:\n\n$ cargo test add\nFinished dev [unoptimized + debuginfo] target(s) in 0.0 secs\nRunning target/debug/deps/adder-06a75b4a1f2515e9\n\nrunning 2 tests\ntest tests::add_two_and_two ... ok\ntest tests::add_three_and_two ... ok\n\ntest result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out\n\nThis command ran all tests with add in the name and filtered out the\ntest named one_hundred. Also note that the module in which tests appear\nbecomes part of the test\u2019s name, so we can run all the tests in a module by\nfiltering on the module\u2019s name.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 11.15,
                        "section_name": "Ignoring Some Tests Unless Specifically Requested",
                        "section_path": "./screenshots-images-2/chapter_11/section_15",
                        "images": [
                            "./screenshots-images-2/chapter_11/section_15/d17f74c8-03b1-46c0-b723-ac79a05fb6d3.png",
                            "./screenshots-images-2/chapter_11/section_15/bb265ea9-f842-4d38-84df-bf02a020b57b.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/lib.rs\n\nIgnoring Some Tests Unless Specifically Requested\n\nSometimes a few specific tests can be very time-consuming to execute, so\nyou might want to exclude them during most runs of cargo test. Rather\nthan listing as arguments all tests you do want to run, you can instead anno-\ntate the time-consuming tests using the ignore attribute to exclude them, as\nshown here:\n\n#[test]\n\nfn it_works() {\nassert_eq!(2 + 2, 4);\n\n}\n\n#[test]\n#[ ignore]\nfn expensive_test() {\n// code that takes an hour to run\n}\n\nAfter #[test], we add the #[ignore] line to the test we want to exclude.\nNow when we run our tests, it_works runs, but expensive_test doesn\u2019t:\n\n$ cargo test\nCompiling adder v0.1.0 (file:///projects/adder)\nFinished dev [unoptimized + debuginfo] target(s) in 0.24 secs\nRunning target/debug/deps/adder-ce99bcc2479f4607\n\nrunning 2 tests\ntest expensive_test ... ignored\ntest it_works ... ok\n\ntest result: ok. 1 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out\n\nThe expensive_test function is listed as ignored. If we want to run only\nthe ignored tests, we can use cargo test -- --ignored:\n\n$ cargo test -- --ignored\nFinished dev [unoptimized + debuginfo] target(s) in 0.0 secs\nRunning target/debug/deps/adder-ce99bcc2479f4607\n\nrunning 1 test\ntest expensive test ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out\n\nBy controlling which tests run, you can make sure your cargo test results\nwill be fast. When you're at a point where it makes sense to check the results\nof the ignored tests and you have time to wait for the results, you can run cargo\ntest -- --ignored instead.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 11.16,
                        "section_name": "Test Organization",
                        "section_path": "./screenshots-images-2/chapter_11/section_16",
                        "images": [
                            "./screenshots-images-2/chapter_11/section_16/249e3ce5-2c06-40e1-af38-b4b3e6cdfe21.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Test Organization\n\nAs mentioned at the start of the chapter, testing is a complex discipline,\nand different people use different terminology and organization. The Rust\ncommunity thinks about tests in terms of two main categories: unit tests and\nintegration tests. Unit tests are small and more focused, testing one module\nin isolation at a time, and can test private interfaces. Integration tests are\nentirely external to your library and use your code in the same way any\nother external code would, using only the public interface and potentially\nexercising multiple modules per test.\n\nWriting both kinds of tests is important to ensure that the pieces of\nyour library are doing what you expect them to, separately and together.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 11.17,
                        "section_name": "Unit Tests",
                        "section_path": "./screenshots-images-2/chapter_11/section_17",
                        "images": [
                            "./screenshots-images-2/chapter_11/section_17/b70b8715-8fb3-47e9-a575-2bea6d8ced4c.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Unit Tests\n\nThe purpose of unit tests is to test each unit of code in isolation from the rest\nof the code to quickly pinpoint where code is and isn\u2019t working as expected.\nYou'll put unit tests in the src directory in each file with the code that they're\ntesting. The convention is to create a module named tests in each file to con-\ntain the test functions and to annotate the module with cfg(test).\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 11.18,
                        "section_name": "The Tests Module and #[cfg(test)]",
                        "section_path": "./screenshots-images-2/chapter_11/section_18",
                        "images": [
                            "./screenshots-images-2/chapter_11/section_18/3739246b-c5c9-4369-8564-9662b1652489.png",
                            "./screenshots-images-2/chapter_11/section_18/29879b33-6c54-4497-8aae-6c66a8e94474.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/lib.rs\n\nThe Tests Module and #[cfg(test)]\n\nThe #[cfg(test)] annotation on the tests module tells Rust to compile and\nrun the test code only when you run cargo test, not when you run cargo build.\nThis saves compile time when you only want to build the library and saves\nspace in the resulting compiled artifact because the tests are not included.\nYou'll see that because integration tests go in a different directory, they don\u2019t\nneed the #[cfg(test)] annotation. However, because unit tests go in the same\nfiles as the code, you'll use #[cfg(test)] to specify that they shouldn't be\nincluded in the compiled result.\n\nRecall that when we generated the new adder project in the first section\nof this chapter, Cargo generated this code for us:\n\n#[cfg(test) ]\nmod tests {\n#[test]\nfn it_works() {\nassert_eq!(2 + 2, 4);\n}\n\nThis code is the automatically generated test module. The attribute\ncfg stands for configuration and tells Rust that the following item should\nonly be included given a certain configuration option. In this case, the\nconfiguration option is test, which is provided by Rust for compiling and\nrunning tests. By using the cfg attribute, Cargo compiles our test code\nonly if we actively run the tests with cargo test. This includes any helper\nfunctions that might be within this module, in addition to the functions\nannotated with #[test].\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 11.19,
                        "section_name": "Testing Private Functions",
                        "section_path": "./screenshots-images-2/chapter_11/section_19",
                        "images": [
                            "./screenshots-images-2/chapter_11/section_19/be565926-bb3f-40d2-963e-507b9133a8fa.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/lib.rs\n\nTesting Private Functions\n\nThere\u2019s debate within the testing community about whether or not private\nfunctions should be tested directly, and other languages make it difficult or\nimpossible to test private functions. Regardless of which testing ideology you\nadhere to, Rust\u2019s privacy rules do allow you to test private functions. Consider\nthe code in Listing 11-12 with the private function internal_adder.\n\npub fn add _two(a: i32) -> i32 {\ninternal_adder(a, 2)\n\n}\nfn internal_adder(a: i132, b: i132) -> i32 {\na+b\n}\n#[cfg(test)]\nmod tests {\nuse super::*;\n#[test]\nfn internal() {\nassert_eq!(4, internal_adder(2, 2));\n}\n}\n\nListing 11-12: Testing a private function\n\nNote that the internal_adder function is not marked as pub, but because\ntests are just Rust code and the tests module is just another module, you can\nbring internal_adder into a test's scope and call it. If you don\u2019t think private\nfunctions should be tested, nothing in Rust will compel you to do so.\n\n, a ee ee\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 11.2,
                        "section_name": "Integration Tests",
                        "section_path": "./screenshots-images-2/chapter_11/section_20",
                        "images": [
                            "./screenshots-images-2/chapter_11/section_20/e0e7e3a6-5a61-454b-b207-8cfe1500f578.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Integration Tests\n\nIn Rust, integration tests are entirely external to your library. They use your\nlibrary in the same way any other code would, which means they can only call\nfunctions that are part of your library\u2019s public API. Their purpose is to test\nwhether many parts of your library work together correctly. Units of code\nthat work correctly on their own could have problems when integrated, so\ntest coverage of the integrated code is important as well. To create integra-\ntion tests, you first need a tests directory.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 11.21,
                        "section_name": "The tests Directory",
                        "section_path": "./screenshots-images-2/chapter_11/section_21",
                        "images": [
                            "./screenshots-images-2/chapter_11/section_21/4614c674-6c00-4d23-92ee-f908cc29d94a.png",
                            "./screenshots-images-2/chapter_11/section_21/80a260f2-0fc2-4e0b-ad6f-a2779eaab304.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "tests/integration\n_test.rs\n\nThe tests Directory\n\nWe create a fests directory at the top level of our project directory, next to\nsrc, Cargo knows to look for integration test files in this directory. We can\nthen make as many test files as we want to in this directory, and Cargo will\ncompile each of the files as an individual crate.\n\nLet's create an integration test. With the code in Listing 11-12 still in the\nsr\u00a2/lib.rs file, make a tests directory, create a new file named fests/integration\n_test.rs, and enter the code in Listing 11-13.\n\nuse adder;\n\n#[test]\nfn it_adds two() {\n\nassert_eq!(4, adder: :add_two(2));\n}\n\nListing 11-13: An integration test of a function in the adder crate\n\nWe've added use adder at the top of the code, which we didn\u2019t need in\nthe unit tests. The reason is that each test in the (ests directory is a separate\ncrate, so we need to bring our library into each test crate\u2019s scope.\n\nWe don\u2019t need to annotate any code in tests/integration_test.rs with\n#[cfg(test)]. Cargo treats the tests directory specially and compiles files\nin this directory only when we run cargo test. Run cargo test now:\n\n$ cargo test\nCompiling adder v0.1.0 (file:///projects/adder)\nFinished dev [unoptimized + debuginfo] target(s) in 0.31 secs\nRunning target/debug/deps/adder-abcabcabc\n\n@ running 1 test\ntest tests::internal ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n\u00a9 Running target/debug/deps/integration_test-ce99bcc2479f4607\n\nrunning 1 test\n\u00a9 test it_adds two ... ok\n\n\u00a9 test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\nDoc-tests adder\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n\nThe three sections of output include the unit tests, the integration test,\nand the doc tests. The first section for the unit tests @ is the same as we've\nbeen seeing: one line for each unit test (one named internal that we added\nin Listing 11-12) and then a summary line for the unit tests.\n\nThe integration tests section starts with the line Running target/debug/\ndeps/integration_test-ce99bcc2479f4607 @ (the hash at the end of your output\nwill be different). Next, there is a line for each test function in that integra-\ntion test \u00ae and a summary line for the results of the integration test \u00a9 just\nbefore the Doc-tests adder section starts.\n\nSimilarly to how adding more unit test functions adds more result lines\nto the unit tests section, adding more test functions to the integration test file\nadds more result lines to this integration test file\u2019s section. Each integration\ntest file has its own section, so if we add more files in the fests directory, there\nwill be more integration test sections.\n\nWe can still run a particular integration test function by specifying the\ntest function\u2019s name as an argument to cargo test. To run all the tests ina\nparticular integration test file, use the --test argument of cargo test followed\nby the name of the file:\n\n$ cargo test --test integration_test\nFinished dev [unoptimized + debuginfo] target(s) in 0.0 secs\nRunning target/debug/integration_test-952a27e0126bb565\n\nrunning 1 test\ntest it_adds two ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n\nThis command runs only the tests in the tests/integration_test.rs file.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 11.22,
                        "section_name": "Submodules in Integration Tests",
                        "section_path": "./screenshots-images-2/chapter_11/section_22",
                        "images": [
                            "./screenshots-images-2/chapter_11/section_22/5dda8d64-d0a5-4151-8914-01c4b762be25.png",
                            "./screenshots-images-2/chapter_11/section_22/ac340668-4b58-4701-aeb6-5f434da10fda.png",
                            "./screenshots-images-2/chapter_11/section_22/2916652e-5ee5-4d46-bc33-f92593b05676.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "tests/common.rs\n\nSubmodules in Integration Tests\n\nAs you add more integration tests, you might want to make more than one\nfile in the fests directory to help organize them; for example, you can group\nthe test functions by the functionality they\u2019re testing. As mentioned earlier,\neach file in the fests directory is compiled as its own separate crate.\n\nTreating each integration test file as its own crate is useful to create\nseparate scopes that are more like the way end users will be using your crate.\nHowever, this means files in the fests directory don\u2019t share the same behavior\nas files in src do, as you learned in Chapter 7 regarding how to separate code\ninto modules and files.\n\nThe different behavior of files in the fests directory is most noticeable\nwhen you have a set of helper functions that would be useful in multiple\nintegration test files and you try to follow the steps in \u201cSeparating Modules\ninto Different Files\u201d on page 127 to extract them into a common module.\nFor example, if we create fests/common.rs and place a function named setup\nin it, we can add some code to setup that we want to call from multiple test\nfunctions in multiple test files:\n\npub fn setup() {\n// setup code specific to your library's tests would go here\n}\n\ntests/integration\n_test.rs\n\nWhen we run the tests again, we'll see a new section in the test output for\nthe common.rs file, even though this file doesn\u2019t contain any test functions nor\ndid we call the setup function from anywhere:\n\nrunning 1 test\n\ntest tests::internal ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\nRunning target/debug/deps/common-b&b07b6f1be2db70\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n\nRunning target/debug/deps/integration_test-d993c68b431d39df\n\nrunning 1 test\ntest it_adds two ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\nDoc-tests adder\nrunning O tests\n\ntest result: ok. 0 pa 0 filtered out\n\nd; O failed; 0 ignored; 0 measured\n\nHaving common appear in the test results with running 0 tests displayed\nfor it is not what we wanted. We just wanted to share some code with the\nother integration test files.\n\nTo avoid having common appear in the test output, instead of creating\ntests/common.rs, we'll create tests/common/mod.rs. This is an alternate naming\nconvention that Rust also understands. Naming the file this way tells Rust not\nto treat the common module as an integration test file. When we move the setup\nfunction code into tests/common/mod.rs and delete the tests/common.rs file, the\nsection in the test output will no longer appear. Files in subdirectories of the\ntests directory don\u2019t get compiled as separate crates or have sections in the test\noutput.\n\nAfter we've created tests/common/mod.rs, we can use it from any of the\nintegration test files as a module. Here\u2019s an example of calling the setup\nfunction from the it_adds_two test in fests/integration_ltest.rs:\n\nuse adder;\n\nmod common;\n#[test]\n\nfn it_adds two() {\n\ncommon: :setup();\nassert_eq!(4, adder: :add_two(2));\n\nNote that the mod common; declaration is the same as the module declara-\ntions we demonstrated in Listing 7-21 on page 128. Then in the test func-\ntion, we can call the common: :setup() function.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 11.23,
                        "section_name": "Integration Tests for Binary Crates",
                        "section_path": "./screenshots-images-2/chapter_11/section_23",
                        "images": [
                            "./screenshots-images-2/chapter_11/section_23/b71d84dd-9131-4e89-af31-0a24e40f4402.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Integration Tests for Binary Crates\n\nIf our project is a binary crate that only contains a sr\u00a2/main.rs file and doesn\u2019t\nhave a src/lib.rs file, we can\u2019t create integration tests in the fests directory and\nbring functions defined in the src/main.rs file into scope with a use statement.\nOnly library crates expose functions that other crates can use; binary crates\nare meant to be run on their own.\n\nThis is one of the reasons Rust projects that provide a binary have a\nstraightforward src/main.rs file that calls logic that lives in the sr\u00a2/lib-rs file.\nUsing that structure, integration tests can test the library crate with use to\nexercise the important functionality. If the important functionality works,\nthe small amount of code in the src/main.rs file will work as well, and that\nsmall amount of code doesn\u2019t need to be tested.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 11.24,
                        "section_name": "Summary",
                        "section_path": "./screenshots-images-2/chapter_11/section_24",
                        "images": [
                            "./screenshots-images-2/chapter_11/section_24/eb8fa09e-8db8-4e72-afaf-edb059d76746.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Summary\n\nRust'\u2019s testing features provide a way to specify how code should function to\nensure it continues to work as you expect, even as you make changes. Unit\ntests exercise different parts of a library separately and can test private\nimplementation details. Integration tests check that many parts of the\nlibrary work together correctly, and they use the library's public API to test\nthe code in the same way external code will use it. Even though Rust\u2019s type\nsystem and ownership rules help prevent some kinds of bugs, tests are still\nimportant to reduce logic bugs having to do with how your code is expected\nto behave.\n\nLet\u2019s combine the knowledge you learned in this chapter and in previ-\nous chapters to work on a project!\n",
                        "extracted-code": ""
                    }
                ]
            },
            {
                "chapter_id": 12,
                "chapter_name": "AN I/O PROJECT: BUILDINGA\nCOMMAND LINE PROGRAM",
                "chapter_path": "./screenshots-images-2/chapter_12",
                "sections": [
                    {
                        "section_id": 12.1,
                        "section_name": "AN I/O PROJECT: BUILDINGA\nCOMMAND LINE PROGRAM",
                        "section_path": "./screenshots-images-2/chapter_12/section_1",
                        "images": [
                            "./screenshots-images-2/chapter_12/section_1/42cd8a21-3ac7-45a1-88ed-10b099d362b2.png",
                            "./screenshots-images-2/chapter_12/section_1/1b327106-846f-4a31-af81-83b98bb555b4.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "This chapter is a recap of the many skills\nyou've learned so far and an exploration of\n\na few more standard library features. We'll\n\nbuild a command line tool that interacts with file\nand command line input/output to practice some of\nthe Rust concepts you now have under your belt.\n\nRust\u2019s speed, safety, single binary output, and cross-platform support\nmake it an ideal language for creating command line tools, so for our\nproject, we'll make our own version of the classic command line tool grep\n(globally search a regular expression and print). In the simplest use case,\ngrep searches a specified file for a specified string. To do so, grep takes as its\narguments a filename and a string. Then it reads the file, finds lines in that\nfile that contain the string argument, and prints those lines.\n\nAlong the way, we'll show how to make our command line tool use fea-\ntures of the terminal that many command line tools use. We'll read the value\nof an environment variable to allow the user to configure the behavior of our\n\n\ntool. We'll also print to the standard error console stream (stderr) instead\nof standard output (stdout), so, for example, the user can redirect successful\noutput to a file while still seeing error messages onscreen.\n\nOne Rust community member, Andrew Gallant, has already created a\nfully featured, very fast version of grep, called ripgrep. By comparison, our\nversion of grep will be fairly simple, but this chapter will give you some of\nthe background knowledge you need to understand a real-world project\nsuch as ripgrep.\n\nOur grep project will combine a number of concepts you've learned so far:\n\ne Organizing code (using what you learned about modules in Chapter 7)\ne Using vectors and strings (collections, Chapter 8)\n\ne Handling errors (Chapter 9)\n\ne Using traits and lifetimes where appropriate (Chapter 10)\n\ne Writing tests (Chapter 11)\n\nWe'll also briefly introduce closures, iterators, and trait objects, which\nChapters 13 and 17 will cover in detail.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 12.2,
                        "section_name": "Accepting Command Line Arguments",
                        "section_path": "./screenshots-images-2/chapter_12/section_2",
                        "images": [
                            "./screenshots-images-2/chapter_12/section_2/a32d68a0-d4d7-4cc8-8822-67d9f9bc5b96.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Accepting Command Line Arguments\n\nLet\u2019s create a new project with, as always, cargo new. We'll call our project\nminigrep to distinguish it from the grep tool that you might already have on\nyour system.\n\n$ cargo new minigrep\nCreated binary (application) \u201cminigrep~ project\n$ cd minigrep\n\nThe first task is to make minigrep accept its two command line arguments:\nthe filename and a string to search for. That is, we want to be able to run our\nprogram with cargo run, a string to search for, and a path to a file to search in,\nlike so:\n\n$ cargo run searchstring example-filename.txt\n\nRight now, the program generated by cargo new cannot process argu-\nments we give it. Some existing libraries on Attps://crates.io/ can help with\nwriting a program that accepts command line arguments, but because\nyou're just learning this concept, let's implement this capability ourselves.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 12.3,
                        "section_name": "Reading the Argument Values",
                        "section_path": "./screenshots-images-2/chapter_12/section_3",
                        "images": [
                            "./screenshots-images-2/chapter_12/section_3/19404f64-d5d4-4249-a38f-169cfa3b0aaa.png",
                            "./screenshots-images-2/chapter_12/section_3/2f1025f8-cbd7-453c-b4c0-51390d32fe9c.png",
                            "./screenshots-images-2/chapter_12/section_3/0fa3ff46-97ac-491c-aab8-39c49ff3dd53.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Reading the Argument Values\n\nTo enable minigrep to read the values of command line arguments we pass\n\nto it, we'll need a function provided in Rust\u2019s standard library, which is\n\nstd: :env::args. This function returns an iterator of the command line argu-\nments that were given to minigrep. We'll cover iterators fully in Chapter 13.\nFor now, you only need to know two details about iterators: iterators produce\n\nsrc/main.rs\n\na series of values, and we can call the collect method on an iterator to turn\nit into a collection, such as a vector, containing all the elements the iterator\nproduces.\n\nUse the code in Listing 12-1 to allow your minigrep program to read any\ncommand line arguments passed to it and then collect the values into a\nvector.\n\nuse std::env;\n\nfn main() {\nlet args: Vec<String> = env::args().collect();\nprintln!(\"{:?}\", args);\n\n}\n\nListing 12-1: Collecting the command line arguments into a vector and printing them\n\nFirst, we bring the std::env module into scope with a use statement so we\ncan use its args function. Notice that the std: :env::args function is nested\nin two levels of modules. As we discussed in Chapter 7, in cases where the\ndesired function is nested in more than one module, it\u2019s conventional to\nbring the parent module into scope rather than the function. By doing so,\nwe can easily use other functions from std: :env. It\u2019s also less ambiguous\nthan adding use std::env::args and then calling the function with just args,\nbecause args might easily be mistaken for a function that\u2019s defined in the\ncurrent module.\n\nTHE ARGS FUNCTION AND INVALID UNICODE\n\nNote that std: :env: :args will panic if any argument contains invalid Unicode.\nIf your program needs to accept arguments containing invalid Unicode, use\n\nstd: :env::args_os instead. That function returns an iterator that produces\nOsString values instead of String values. We've chosen to use std::env: :args\nhere for simplicity, because OsString values differ per platform and are more\ncomplex to work with than String values.\n\nOn the first line of main, we call env: :args, and we immediately use collect\nto turn the iterator into a vector containing all the values produced by the\niterator. We can use the collect function to create many kinds of collections,\nso we explicitly annotate the type of args to specify that we want a vector of\nstrings. Although we very rarely need to annotate types in Rust, collect is one\nfunction you often do need to annotate because Rust isn\u2019t able to infer the\nkind of collection you want.\n\nFinally, we print the vector using the debug formatter, :?. Let\u2019s try run-\nning the code first with no arguments and then with two arguments:\n\n$ cargo run\n--snip--\n\n[\"target/debug/minigrep\"]\n\n$ cargo run needle haystack\n--snip--\n[\"target/debug/minigrep\", \"needle\", \u201chaystack\"]\n\nNotice that the first value in the vector is \"target/debug/minigrep\", which is\nthe name of our binary. This matches the behavior of the arguments list in C,\nletting programs use the name by which they were invoked in their execution.\nIt\u2019s often convenient to have access to the program name in case you want to\nprint it in messages or change behavior of the program based on what com-\nmand line alias was used to invoke the program. But for the purposes of this\nchapter, we'll ignore it and save only the two arguments we need.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 12.4,
                        "section_name": "Saving the Argument Values in Variables",
                        "section_path": "./screenshots-images-2/chapter_12/section_4",
                        "images": [
                            "./screenshots-images-2/chapter_12/section_4/b6df6228-1908-441e-a768-645e83d23e2b.png",
                            "./screenshots-images-2/chapter_12/section_4/7f727e17-52a9-4c69-93f1-c9a98b99f9c4.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nSaving the Argument Values in Variables\n\nPrinting the value of the vector of arguments illustrated that the program\nis able to access the values specified as command line arguments. Now we\nneed to save the values of the two arguments in variables so we can use the\nvalues throughout the rest of the program. We do that in Listing 12-2.\n\nn main\n\nlet args: Vec<String> env: :args().collect();\n\nlet query = &args[1];\nlet filename = &args[2];\n\nprintln!(\"Searching for {}\", query);\nprintln!(\"In file {}\", filename) ;\n}\n\nListing 12-2: Creating variables to hold the query argument and filename argument\n\nAs we saw when we printed the vector, the program's name takes up the\nfirst value in the vector at args[0], so we're starting at index 1. The first argu-\nment minigrep takes is the string we're searching for, so we put a reference to\nthe first argument in the variable query. The second argument will be the file-\nname, so we put a reference to the second argument in the variable filename.\n\nWe temporarily print the values of these variables to prove that the code\nis working as we intend. Let's run this program again with the arguments test\nand sample. txt:\n\n$ cargo run test sample.txt\nCompiling minigrep v0.1.0 (file: ///projects/minigrep)\nFinished dev [unoptimized + debuginfo] target(s) in 0.0 secs\nRunning ~target/debug/minigrep test sample.txt\u201d\nSearching for test\nIn file sample.txt\n\nGreat, the program is working! The values of the arguments we need are\nbeing saved into the right variables. Later we'll add some error handling to\ndeal with certain potential erroneous situations, such as when the user pro-\nvides no arguments; for now, we'll ignore that situation and work on adding\nfile-reading capabilities instead.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 12.5,
                        "section_name": "Reading a File",
                        "section_path": "./screenshots-images-2/chapter_12/section_5",
                        "images": [
                            "./screenshots-images-2/chapter_12/section_5/f3233852-dd4b-463b-8bda-7b7de634da3b.png",
                            "./screenshots-images-2/chapter_12/section_5/db0289e0-7edf-43cc-9046-3d9882a85400.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Reading a File\n\nNow we'll add functionality to read the file that is specified in the filename\ncommand line argument. First, we need a sample file to test it with: the best\nkind of file to use to make sure minigrep is working is one with a small amount\nof text over multiple lines with some repeated words. Listing 12-3 has an\nEmily Dickinson poem that will work well! Create a file called poem.txt at the\nroot level of your project and enter the poem \u201cI\u2019m Nobody! Who are you?\u201d\n\npoem. txt I'm nobody! Who are you?\nAre you nobody, too?\nThen there's a pair of us \u2014 don't tell!\nThey'd banish us, you know.\n\nHow dreary to be somebody!\n\nHow public, like a frog\n\nTo tell your name the livelong day\nTo an admiring bog!\n\nListing 12-3: A poem by Emily Dickinson makes a good test case.\n\nWith the text in place, edit src/main.rs and add code to read the file, as\nshown in Listing 12-4.\n\nsrc/main.rs ise std::env;\n\n@ use std::fs;\n\nprintln!(\"In file {}\", filename);\n\n\u00a9 let contents = fs::read_to_string(filename)\n-expect (\"Something went wrong reading the file\");\n\n\u00a9 println! (\"With text:\\n{}\", contents);\n\nListing 12-4: Reading the contents of the file specified by the second argument\n\nFirst, we add another use statement to bring in a relevant part of the\nstandard library: we need std::fs to handle files @.\n\nIn main, we've added a new statement: fs::read_to_string takes the file-\nname, opens that file, and returns a Result<String> of the file\u2019s contents e.\n\nAfter that statement, we\u2019ve again added a temporary print1n! statement\nthat prints the value of contents after the file is read, so we can check that\nthe program is working so far \u00ae.\n\nLet\u2019s run this code with any string as the first command line argument\n(because we haven't implemented the searching part yet) and the poem.txt\nfile as the second argument:\n\n$ cargo run the poem.txt\nCompiling minigrep v0.1.0 (file: ///projects/minigrep)\nFinished dev [unoptimized + debuginfo] target(s) in 0.0 secs\n\nRunning ~target/debug/minigrep the poem.txt\u201d\n\nSearching for the\n\nIn file poem.txt\n\nWith text:\n\nI'm nobody! Who are you?\n\nAre you nobody, too?\n\nThen there's a pair of us - don't tell!\n\nThey'd banish us, you know.\n\nHow dreary to be somebody!\n\nHow public, like a frog\n\nTo tell your name the livelong day\nTo an admiring bog!\n\nGreat! The code read and then printed the contents of the file. But the\ncode has a few flaws. The main function has multiple responsibilities: gener-\nally, functions are clearer and easier to maintain if each function is respon-\nsible for only one idea. The other problem is that we're not handling errors\nas well as we could. The program is still small, so these flaws aren\u2019t a big prob-\nlem, but as the program grows, it will be harder to fix them cleanly. It's good\npractice to begin refactoring early on when developing a program, because\nit\u2019s much easier to refactor smaller amounts of code. We'll do that next.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 12.6,
                        "section_name": "Refactoring to Improve Modularity and Error Handling",
                        "section_path": "./screenshots-images-2/chapter_12/section_6",
                        "images": [
                            "./screenshots-images-2/chapter_12/section_6/11756192-37e2-4b8d-8dff-8cdfd063937b.png",
                            "./screenshots-images-2/chapter_12/section_6/57b5ec87-1a75-4053-8fec-76981e66cb6d.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Refactoring to Improve Modularity and Error Handling\n\nTo improve our program, we'll fix four problems that have to do with the\nprogram\u2019s structure and how it\u2019s handling potential errors.\n\nFirst, our main function now performs two tasks: it parses arguments\nand reads files. For such a small function, this isn\u2019t a major problem.\nHowever, if we continue to grow our program inside main, the number of\nseparate tasks the main function handles will increase. As a function gains\nresponsibilities, it becomes more difficult to reason about, harder to test,\nand harder to change without breaking one of its parts. It\u2019s best to separate\nfunctionality so each function is responsible for one task.\n\nThis issue ties into the second problem: although query and filename are\nconfiguration variables to our program, variables like contents are used to\nperform the program\u2019s logic. The longer main becomes, the more variables\nwe'll need to bring into scope; the more variables we have in scope, the\nharder it will be to keep track of the purpose of each. It\u2019s best to group the\nconfiguration variables into one structure to make their purpose clear.\n\nThe third problem is that we've used expect to print an error message\nwhen reading the file fails, but the error message just prints Something\nwent wrong reading the file. Reading a file can fail in a number of ways:\nfor example, the file could be missing, or we might not have permission\nto open it. Right now, regardles of that situation, we'd print the Something\nwent wrong reading the file error message, which wouldn't give the user any\ninformation!\n\nFourth, we use expect repeatedly to handle different errors, and if the\nuser runs our program without specifying enough arguments, they'll get an\nindex out of bounds error from Rust that doesn\u2019t clearly explain the problem. It\nwould be best if all the error-handling code were in one place so future main-\ntainers had only one place to consult in the code if the error-handling logic\nneeded to change. Having all the error-handling code in one place will also\nensure that we're printing messages that will be meaningful to our end users.\n\nLet's address these four problems by refactoring our project.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 12.7,
                        "section_name": "Separation of Concerns for Binary Projects",
                        "section_path": "./screenshots-images-2/chapter_12/section_7",
                        "images": [
                            "./screenshots-images-2/chapter_12/section_7/56282876-b245-4a68-9b27-c1bee2707245.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Separation of Concerns for Binary Projects\n\nThe organizational problem of allocating responsibility for multiple tasks to\nthe main function is common to many binary projects. As a result, the Rust\ncommunity has developed a process to use as a guideline for splitting the\nseparate concerns of a binary program when main starts getting large. The\nprocess has the following steps:\n\ne Split your program into a main.rs and a lib.rs and move your program\u2019s\nlogic to lib.rs.\n\ne As long as your command line parsing logic is small, it can remain in\nmain.rs.\n\ne When the command line parsing logic starts getting complicated,\nextract it from main.rs and move it to lib.rs.\n\nThe responsibilities that remain in the main function after this process\nshould be limited to the following:\n\ne Calling the command line parsing logic with the argument values\ne Setting up any other configuration\ne =Calling a run function in lib.rs\n\ne Handling the error if run returns an error\n\nThis pattern is about separating concerns: main.rs handles running the\nprogram, and /ib.rs handles all the logic of the task at hand. Because you\ncan\u2019t test the main function directly, this structure lets you test all of your\nprogram\u2019s logic by moving it into functions in /ib.rs. The only code that\nremains in main.rs will be small enough to verify its correctness by reading\nit. Let's rework our program by following this process.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 12.8,
                        "section_name": "Extracting the Argument Parser",
                        "section_path": "./screenshots-images-2/chapter_12/section_8",
                        "images": [
                            "./screenshots-images-2/chapter_12/section_8/1bfe93b2-d5db-4b91-97fe-70e1544817f0.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nExtracting the Argument Parser\n\nWe'll extract the functionality for parsing arguments into a function that main\nwill call to prepare for moving the command line parsing logic to sre/lib.rs.\nListing 12-5 shows the new start of main that calls a new function parse_config,\nwhich we'll define in sr\u00a2/main.rs for the moment.\n\nn main\n\nlet arg\n\nenv: :args().colle\n\nlet (query, filename) = parse_config(&args);\n\n--snip--\n}\n\nfn parse_config(args: &[String]) -> (&str, &str) {\nlet query = &args[1];\nlet filename = &args[2];\n\n(query, filename)\n}\n\nListing 12-5: Extracting a parse_config function from main\n\nWe're still collecting the command line arguments into a vector, but\ninstead of assigning the argument value at index 1 to the variable query and\nthe argument value at index 2 to the variable filename within the main func-\ntion, we pass the whole vector to the parse_config function. The parse_config\nfunction then holds the logic that determines which argument goes in\nwhich variable and passes the values back to main. We still create the query\nand filename variables in main, but main no longer has the responsibility of\ndetermining how the command line arguments and variables correspond.\n\nThis rework may seem like overkill for our small program, but we're\nrefactoring in small, incremental steps. After making this change, run the\nprogram again to verify that the argument parsing still works. It's good to\ncheck your progress often to help identify the cause of problems when they\noccur.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 12.9,
                        "section_name": "Grouping Configuration Values",
                        "section_path": "./screenshots-images-2/chapter_12/section_9",
                        "images": [
                            "./screenshots-images-2/chapter_12/section_9/9517d8d3-924d-4769-bb36-1481436051e7.png",
                            "./screenshots-images-2/chapter_12/section_9/41fb4d75-4c96-4600-b819-c9de2aef3cda.png",
                            "./screenshots-images-2/chapter_12/section_9/b5ed3a26-b30f-4631-ac57-e45a600c2f2b.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Grouping Configuration Values\n\nWe can take another small step to improve the parse_config function further.\nAt the moment, we're returning a tuple, but then we immediately break that\ntuple into individual parts again. This is a sign that perhaps we don\u2019t have the\nright abstraction yet.\n\nAnother indicator that shows there\u2019s room for improvement is the config\npart of parse_config, which implies that the two values we return are related\nand are both part of one configuration value. We're not currently conveying\nthis meaning in the structure of the data other than by grouping the two\nvalues into a tuple; we could put the two values into one struct and give each\n\nsrc/main.rs\n\nof the struct fields a meaningful name. Doing so will make it easier for future\nmaintainers of this code to understand how the different values relate to each\nother and what their purpose is.\n\nUsing primitive values when a complex type would be more appropriate is an anti-\npattern known as primitive obsession.\n\nListing 12-6 shows the improvements to the parse_config function.\n\nlet args: Vec<String> = env::args().colle\n@ let config = parse_config(&args);\n\nprintln!(\"Searching for {}\", config.query\u00ae) ;\nprintln!(\"In file {}\", config.filename\u00ae) ;\n\nlet contents = fs::read_to_string(config. filename\u00ae)\n-expect (\"Something went wrong reading the file\");\n\n--snip--\n\nstruct Config {\nquery: String,\nfilename: String,\n}\n\nfn parse_config(args: &[String]) -> Config {\n@ let query = args[1].clone();\n\u00a9 let filename = args[2].clone();\n\nConfig { query, filename }\n}\n\nListing 12-6: Refactoring parse_config to return an instance of a Config struct\n\nWe've added a struct named Config defined to have fields named query\nand filename @. The signature of parse_config now indicates that it returns\na Config value @. In the body of parse_config, where we used to return string\nslices that reference String values in args, we now define Config to contain\nowned String values. The args variable in main is the owner of the argument\nvalues and is only letting the parse_config function borrow them, which\nmeans we'd violate Rust\u2019s borrowing rules if Config tried to take ownership\nof the values in args.\n\nWe could manage the String data in a number of different ways, but the\neasiest, though somewhat inefficient, route is to call the clone method on\n\nthe values @\u00ae. This will make a full copy of the data for the Config instance\nto own, which takes more time and memory than storing a reference to the\nstring data. However, cloning the data also makes our code very straight-\nforward because we don\u2019t have to manage the lifetimes of the references;\nin this circumstance, giving up a little performance to gain simplicity is a\nworthwhile trade-off.\n\nTHE TRADE-OFFS OF USING CLONE\n\nThere's a tendency among many Rustaceans to avoid using clone to fix owner-\nship problems because of its runtime cost. In Chapter 13, you'll learn how to\nuse more efficient methods in this type of situation. But for now, it's okay to\ncopy a few strings to continue making progress because you'll make these\n\ncopies only once and your filename and query string are very small. It\u2019s better\nto have a working program that's a bit inefficient than to try to hyperoptimize\ncode on your first pass. As you become more experienced with Rust, it'll be\neasier to start with the most efficient solution, but for now, it's perfectly accept-\nable to call clone.\n\nWe've updated main so it places the instance of Config returned by\nparse_config into a variable named config @, and we updated the code that\npreviously used the separate query and filename variables so it now uses the\nfields on the Config struct instead @@9O.\n\nNow our code more clearly conveys that query and filename are related\nand that their purpose is to configure how the program will work. Any\ncode that uses these values knows to find them in the config instance in\nthe fields named for their purpose.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 12.1,
                        "section_name": "Creating a Constructor for Config",
                        "section_path": "./screenshots-images-2/chapter_12/section_10",
                        "images": [
                            "./screenshots-images-2/chapter_12/section_10/867df1a6-42fc-4b59-aaf0-e647c7074de6.png",
                            "./screenshots-images-2/chapter_12/section_10/ddc16127-36b2-4e64-837c-ea02f0cef2da.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Creating a Constructor for Config\n\nSo far, we've extracted the logic responsible for parsing the command line\narguments from main and placed it in the parse_config function. Doing so\nhelped us to see that the query and filename values were related and that rela-\ntionship should be conveyed in our code. We then added a Config struct to\nname the related purpose of query and filename and to be able to return the\nvalues\u2019 names as struct field names from the parse_config function.\n\nSo now that the purpose of the parse_config function is to create a\nConfig instance, we can change parse_config from a plain function to a func-\ntion named new that is associated with the Config struct. Making this change\nwill make the code more idiomatic. We can create instances of types in the\nstandard library, such as String, by calling String: :new. Similarly, by chang-\ning parse_config into a new function associated with Config, we'll be able\nto create instances of Config by calling Config: :new. Listing 12-7 shows the\nchanges we need to make.\n\nsrc/main.rs fn main(\n\n@ let config = Config: :new(&args);\n\n// --snip--\n\n{ --snip--\n\u00a9 impl Config {\n\u00a9 fn new(args: &[String]) -> Config {\nlet query = args[1].clone();\nlet filename = args[2].clone();\n\nConfig { query, filename }\n}\n\nListing 12-7: Changing parse_config into Config: :new\n\nWe've updated main where we were calling parse_config to instead call\nConfig: :new @. We've changed the name of parse_config to new \u00ae and moved\nit within an imp] block \u00ae, which associates the new function with Config. Try\ncompiling this code again to make sure it works.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 12.11,
                        "section_name": "Fixing the Error Handling",
                        "section_path": "./screenshots-images-2/chapter_12/section_11",
                        "images": [
                            "./screenshots-images-2/chapter_12/section_11/49eb3499-2237-4055-9b8c-3cd9938b2426.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Fixing the Error Handling\n\nNow we'll work on fixing our error handling. Recall that attempting to access\nthe values in the args vector at index 1| or index 2 will cause the program to\npanic if the vector contains fewer than three items. Try running the program\nwithout any arguments; it will look like this:\n\n$ cargo run\nCompiling minigrep v0.1.0 (file:///projects/minigrep)\nFinished dev [unoptimized + debuginfo] target(s) in 0.0 secs\nRunning \u201ctarget/debug/minigrep~\nthread 'main' panicked at \u2018index out of bounds: the len is 1\nbut the index is 1', sre/main.rs:25:21\nnote: Run with ~RUST_BACKTRACE=1\u00b0 for a backtrace.\n\nThe line index out of bounds: the len is 1 but the index is 1is an error\nmessage intended for programmers. It won't help our end users understand\nwhat happened and what they should do instead. Let\u2019s fix that now.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 12.12,
                        "section_name": "Improving the Error Message",
                        "section_path": "./screenshots-images-2/chapter_12/section_12",
                        "images": [
                            "./screenshots-images-2/chapter_12/section_12/f7c77f9a-ef0d-4cc1-9294-7f6a2369a403.png",
                            "./screenshots-images-2/chapter_12/section_12/ce7f6cec-afba-45a3-a937-97142071380b.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Improving the Error Message\n\nIn Listing 12-8, we add a check in the new function that will verify that the\nslice is long enough before accessing index 1 and 2. If the slice isn\u2019t long\nenough, the program panics and displays a better error message than the\nindex out of bounds message.\n\nsrc/main.rs\n\n/ --snip--\nn new(args: &[String]) -> Config {\nif args.len() < 3 {\npanic! (\"not enough arguments\");\n\n--snip--\n\nListing 12-8: Adding a check for the number of arguments\n\nThis code is similar to the Guess: :new function we wrote in Listing 9-10,\nwhere we called panic! when the value argument was out of the range of\nvalid values. Instead of checking for a range of values here, we're checking\nthat the length of args is at least 3 and the rest of the function can operate\nunder the assumption that this condition has been met. If args has fewer\nthan three items, this condition will be true, and we call the panic! macro\nto end the program immediately.\n\nWith these extra few lines of code in new, let\u2019s run the program without\nany arguments again to see what the error looks like now:\n\n$ cargo run\nCompiling minigrep v0.1.0 (file:///projects/minigrep)\nFinished dev [unoptimized + debuginfo] target(s) in 0.0 secs\nRunning ~target/debug/minigrep~\nthread \u2018main' panicked at \u2018not enough arguments\u2019, src/main.rs:26:13\nnote: Run with ~RUST_BACKTRACE=1\u00b0 for a backtrace.\n\nThis output is better: we now have a reasonable error message. However,\nwe also have extraneous information we don\u2019t want to give to our users. Per-\nhaps using the technique we used in Listing 9-10 isn\u2019t the best to use here: a\ncall to panic! is more appropriate for a programming problem than a usage\nproblem, as discussed in Chapter 9. Instead, we can use the other technique\nyou learned about in Chapter 9\u2014returning a Result that indicates either\nsuccess or an error.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 12.13,
                        "section_name": "Returning a Result from new Instead of Calling panic!",
                        "section_path": "./screenshots-images-2/chapter_12/section_13",
                        "images": [
                            "./screenshots-images-2/chapter_12/section_13/f9aaea97-7ebc-468d-93e7-d0c4db2ed26a.png",
                            "./screenshots-images-2/chapter_12/section_13/a552050e-406f-4ec7-932c-816ba02b5f5f.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nReturning a Result from new Instead of Calling panic!\n\nWe can instead return a Result value that will contain a Config instance in\nthe successful case and will describe the problem in the error case. When\nConfig: :new is communicating to main, we can use the Result type to signal\nthere was a problem. Then we can change main to convert an Err variant\ninto a more practical error for our users without the surrounding text\nabout thread 'main' and RUST_BACKTRACE that a call to panic! causes.\n\nListing 12-9 shows the changes we need to make to the return value of\nConfig: :new and the body of the function needed to return a Result. Note\nthat this won\u2019t compile until we update main as well, which we'll do in the\nnext listing.\n\nimpl Config\nfn new(args: a[string]) -> Result<Config, &'static str> {\nif args.len() < 3\n\nreturn Err(\u201cnot enough arguments\");\n\nOk(Config { query, filename })\n\nListing 12-9: Returning a Result from Config: :new\n\nOur new function now returns a Result with a Config instance in the\nsuccess case and a &'static str in the error case. Recall from \u201cThe Static\nLifetime\u201d on page 204 that &' static str is the type of string literals, which is\nour error message type for now.\n\nWe've made two changes in the body of the new function: instead of call-\ning panic! when the user doesn\u2019t pass enough arguments, we now return an\nErr value, and we've wrapped the Config return value in an 0k. These changes\nmake the function conform to its new type signature.\n\nReturning an Err value from Config: :new allows the main function to\nhandle the Result value returned from the new function and exit the process\nmore cleanly in the error case.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 12.14,
                        "section_name": "Calling Config::new and Handling Errors",
                        "section_path": "./screenshots-images-2/chapter_12/section_14",
                        "images": [
                            "./screenshots-images-2/chapter_12/section_14/569d3559-2673-45d2-b33f-834ff23c8580.png",
                            "./screenshots-images-2/chapter_12/section_14/76afb11c-137b-4e64-9208-5f4d13f93568.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nCalling Config::new and Handling Errors\n\nTo handle the error case and print a user-friendly message, we need to\nupdate main to handle the Result being returned by Config: :new, as shown\n\nin Listing 12-10. We'll also take the responsibility of exiting the command\nline tool with a nonzero error code from panic! and implement it by hand.\nA nonzero exit status is a convention to signal to the process that called our\nprogram that the program exited with an error state.\n\nuse std: :process;\n\n@ let config = Config: :new(&args).unwrap_or_else(@lerr\u00ae| {\n\u00a9 println!(\"Problem parsing arguments: {}\", err);\n\u00ae process: :exit(1);\n\n3\n\n/{ --snip--\n\nListing 12-10: Exiting with an error code if creating a new Config fails\n\nIn this listing, we've used a method we haven't covered before:\nunwrap_or_else, which is defined on Result<T, \u00a3> by the standard library \u00ae@.\nUsing unwrap_or_else allows us to define some custom, non-panic! error\nhandling. If the Result is an 0k value, this method\u2019s behavior is similar to\nunwrap: it returns the inner value 0k is wrapping. However, if the value is an\nErr value, this method calls the code in the closure, which is an anonymous\nfunction we define and pass as an argument to unwrap_or_else \u00ae. We'll cover\nclosures in more detail in Chapter 13. For now, you just need to know that\n\nunwrap_or_else will pass the inner value of the Err, which in this case is the\nstatic string not enough arguments that we added in Listing 12-9, to our clo-\nsure in the argument err that appears between the vertical pipes \u00ae. The\ncode in the closure can then use the err value when it runs.\n\nWe've added a new use line to bring process from the standard library\ninto scope @. The code in the closure that will be run in the error case is\nonly two lines: we print the err value \u00a9 and then call process: :exit \u00ae. The\nprocess: :exit function will stop the program immediately and return the\nnumber that was passed as the exit status code. This is similar to the panic!-\nbased handling we used in Listing 12-8, but we no longer get all the extra\noutput. Let's try it:\n\n$ cargo run\nCompiling minigrep v0.1.0 (file: ///projects/minigrep)\nFinished dev [unoptimized + debuginfo] target(s) in 0.48 secs\nRunning \u201ctarget/debug/minigrep~\nProblem parsing arguments: not enough arguments\n\nGreat! This output is much friendlier for our users.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 12.15,
                        "section_name": "Extracting Logic from main",
                        "section_path": "./screenshots-images-2/chapter_12/section_15",
                        "images": [
                            "./screenshots-images-2/chapter_12/section_15/f05cea38-a45c-4cce-a9aa-a57a47e068dd.png",
                            "./screenshots-images-2/chapter_12/section_15/a13017e1-ab84-428b-86ac-35fe29d95a52.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nExtracting Logic from main\n\nNow that we've finished refactoring the configuration parsing, let\u2019s turn\nto the program\u2019s logic. As we stated in \u201cSeparation of Concerns for Binary\nProjects\u201d on page 239, we'll extract a function named run that will hold all\nthe logic currently in the main function that isn\u2019t involved with setting up con-\nfiguration or handling errors. When we're done, main will be concise and easy\nto verify by inspection, and we'll be able to write tests for all the other logic.\nListing 12-11 shows the extracted run function. For now, we're just mak-\ning the small, incremental improvement of extracting the function. We're\nstill defining the function in sre/main.rs.\n\nn main(\n\n--snip--\n\nprintln! (\"Searching for {}\", config\n\nIn file {}\", config.filenam\n\nprintln! (\n\nrun(config) ;\n}\n\nfn run(config: Config) {\nlet contents = fs::read_to_string(config. filename)\n-expect(\"Something went wrong reading the file\");\n\nprintln! (\"With text:\\n{}\", contents);\n\n/ --snip--\n\nListing 12-11: Extracting a run function containing the rest of the program logic\n\nThe run function now contains all the remaining logic from main, start-\ning from reading the file. The run function takes the Config instance as an\nargument.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 12.16,
                        "section_name": "Returning Errors from the run Function",
                        "section_path": "./screenshots-images-2/chapter_12/section_16",
                        "images": [
                            "./screenshots-images-2/chapter_12/section_16/3e7dddb4-0349-49a3-8b49-72ff1dba59a8.png",
                            "./screenshots-images-2/chapter_12/section_16/f18d4c02-6ec0-4df6-80e0-ad447d63c65e.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nReturning Errors from the run Function\n\nWith the remaining program logic separated into the run function, we\ncan improve the error handling, as we did with Config: :new in Listing 12-9.\nInstead of allowing the program to panic by calling expect, the run func-\ntion will return a Result<T, E> when something goes wrong. This will let us\nfurther consolidate into main the logic around handling errors in a user-\nfriendly way. Listing 12-12 shows the changes we need to make to the signa-\nture and body of run.\n\nuse std::error::Error;\n/ --snip--\n\nfn run(config: Config) -> Result<(), Box<dyn Error>> {\nlet contents = fs::read_to_string(config. filename)?\u00ae;\n\nprintln With text:\\nj}\", contents\n\n\u00a9 0k(())\n\nListing 12-12: Changing the run function to return Result\n\nWe've made three significant changes here. First, we changed the\nreturn type of the run function to Result<(), Box<dyn Error>> @. This function\npreviously returned the unit type, (), and we keep that as the value\nreturned in the 0k case.\n\nFor the error type, we used the trait object Box<dyn Error> (and we've\nbrought std: :error: :Error into scope with a use statement at the top \u00ae).\nWe'll cover trait objects in Chapter 17. For now, just know that Box<dyn Error>\nmeans the function will return a type that implements the Error trait, but\nwe don\u2019t have to specify what particular type the return value will be. This\ngives us flexibility to return error values that may be of different types in\ndifferent error cases. The dyn keyword is short for \u201cdynamic.\u201d\n\nSecond, we've removed the call to expect in favor of the ? operator \u00a9, as\nwe talked about in Chapter 9. Rather than panic! on an error, the ? operator\nwill return the error value from the current function for the caller to handle.\n\nThird, the run function now returns an Ok value in the success case \u00ae.\nWe've declared the run function\u2019s success type as () in the signature, which\nmeans we need to wrap the unit type value in the 0k value. This 0k(()) syntax\nmight look a bit strange at first, but using () like this is the idiomatic way to\nindicate that we're calling run for its side effects only; it doesn\u2019t return a value\nwe need.\n\nWhen you run this code, it will compile but will display a warning:\n\nwarning: unused ~std::result::Result\u2019 that must be used\n--> src/main.rs:17:5\n\n|\n17 | run(config);\n\nARAAARAARAAA\n\nnote: #[warn(unused_must_use)] on by default\nnote: this \u201cResult\u201d may be an \u201cErr\u201d variant, which should be handled\n\nRust tells us that our code ignored the Result value and the Result value\nmight indicate that an error occurred. But we're not checking to see whether\nor not there was an error, and the compiler reminds us that we probably\nmeant to have some error-handling code here! Let\u2019s rectify that problem now.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 12.17,
                        "section_name": "Handling Errors Returned from run in main",
                        "section_path": "./screenshots-images-2/chapter_12/section_17",
                        "images": [
                            "./screenshots-images-2/chapter_12/section_17/95055a58-3881-48e6-a01a-83227f8e50fa.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nHandling Errors Returned from run in main\n\nWe'll check for errors and handle them using a technique similar to the\none we used with Config: :new in Listing 12-10, but with a slight difference:\n\nif let Err(e) = run(config) {\nprintln! (\"Application error: {}\", e);\n\nprocess: :exit(1);\n\nWe use if let rather than unwrap_or_else to check whether run returns an\nErr value and call process: :exit(1) if it does. The run function doesn\u2019t return\na value that we want to unwrap in the same way that Config: :new returns the\nConfig instance. Because run returns () in the success case, we only care about\ndetecting an error, so we don\u2019t need unwrap_or_else to return the unwrapped\nvalue because it would only be ().\n\nThe bodies of the if let and the unwrap_or_else functions are the same\nin both cases: we print the error and exit.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 12.18,
                        "section_name": "Splitting Code into a Library Crate",
                        "section_path": "./screenshots-images-2/chapter_12/section_18",
                        "images": [
                            "./screenshots-images-2/chapter_12/section_18/8ff39140-160d-4b44-ba76-a9c99cfb93b9.png",
                            "./screenshots-images-2/chapter_12/section_18/867fc88c-005b-4ee2-a504-3657357dd152.png",
                            "./screenshots-images-2/chapter_12/section_18/038f8bf5-ad4e-4c41-b8c2-8fc06738424d.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Splitting Code into a Library Crate\n\nOur minigrep project is looking good so far! Now we'll split the src/main.rs\nfile and put some code into the sr\u00a2/lib.rs file so we can test it and have a sre/\nmain.rs file with fewer responsibilities.\n\nsrc/lib.rs\n\nsrc/main.rs\n\nLet\u2019s move all the code that isn\u2019t the main function from sr\u00a2/main.rs to\nsre/lib.rs:\n\ne =The run function definition\n\ne = The relevant use statements\n\ne The definition of Config\n\ne The Config: :new function definition\n\nThe contents of src/lib.rs should have the signatures shown in Listing 12-13\n(we've omitted the bodies of the functions for brevity). Note that this won't\ncompile until we modify sr\u00a2/main.rs in Listing 12-14.\n\nuse std::error::Error;\nuse std::fs;\n\npub struct Config {\npub query: String,\npub filename: String,\n}\n\nimpl Config {\npub fn new(args: &[String]) -> Result<Config, &'static str> {\n\n--snip--\n}\n\n}\n\npub fn run(config: Config) -> Result<(), Box<dyn Error>> {\n// --snip--\n\n}\n\nListing 12-13: Moving Config and run into src/lib.rs\n\nWe've made liberal use of the pub keyword: on Config, on its fields and its\nnew method, and on the run function. We now have a library crate that has a\npublic API that we can test!\n\nNow we need to bring the code we moved to sre/lib.rs into the scope of\nthe binary crate in src/main.rs, as shown in Listing 12-14.\n\nenv;\n\nd::process;\n\nuse minigrep: :Config;\n\nfn main() {\n// --snip--\nif let Err(e) = minigrep::run(config) {\n--snip--\n}\n\nListing 12-14: Using the minigrep crate in src/main.rs\n\nWe add a use minigrep: :Config line to bring the Config type from the\nlibrary crate into the binary crate\u2019s scope, and we prefix the run function\nwith our crate name. Now all the functionality should be connected and\nshould work. Run the program with cargo run and make sure everything\nworks correctly.\n\nWhew! That was a lot of work, but we've set ourselves up for success in the\nfuture. Now it\u2019s much easier to handle errors, and we've made the code more\nmodular. Almost all of our work will be done in src/lib.rs from here on out.\n\nLet\u2019s take advantage of this newfound modularity by doing something\nthat would have been difficult with the old code but is easy with the new\ncode: we'll write some tests!\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 12.19,
                        "section_name": "Developing the Library\u2019s Functionality with\nTest-Driven Development",
                        "section_path": "./screenshots-images-2/chapter_12/section_19",
                        "images": [
                            "./screenshots-images-2/chapter_12/section_19/4c1bc088-fb7e-49f5-b941-458b4c44da9e.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Developing the Library\u2019s Functionality with\nTest-Driven Development\n\nNow that we've extracted the logic into sr\u00a2/lib.rs and left the argument col-\nlecting and error handling in src/main.rs, it\u2019s much easier to write tests for\nthe core functionality of our code. We can call functions directly with vari-\nous arguments and check return values without having to call our binary\nfrom the command line. Feel free to write some tests for the functionality\nin the Config: :new and run functions on your own.\n\nIn this section, we'll add the searching logic to the minigrep program by\nusing the test-driven development (TDD) process. This software develop-\nment technique follows these steps:\n\n1. Write a test that fails and run it to make sure it fails for the reason you\nexpect.\n\nbad\n\nWrite or modify just enough code to make the new test pass.\n\n3. Refactor the code you just added or changed and make sure the tests\ncontinue to pass.\n\n4. Repeat from step 1!\n\nThis process is just one of many ways to write software, but TDD can\nhelp drive code design as well. Writing the test before you write the code\nthat makes the test pass helps to maintain high test coverage throughout\nthe process.\n\nWe'll test drive the implementation of the functionality that will actu-\nally do the searching for the query string in the file contents and produce a\nlist of lines that match the query. We'll add this functionality in a function\ncalled search.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 12.2,
                        "section_name": "Writing a Failing Test",
                        "section_path": "./screenshots-images-2/chapter_12/section_20",
                        "images": [
                            "./screenshots-images-2/chapter_12/section_20/ed088d46-d9bc-40de-80a1-71f0984501d1.png",
                            "./screenshots-images-2/chapter_12/section_20/3fe45539-7672-431b-8b6c-4bcc88dac0f3.png",
                            "./screenshots-images-2/chapter_12/section_20/e3ab6780-ec30-4d7c-a452-86037c31b9c4.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Writing a Failing Test\n\nBecause we don\u2019t need them anymore, let\u2019s remove the println! statements\nfrom src/lib.rs and src/main.rs that we used to check the program\u2019s behavior.\nThen, in src/lib.rs, we'll add a tests module with a test function, as we did\nin Chapter 11. The test function specifies the behavior we want the search\n\nsrc/lib.rs\n\nsrc/lib.rs\n\nfunction to have: it will take a query and the text to search for the query\nin, and it will return only the lines from the text that contain the query.\nListing 12-15 shows this test, which won't compile yet.\n\n#[cfg(test) ]\nmod tests {\nuse super::*;\n\n#[test]\nfn one_result() {\nlet query = \"duct\";\nlet contents = \"\\\nRust:\nsafe, fast, productive.\nPick three.\";\n\nassert_eq! (\nvec![\"safe, fast, productive.\"],\nsearch(query, contents)\n\n}\n\nListing 12-15: Creating a failing test for the search function we wish we had\n\nThis test searches for the string \"duct\". The text we're searching is three\nlines, only one of which contains \"duct\". We assert that the value returned\nfrom the search function contains only the line we expect.\n\nWe aren't able to run this test and watch it fail because the test doesn\u2019t\neven compile: the search function doesn\u2019t exist yet! So now we'll add just\nenough code to get the test to compile and run by adding a definition of the\nsearch function that always returns an empty vector, as shown in Listing 12-16.\nThen the test should compile and fail because an empty vector doesn\u2019t match\na vector containing the line \"safe, fast, productive.\"\n\npub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {\n\nvec! []\n}\n\nListing 12-16: Defining just enough of the search function so our test will compile\n\nNotice that we need an explicit lifetime \u2018a defined in the signature of\nsearch and used with the contents argument and the return value. Recall in\nChapter 10 that the lifetime parameters specify which argument lifetime is\nconnected to the lifetime of the return value. In this case, we indicate that\nthe returned vector should contain string slices that reference slices of the\nargument contents (rather than the argument query).\n\nIn other words, we tell Rust that the data returned by the search function\nwill live as long as the data passed into the search function in the contents\nargument. This is important! The data referenced bya slice needs to be valid\nfor the reference to be valid; if the compiler assumes we're making string\nslices of query rather than contents, it will do its safety checking incorrectly.\n\nIf we forget the lifetime annotations and try to compile this function,\nwe'll get this error:\n\nerror[E0106]: missing lifetime specifier\n--> sre/lib.rs:5:51\n\n|\n5 | pub fn search(query: &str, contents: &str) -> Vec<&str> {\n\n| * expected lifetime\nparameter\n\n= help: this function's return type contains a borrowed value, but the\nsignature does not say whether it is borrowed from \u201cquery\u201d or \u201ccontents\u201d\n\nRust can\u2019t possibly know which of the two arguments we need, so we need\nto tell it. Because contents is the argument that contains all of our text and we\nwant to return the parts of that text that match, we know contents is the argu-\nment that should be connected to the return value using the lifetime syntax.\n\nOther programming languages don\u2019t require you to connect arguments\nto return values in the signature. Although this might seem strange, it will get\neasier over time. You might want to compare this example with \u201cValidating\nReferences with Lifetimes\u201d on page 192.\n\nNow let\u2019s run the test:\n\n$ cargo test\nCompiling minigrep v0.1.0 (file: ///projects/minigrep)\n--warnings--\nFinished dev [unoptimized + debuginfo] target(s) in 0.43 secs\nRunning target/debug/deps/minigrep-abcabcabc\n\nrunning 1 test\ntest tests::one_result ... FAILED\n\nfailures:\n---- tests::one_result stdout ----\nthread \u2018tests::one_result' panicked at \u2018assertion failed: ~(left ==\nright)\nleft: \u201c[\"safe, fast, productive.\"]*,\n\nright: \u201c[]\u00b0)', src/lib.rs:48:8\nnote: Run with ~RUST_BACKTRACE=1\u00b0 for a backtrace.\n\nfailures:\ntests::one_result\n\ntest result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out\n\nerror: test failed, to rerun pass '--lib\u2019\n\nGreat, the test fails, exactly as we expected. Let's get the test to pass!\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 12.21,
                        "section_name": "Writing Code to Pass the Test",
                        "section_path": "./screenshots-images-2/chapter_12/section_21",
                        "images": [
                            "./screenshots-images-2/chapter_12/section_21/3be1e23b-9780-4a01-b894-66d279b35a01.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Writing Code to Pass the Test\n\nCurrently, our test is failing because we always return an empty vector. To\nfix that and implement search, our program needs to follow these steps:\n\n1. Iterate through each line of the contents.\n\n2. Check whether the line contains our query string.\n3. fit does, add it to the list of values we're returning.\n4. Ifit doesn't, do nothing.\n\n5. Return the list of results that match.\n\nLet's work through each step, starting with iterating through lines.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 12.22,
                        "section_name": "Iterating Through Lines with the lines Method",
                        "section_path": "./screenshots-images-2/chapter_12/section_22",
                        "images": [
                            "./screenshots-images-2/chapter_12/section_22/c68c065e-a060-4590-a9df-177b8efa58c2.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/lib.rs\n\nIterating Through Lines with the lines Method\n\nRust has a helpful method to handle line-by-line iteration of strings, con-\nveniently named lines, that works as shown in Listing 12-17. Note this won\u2019t\ncompile yet.\n\npub fn search<'a>(query: &str, contents: &'a str > Vec<&'a str> {\nfor line in contents. lines() a\n// do something with line\n}\n\nListing 12-17: Iterating through each line in contents\n\nThe lines method returns an iterator. We'll talk about iterators in\ndepth in Chapter 13, but recall that you saw this way of using an iterator\nin Listing 3-5 on page 57, where we used a for loop with an iterator to\nrun some code on each item in a collection.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 12.23,
                        "section_name": "Searching Each Line for the Query",
                        "section_path": "./screenshots-images-2/chapter_12/section_23",
                        "images": [
                            "./screenshots-images-2/chapter_12/section_23/386a68b0-63ee-4ad5-a804-8b8ace055ad3.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/lib.rs\n\nSearching Each Line for the Query\n\nNext, we'll check whether the current line contains our query string.\nFortunately, strings have a helpful method named contains that does this\nfor us! Add a call to the contains method in the search function, as shown\nin Listing 12-18. Note this still won\u2019t compile yet.\n\nif line. contains (query) {\n\ndo something with line\n\n}\n\nListing 12-18: Adding functionality to see whether the line contains the string in query\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 12.24,
                        "section_name": "Storing Matching Lines",
                        "section_path": "./screenshots-images-2/chapter_12/section_24",
                        "images": [
                            "./screenshots-images-2/chapter_12/section_24/d4b9505e-3db7-4e3f-9bbf-9bc931f1976c.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/lib.rs\n\nStoring Matching Lines\n\nWe also need a way to store the lines that contain our query string. For that,\nwe can make a mutable vector before the for loop and call the push method\n\nto store a line in the vector. After the for loop, we return the vector, as shown\nin Listing 12-19.\n\npub fn search<'a>(query: &str, contents: &'a str)\n\nlet mut results = Vec::new();\n\nfor line in contents. lines()\n\nresults.push(line);\n\nresults\n}\n\nListing 12-19: Storing the lines that match so we can return them\n\nNow the search function should return only the lines that contain query,\nand our test should pass. Let\u2019s run the test:\n\n$ cargo test\n\n--snip--\n\nrunning 1 test\n\ntest tests::one_result ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n\nOur test passed, so we know it works!\n\nAt this point, we could consider opportunities for refactoring the\nimplementation of the search function while keeping the tests passing to\nmaintain the same functionality. The code in the search function isn\u2019t too\nbad, but it doesn\u2019t take advantage of some useful features of iterators. We'll\nreturn to this example in Chapter 13, where we'll explore iterators in detail,\nand look at how to improve it.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 12.25,
                        "section_name": "Using the search Function in the run Function",
                        "section_path": "./screenshots-images-2/chapter_12/section_25",
                        "images": [
                            "./screenshots-images-2/chapter_12/section_25/c81c9def-fded-4c39-a095-0e547f0042e2.png",
                            "./screenshots-images-2/chapter_12/section_25/97b3e7c6-9fe7-48f9-a5b6-4b253a4f5522.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "sre/lib.rs\n\nUsing the search Function in the run Function\n\nNow that the search function is working and tested, we need to call search\nfrom our run function. We need to pass the config. query value and the contents\nthat run reads from the file to the search function. Then run will print each\nline returned from search:\n\npub fn run(config: Config)\n\nlet contents = fs::read_to_st\n\nfor line in search(&config.query, &contents) {\nprintln!(\"{}\", line);\n\nWe're still using a for loop to return each line from search and print it.\nNow the entire program should work! Let's try it out, first with a word\nthat should return exactly one line from the Emily Dickinson poem, \u201cfrog\u201d:\n\n$ cargo run frog poem.txt\nCompiling minigrep v0.1.0 (file:///projects/minigrep)\nFinished dev [unoptimized + debuginfo] target(s) in 0.38 secs\nRunning \u201ctarget/debug/minigrep frog poem.txt\u2122\nHow public, like a frog\n\nCool! Now let\u2019s try a word that will match multiple lines, like \u201cbody\u201d:\n\n$ cargo run body poem.txt\nFinished dev [unoptimized + debuginfo] target(s) in 0.0 secs\nRunning \u201ctarget/debug/minigrep body poem.txt~\n\nI'm nobody! Who are you?\n\nAre you nobody, too?\n\nHow dreary to be somebody!\n\nAnd finally, let\u2019s make sure that we don\u2019t get any lines when we search\nfor a word that isn\u2019t anywhere in the poem, such as \u201cmonomorphization\u201d:\n\n$ cargo run monomorphization poem.txt\nFinished dev [unoptimized + debuginfo] target(s) in 0.0 secs\nRunning \u201ctarget/debug/minigrep monomorphization poem.txt*\n\nExcellent! We've built our own mini version of a classic tool and learned\na lot about how to structure applications. We've also learned a bit about file\ninput and output, lifetimes, testing, and command line parsing.\n\nTo round out this project, we'll briefly demonstrate how to work with\nenvironment variables and how to print to standard error, both of which\nare useful when you're writing command line programs.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 12.26,
                        "section_name": "Working with Environment Variables",
                        "section_path": "./screenshots-images-2/chapter_12/section_26",
                        "images": [
                            "./screenshots-images-2/chapter_12/section_26/a7f76f74-0f17-419f-813d-f016d77eb005.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Working with Environment Variables\n\nWe'll improve minigrep by adding an extra feature: an option for case-\ninsensitive searching that the user can turn on via an environment vari-\nable. We could make this feature a command line option and require\n\nthat users enter it each time they want it to apply, but instead we'll use an\nenvironment variable. Doing so allows our users to set the environment\nvariable once and have all their searches be case insensitive in that terminal\nsession.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 12.27,
                        "section_name": "Writing a Failing Test for the Case-Insensitive search Function",
                        "section_path": "./screenshots-images-2/chapter_12/section_27",
                        "images": [
                            "./screenshots-images-2/chapter_12/section_27/28e87f05-641a-4c95-88a6-2e5f0779c524.png",
                            "./screenshots-images-2/chapter_12/section_27/13c42f48-2b20-413d-b049-1e90a0db3a29.png",
                            "./screenshots-images-2/chapter_12/section_27/71ea8cff-ef27-4606-9cc3-cb3a741672d8.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Writing a Failing Test for the Case-Insensitive search Function\n\nWe want to add a new search_case_insensitive function that we'll call when\nthe environment variable is on. We'll continue to follow the TDD process,\n\n\nour failing test, and it will fail to compile because we haven't yet defined the\nsearch_case_insensitive function. Feel free to add a skeleton implementation\nthat always returns an empty vector, similar to the way we did for the search\nfunction in Listing 12-16 to see the test compile and fail.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 12.28,
                        "section_name": "Implementing the search_case_insensitive Function",
                        "section_path": "./screenshots-images-2/chapter_12/section_28",
                        "images": [
                            "./screenshots-images-2/chapter_12/section_28/4cc575e8-9bde-4bb9-ab50-6d7d2c09bc31.png",
                            "./screenshots-images-2/chapter_12/section_28/cc72b41e-a321-4636-aadc-e451a4746930.png",
                            "./screenshots-images-2/chapter_12/section_28/20105dee-fa43-4746-a6b2-fc2f4dcb7232.png",
                            "./screenshots-images-2/chapter_12/section_28/5dbfec19-d134-4152-8e9a-c2b3239f4ac6.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/lib.rs\n\nImplementing the search_case_insensitive Function\n\nThe search_case_insensitive function, shown in Listing 12-21, will be almost\nthe same as the search function. The only difference is that we'll lowercase the\nquery and each line so whatever the case of the input arguments, they'll be\nthe same case when we check whether the line contains the query.\n\npub fn search_case_insensitive<'a>(query: &str, contents: &'a str) -> Vec<&'a\nstr> {\n@ let query = query.to_lowercase();\n\nlet mut results = Vec::new();\n\nfor line in contents.lines() {\nif line.to_lowercase()@.contains(&query\u00ae) {\nresults.push(line) ;\n}\n\n}\n\nresults\n\n}\n\nListing 12-21: Defining the search_case_insensitive function to lowercase the query and\nthe line before comparing them\n\nFirst, we lowercase the query string and store it in a shadowed variable\nwith the same name @. Calling to_lowercase on the query is necessary so\nno matter whether the user\u2019s query is \"rust\", \"RUST\", \"Rust\", or \"rUsT\", we'll\ntreat the query as if it were \"rust\" and be insensitive to the case.\n\nNote that query is now a String rather than a string slice, because calling\nto_lowercase creates new data rather than referencing existing data. Say the\nquery is \"rUsT\", as an example: that string slice doesn\u2019t contain a lowercase\nu or t for us to use, so we have to allocate a new String containing \"rust\".\nWhen we pass query as an argument to the contains method now, we need to\nadd an ampersand \u00ae because the signature of contains is defined to take a\nstring slice.\n\nNext, we add a call to to_lowercase on each line before we check whether\nit contains query to lowercase all characters @. Now that we've converted line\nand query to lowercase, we'll find matches no matter what the case of the\nquery is.\n\nLet's see if this implementation passes the tests:\n\nrunning 2 tests\ntest tests::case_insensitive ... ok\ntest tests::case_sensitive ... ok\n\ntest result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n\n\nsrc/lib.rs\n\nsrc/lib.rs\n\nsrc/lib.rs\n\nGreat! They passed. Now, let\u2019s call the new search_case_insensitive func-\ntion from the run function. First, we'll add a configuration option to the\nConfig struct to switch between case-sensitive and case-insensitive search.\nAdding this field will cause compiler errors because we aren't initializing\nthis field anywhere yet:\n\nConfig {\ny: String,\n\npub s\n\nb qu\npub filename: String,\n\npub case_sensitive: \u201cbool,\n\nNote that we added the case_sensitive field that holds a Boolean. Next, we\nneed the run function to check the case_sensitive field\u2019s value and use that to\ndecide whether to call the search function or the search_case_insensitive func-\ntion, as shown in Listing 12-22. Note this still won't compile yet.\n\npub fn run(config: Conf\nlet contents fs::read\n\nlet results = if config.case_sensitive {\nsearch(&config.query, &contents)\n} else {\nsearch_case_insensitive(&config.query, &contents)\nhs\n\nfor line in results {\nprintln!(\"{}\", line);\n\nOk(\n}\n\nListing 12-22: Calling either search or search_case_insensitive based on the value in\nconfig.case_sensitive\n\nFinally, we need to check for the environment variable. The functions\nfor working with environment variables are in the env module in the stan-\ndard library, so we want to bring that module into scope with a use std::env;\nline at the top of src/lib.rs. Then we'll use the var function from the env mod-\nule to check for an environment variable named CASE_INSENSITIVE, as shown\nin Listing 12-23.\n\nuse std::env;\n\n/ --snip--\nimpl Config {\npub fn new(args: &[String]) -> Result<Config, &'static str> {\nf args.len() < 3 {\n\nreturn Err(\"\u201cnot enough arguments\");\n\nlet case_sensitive = env::var(\"CASE_INSENSITIVE\").is_err();\n\nOk(Config { query, filename, case_sensitive })\n\nListing 12-23: Checking for an environment variable named CASE_INSENSITIVE\n\nHere, we create a new variable case_sensitive. To set its value, we call the\nenv: :var function and pass it the name of the CASE_INSENSITIVE environment\nvariable. The env: :var function returns a Result that will be the successful 0k\nvariant that contains the value of the environment variable if the environ-\nment variable is set. It will return the Err variant if the environment variable\nis not set.\n\nWe're using the is_err method on the Result to check whether it\u2019s an\nerror and therefore unset, which means it should do a case-sensitive search.\nIf the CASE_INSENSITIVE environment variable is set to anything, is_err will\nreturn false and the program will perform a case-insensitive search. We\ndon\u2019t care about the value of the environment variable, just whether it\u2019s set\nor unset, so we're checking is_err rather than using unwrap, expect, or any of\nthe other methods we've seen on Result.\n\nWe pass the value in the case_sensitive variable to the Config instance\nso the run function can read that value and decide whether to call search or\nsearch_case_insensitive, as we implemented in Listing 12-22.\n\nLet's give it a try! First, we'll run our program without the environment\nvariable set and with the query to, which should match any line that contains\nthe word \u201cto\u201d in all lowercase:\n\n$ cargo run to poem.txt\nCompiling minigrep v0.1.0 (file:///projects/minigrep)\nFinished dev [unoptimized + debuginfo] target(s) in 0.0 secs\nRunning \u201ctarget/debug/minigrep to poem.txt\u201d\nAre you nobody, too?\nHow dreary to be somebody!\n\nLooks like that still works! Now, let\u2019s run the program with CASE\n_INSENSITIVE set to 1 but with the same query to.\n\nIf you're using PowerShell, you will need to set the environment variable\nand run the program in two commands rather than one:\n\n$ $env:CASE_INSENSITIVE=1\n$ cargo run to poem.txt\n\nWe should get lines that contain \u201cto\u201d that might have uppercase letters:\n\n$ CASE_INSENSITIVE=1 cargo run to poem.txt\nFinished dev [unoptimized + debuginfo] target(s) in 0.0 secs\nRunning \u201ctarget/debug/minigrep to poem.txt\u2122\n\nAre you nobody, too?\n\nHow dreary to be somebody!\n\nTo tell your name the livelong day\n\nTo an admiring bog!\n\nExcellent, we also got lines containing \u201cTo\u201d! Our minigrep program can\nnow do case-insensitive searching controlled by an environment variable.\nNow you know how to manage options set using either command line argu-\nments or environment variables.\n\nSome programs allow arguments and environment variables for the same\nconfiguration. In those cases, the programs decide that one or the other\ntakes precedence. For another exercise on your own, try controlling case\ninsensitivity through either a command line argument or an environment\nvariable. Decide whether the command line argument or the environment\nvariable should take precedence if the program is run with one set to case\nsensitive and one set to case insensitive.\n\nThe std: :env module contains many more useful features for dealing with\nenvironment variables: check out its documentation to see what is available.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 12.29,
                        "section_name": "Writing Error Messages to Standard Error Instead of\nStandard Output",
                        "section_path": "./screenshots-images-2/chapter_12/section_29",
                        "images": [
                            "./screenshots-images-2/chapter_12/section_29/1c4e817e-307e-429b-b126-df4754f9b604.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Writing Error Messages to Standard Error Instead of\nStandard Output\n\nAt the moment, we\u2019re writing all of our output to the terminal using the\nprintln! function. Most terminals provide two kinds of output: standard\noutput (stdout) for general information and standard error (stderr) for error\nmessages. This distinction enables users to choose to direct the successful\noutput of a program to a file but still print error messages to the screen.\n\nThe println! function is only capable of printing to standard output, so\nwe have to use something else to print to standard error.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 12.3,
                        "section_name": "Checking Where Errors Are Written",
                        "section_path": "./screenshots-images-2/chapter_12/section_30",
                        "images": [
                            "./screenshots-images-2/chapter_12/section_30/2cdaf05c-9db3-4625-8edf-5f123083b1fa.png",
                            "./screenshots-images-2/chapter_12/section_30/e37c54ad-7c3a-40fa-ba2a-ede6b055607b.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Checking Where Errors Are Written\n\nFirst, let's observe how the content printed by minigrep is currently being\nwritten to standard output, including any error messages we want to write\nto standard error instead. We'll do that by redirecting the standard output\nstream to a file while also intentionally causing an error. We won't redirect\nthe standard error stream, so any content sent to standard error will con-\ntinue to display on the screen.\n\nCommand line programs are expected to send error messages to the\nstandard error stream so we can still see error messages on the screen even\nif we redirect the standard output stream to a file. Our program is not cur-\nrently well-behaved: we're about to see that it saves the error message output\nto a file instead!\n\nThe way to demonstrate this behavior is by running the program with\n> and the filename, output.txt, that we want to redirect the standard output\nstream to. We won't pass any arguments, which should cause an error:\n\n$ cargo run > output.txt\n\nThe > syntax tells the shell to write the contents of standard output to\noutput.txt instead of the screen. We didn\u2019t see the error message we were\nexpecting printed to the screen, so that means it must have ended up in\nthe file. This is what output.txt contains:\n\nProblem parsing arguments: not enough arguments\n\nYup, our error message is being printed to standard output. It\u2019s much\nmore useful for error messages like this to be printed to standard error so\nonly data from a successful run ends up in the file. We'll change that.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 12.31,
                        "section_name": "Printing Errors to Standard Error",
                        "section_path": "./screenshots-images-2/chapter_12/section_31",
                        "images": [
                            "./screenshots-images-2/chapter_12/section_31/7d1a5306-a3ad-4934-b096-dda129fbe118.png",
                            "./screenshots-images-2/chapter_12/section_31/f21261bc-73e2-4f5b-8a12-cb6dd9eeb243.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nPrinting Errors to Standard Error\n\nWe'll use the code in Listing 12-24 to change how error messages are printed.\nBecause of the refactoring we did earlier in this chapter, all the code that\nprints error messages is in one function, main. The standard library provides\nthe eprintln! macro that prints to the standard error stream, so let\u2019s change the\ntwo places we were calling print1n! to print errors to use eprintln! instead.\n\nmain() {\n\nlet args: Vec<String> = env::args().collect\n\nlet config )\neprintln!(\u2019 roblen parsing arguments: 0\n\nprocess: :exi\n\n(}err\n\u00bb err);\n\n})3\n\nif let Err(e) minigrep: :run(cont\n\neprintln! (\"Application error: OQ\", e);\n\nprocess: :exit(1);\n\nListing 12-24: Writing error messages to standard error instead of standard output using\neprintln!\n\nAfter changing print1n! to eprint1n!, let\u2019s run the program again in the\nsame way, without any arguments and redirecting standard output with >:\n\n$ cargo run > output.txt\nProblem parsing arguments: not enough arguments\n\nNow we see the error onscreen and output.txt contains nothing, which is\nthe behavior we expect of command line programs.\n\noutput. txt\n\nLet\u2019s run the program again with arguments that don\u2019t cause an error\nbut still redirect standard output to a file, like so:\n\n$ cargo run to poem.txt > output.txt\n\nWe won't see any output to the terminal, and output.txt will contain our\nresults:\n\nAre you nobody, too?\nHow dreary to be somebody!\n\nThis demonstrates that we're now using standard output for successful\noutput and standard error for error output as appropriate.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 12.32,
                        "section_name": "Summary",
                        "section_path": "./screenshots-images-2/chapter_12/section_32",
                        "images": [
                            "./screenshots-images-2/chapter_12/section_32/70a3250b-08b2-4173-b34f-2af9e957c771.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Summary\n\nThis chapter recapped some of the major concepts you've learned so far\nand covered how to perform common I/O operations in Rust. By using\ncommand line arguments, files, environment variables, and the eprint1n!\nmacro for printing errors, you're now prepared to write command line\napplications. By using the concepts in previous chapters, your code will be\nwell organized, store data effectively in the appropriate data structures,\nhandle errors nicely, and be well tested.\n\nNext, we'll explore some Rust features that were influenced by functional\nlanguages: closures and iterators.\n",
                        "extracted-code": ""
                    }
                ]
            },
            {
                "chapter_id": 13,
                "chapter_name": "FUNCTIONAL LANGUAGE\nFEATURES: ITERATORS AND\nCLOSURES",
                "chapter_path": "./screenshots-images-2/chapter_13",
                "sections": [
                    {
                        "section_id": 13.1,
                        "section_name": "FUNCTIONAL LANGUAGE\nFEATURES: ITERATORS AND\nCLOSURES",
                        "section_path": "./screenshots-images-2/chapter_13/section_1",
                        "images": [
                            "./screenshots-images-2/chapter_13/section_1/270c7417-216e-465f-ac18-ec49b0390d81.png",
                            "./screenshots-images-2/chapter_13/section_1/e989dfc3-9f0d-44b9-973d-6446381420ab.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Rust\u2019s design has taken inspiration from\n\nmany existing languages and techniques,\nand one significant influence is functional\n\nprogramming. Programming in a functional style\n\noften includes using functions as values by passing\nthem in arguments, returning them from other func-\ntions, assigning them to variables for later execution,\nand so forth.\n\nIn this chapter, we won't debate the issue of what functional program-\nming is or isn\u2019t but will instead discuss some features of Rust that are simi-\nlar to features in many languages often referred to as functional.\n\nMore specifically, we'll cover:\n\ne Closures, a function-like construct you can store in a variable\n\ne \u2014 Iterators, a way of processing a series of elements\n\ne How to use these two features to improve the I/O project in Chapter 12\n\ne The performance of these two features (Spoiler alert: they're faster\nthan you might think!)\n\nOther Rust features, such as pattern matching and enums, which we've\ncovered in other chapters, are influenced by the functional style as well.\nMastering closures and iterators is an important part of writing idiomatic,\nfast Rust code, so we'll devote this entire chapter to them.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 13.2,
                        "section_name": "Closures: Anonymous Functions That Can Capture\nTheir Environment",
                        "section_path": "./screenshots-images-2/chapter_13/section_2",
                        "images": [
                            "./screenshots-images-2/chapter_13/section_2/04a8e070-dbea-4d41-ac77-b429fb47ca18.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Closures: Anonymous Functions That Can Capture\nTheir Environment\n\nRust\u2019s closures are anonymous functions you can save in a variable or pass\nas arguments to other functions. You can create the closure in one place\nand then call the closure to evaluate it in a different context. Unlike func-\ntions, closures can capture values from the scope in which they're defined.\nWe'll demonstrate how these closure features allow for code reuse and\nbehavior customization.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 13.3,
                        "section_name": "Geating an Abstraction of Behavior with Gosures",
                        "section_path": "./screenshots-images-2/chapter_13/section_3",
                        "images": [
                            "./screenshots-images-2/chapter_13/section_3/cc3f31ef-4905-477f-9ffb-219c9100e30a.png",
                            "./screenshots-images-2/chapter_13/section_3/87ae9690-e34c-46ae-a00d-a9484b83f0f5.png",
                            "./screenshots-images-2/chapter_13/section_3/f39cac02-2566-440d-a02c-e10f8712cb19.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nGeating an Abstraction of Behavior with Cosures\n\nLet\u2019s work on an example of a situation in which it\u2019s useful to store a closure\nto be executed later. Along the way, we'll talk about the syntax of closures,\ntype inference, and traits.\n\nConsider this hypothetical situation: we work at a startup that\u2019s making\nan app to generate custom exercise workout plans. The backend is written in\nRust, and the algorithm that generates the workout plan takes into account\nmany factors, such as the app user's age, body mass index, exercise prefer-\nences, recent workouts, and an intensity number they specify. The actual\nalgorithm used isn\u2019t important in this example; what's important is that this\ncalculation takes a few seconds. We want to call this algorithm only when\nwe need to and only call it once so we don\u2019t make the user wait more than\nnecessary.\n\nWe'll simulate calling this hypothetical algorithm with the function\nsimulated_expensive_calculation shown in Listing 13-1, which will print\ncalculating slowly..., wait for 2 seconds, and then return whatever num-\nber we passed in.\n\nuse std:: thread;\nuse std::time::Duration;\n\nfn simulated_expensive_calculation(intensity: u32) -> u32 {\nprintln! (\"calculating slowly...\");\nthread: :sleep(Duration: :from_secs(2));\nintensity\n\n}\n\nListing 13-1: A function to stand in for a hypothetical calculation that takes about\n2 seconds to run\n\nsrc/main.rs\n\nsrc/main.rs\n\nNext is the main function, which contains the parts of the workout app\nimportant for this example. This function represents the code that the app\nwill call when a user asks for a workout plan. Because the interaction with\nthe app\u2019s frontend isn\u2019t relevant to the use of closures, we'll hardcode values\nrepresenting inputs to our program and print the outputs.\n\nThe required inputs are these:\n\ne An intensity number from the user, which is specified when they request\na workout to indicate whether they want a low-intensity workout or a high-\nintensity workout\n\ne Arandom number that will generate some variety in the workout plans\n\nThe output will be the recommended workout plan. Listing 13-2 shows\nthe main function we'll use.\n\nfn main() {\nlet simulated_user_specified_value = 10;\nlet simulated_random_number = 7;\n\ngenerate_workout(\nsimulated_user_specified_value,\nsimulated_random_number\n)s\n}\n\nListing 13-2: A main function with hardcoded values to simulate user input and random\nnumber generation\n\nWe've hardcoded the variable simulated_user_specified_value as 10 and\nthe variable simulated_random_number as 7 for simplicity\u2019s sake; in an actual\nprogram, we'd get the intensity number from the app\u2019s frontend, and we'd\nuse the rand crate to generate a random number, as we did in the Guessing\nGame example in Chapter 2. The main function calls a generate_workout func-\ntion with the simulated input values.\n\nNow that we have the context, let\u2019s get to the algorithm. The function\ngenerate_workout in Listing 13-3 contains the business logic of the app that\nwe're most concerned with in this example. The rest of the code changes in\nthis example will be made to this function.\n\nfn generate_workout(intensity: u32, random_number: u32) {\n\u00a9 if intensity < 25 {\nprintln!(\n\u201cToday, do {} pushups!\",\nsimulated_expensive_calculation(intensity)\n\n)3\nprintln!(\n\"Next, do {} situps!\",\nsimulated_expensive_calculation(intensity)\n)s\n} else {\n\u00a9 if random_number == 3 {\nprintln!(\"Take a break today! Remember to stay hydrated!\");\n\n\u00a9 } else {\nprintln!(\n\u201cToday, run for {} minutes!\",\nsimulated_expensive_calculation(intensity)\n)3\n\n}\n\nListing 13-3: The business logic that prints the workout plans based on the inputs and calls\nto the simulated_expensive_calculation function\n\nThe code in Listing 13-3 has multiple calls to the slow calculation func-\ntion. The first if block @ calls simulated_expensive_calculation twice, the if\ninside the outer else @ doesn\u2019t call it at all, and the code inside the second\nelse case \u00a9 calls it once.\n\nThe desired behavior of the generate_workout function is to first check\nwhether the user wants a low-intensity workout (indicated by a number less\nthan 25) or a high-intensity workout (a number of 25 or greater).\n\nLow-intensity workout plans will recommend a number of push-ups and\nsit-ups based on the complex algorithm we're simulating.\n\nIf the user wants a high-intensity workout, there\u2019s some additional logic:\nif the value of the random number generated by the app happens to be 3,\nthe app will recommend a break and hydration. If not, the user will get a\nnumber of minutes of running based on the complex algorithm.\n\nThis code works the way the business wants it to now, but let\u2019s say the\ndata science team decides that we need to make some changes to the way we\ncall the simulated_expensive_calculation function in the future. To simplify the\nupdate when those changes happen, we want to refactor this code so it calls\nthe simulated_expensive_calculation function only once. We also want to cut the\nplace where we're currently unnecessarily calling the function twice without\nadding any other calls to that function in the process. That is, we don\u2019t want\nto call it if the result isn\u2019t needed, and we still want to call it only once.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 13.4,
                        "section_name": "Refactoring Using Functions",
                        "section_path": "./screenshots-images-2/chapter_13/section_4",
                        "images": [
                            "./screenshots-images-2/chapter_13/section_4/8a267b11-b4fc-4cc3-ae01-9deca87bc220.png",
                            "./screenshots-images-2/chapter_13/section_4/67e7e8d7-eb8b-4f7b-81ea-c0207da24080.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Refactoring Using Functions\n\nWe could restructure the workout program in many ways. First, we'll try\nextracting the duplicated call to the simulated_expensive_calculation function\ninto a variable, as shown in Listing 13-4.\n\nsrc/main.rs fn generate_workout (int \u00bb random number: u32) {\nlet expensive_result = simulated | expensive_calculation(intensity) ;\n\nif intensity < 25 {\nprintln!(\n\"Today, do {} pushups!\"\nexpensive_result\nprintln!(\n\"Next, do {} situps!\",\nexpensive_result\n\nprintln!(\n\na break today! Remember to stay hyd\n\nprintln!(\n\"Today, run for {} minutes!\",\n\nexpensive_result\n\nListing 13-4: Extracting the calls to simulated_expensive_calculation to one place and\nstoring the result in the expensive_result variable\n\nThis change unifies all the calls to simulated_expensive_calculation and\nsolves the problem of the first if block unnecessarily calling the function\ntwice. Unfortunately, we're now calling this function and waiting for the\nresult in all cases, which includes the inner if block that doesn\u2019t use the result\nvalue at all.\n\nWe want to define code in one place in our program but only execute\nthat code where we actually need the result. This is a use case for closures!\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 13.5,
                        "section_name": "Refactoring with Closures to Store Code",
                        "section_path": "./screenshots-images-2/chapter_13/section_5",
                        "images": [
                            "./screenshots-images-2/chapter_13/section_5/e6b9b5b9-1c5d-42d2-bcaf-7f4ad5a9fa90.png",
                            "./screenshots-images-2/chapter_13/section_5/4508cbd8-314e-406e-8353-94e555785691.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nRefactoring with Closures to Store Code\n\nInstead of always calling the simulated_expensive_calculation function before\nthe if blocks, we can define a closure and store the closure in a variable rather\nthan storing the result of the function call, as shown in Listing 13-5. We can\nactually move the whole body of simulated_expensive_calculation within the\nclosure we're introducing here.\n\nlet expensive _closure = |num| {\nprintln!(\"calculating slowly...\");\nthread: :sleep(Duration: :from_secs(2));\nnum\n\n}s\n\nListing 13-5: Defining a closure and storing it in the expensive_closure variable\n\nThe closure definition comes after the = to assign it to the variable\nexpensive_closure. To define a closure, we start with a pair of vertical pipes\n(|), inside which we specify the parameters to the closure; this syntax was\nchosen because of its similarity to closure definitions in Smalltalk and Ruby.\nThis closure has one parameter named num: ifwe had more than one param-\neter, we would separate them with commas, like |param1, param2|.\n\nAfter the parameters, we place curly brackets that hold the body of the\nclosure\u2014these are optional if the closure body is a single expression. The\nend of the closure, after the curly brackets, needs a semicolon to complete\nthe let statement. The value returned from the last line in the closure body\n(num) will be the value returned from the closure when it\u2019s called, because\nthat line doesn\u2019t end in a semicolon, just as in function bodies.\n\nsrc/main.rs\n\nNote that this let statement means expensive_closure contains the defini-\ntion of an anonymous function, not the resulting value of calling the anony-\nmous function. Recall that we're using a closure because we want to define\nthe code to call at one point, store that code, and call it at a later point; the\ncode we want to call is now stored in expensive_closure.\n\nWith the closure defined, we can change the code in the if blocks to call\nthe closure to execute the code and get the resulting value. We call a closure\nlike we do a function: we specify the variable name that holds the closure\ndefinition and follow it with parentheses containing the argument values we\nwant to use, as shown in Listing 13-6.\n\nn generate_workout (intensity:\nlet expensive _closure = |num| {\nprintln! (\"calculating slowly...\");\nthread: :sleep(Duration: :from_secs(2));\nnum\n\nrandom_number: u32) {\n\n}s\n\nf intensity < 25 {\nprint1n!(\n\"Today, do {} pushups!\",\nexpensive_closure(intensity)\nprintln!(\n\"Next, do {} situps!\",\n\nexpensive_closure(intensity)\n\nfC\nDS\n\nt\nif random number 3 {\nprintln! (\"Take a break today\n\n} else {\nprintln! (\n\n! Remember to stay hydrated!\");\n\nToday, run for {} minutes!\",\n\nexpensive_closure(intensity)\n\n}\n\nListing 13-6: Calling the expensive_closure we've defined\n\nNow the expensive calculation is called in only one place, and we're\nonly executing that code where we need the results.\n\nHowever, we've reintroduced one of the problems from Listing 13-3:\nwe're still calling the closure twice in the first if block, which will call the\nexpensive code twice and make the user wait twice as long as they need to.\nWe could fix this problem by creating a variable local to that if block to\nhold the result of calling the closure, but closures provide us with another\nsolution. We'll talk about that solution in a bit. But first let\u2019s talk about\nwhy there aren\u2019t type annotations in the closure definition and the traits\ninvolved with closures.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 13.6,
                        "section_name": "Closure Type Inference and Annotation",
                        "section_path": "./screenshots-images-2/chapter_13/section_6",
                        "images": [
                            "./screenshots-images-2/chapter_13/section_6/bbb0b8ba-b055-4aae-90fa-5ebe08d52fa6.png",
                            "./screenshots-images-2/chapter_13/section_6/199b9c00-2815-4e1a-b21a-6bfd0b67a6d3.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nClosure Type Inference and Annotation\n\nClosures don\u2019t require you to annotate the types of the parameters or the\nreturn value like fn functions do. Type annotations are required on functions\nbecause they're part of an explicit interface exposed to your users. Defining\nthis interface rigidly is important for ensuring that everyone agrees on what\ntypes of values a function uses and returns. But closures aren't used in an\nexposed interface like this: they're stored in variables and used without nam-\ning them and exposing them to users of our library.\n\nClosures are usually short and relevant only within a narrow context\nrather than in any arbitrary scenario. Within these limited contexts, the\ncompiler is reliably able to infer the types of the parameters and the return\ntype, similar to how it\u2019s able to infer the types of most variables.\n\nMaking programmers annotate the types in these small, anonymous\nfunctions would be annoying and largely redundant with the information\nthe compiler already has available.\n\nAs with variables, we can add type annotations if we want to increase\nexplicitness and clarity at the cost of being more verbose than is strictly\nnecessary. Annotating the types for the closure we defined in Listing 13-5\nwould look like the definition shown in Listing 13-7.\n\nlet expensive closure = |num: u32| -> u32 {\nprintlr alculating s eee\")\nthread: :sleep(Duratior\n\nnun\n\nListing 13-7: Adding optional type annotations of the parameter and return value types in\nthe closure\n\nWith type annotations added, the syntax of closures looks more similar\nto the syntax of functions. The following is a vertical comparison of the syn-\ntax for the definition of a function that adds 1 to its parameter and a closure\nthat has the same behavior. We've added some spaces to line up the relevant\nparts. This illustrates how closure syntax is similar to function syntax except\nfor the use of pipes and the amount of syntax that is optional:\n\nfn addone_vi (x: u32) -> u32 {x +1}\nlet add_one_v2 = |x: u32| -> u32 { x + 1 };\nlet add_one_v3 = |x| {x+1};\nlet add_one_v4 = |x| x+1 ;\n\nThe first line shows a function definition, and the second line shows a\nfully annotated closure definition. The third line removes the type annota-\ntions from the closure definition, and the fourth line removes the brackets,\nwhich are optional because the closure body has only one expression. These\nare all valid definitions that will produce the same behavior when they\u2019re\ncalled.\n\nClosure definitions will have one concrete type inferred for each of their\nparameters and for their return value. For instance, Listing 13-8 shows the\n\nsrc/main.rs\n\ndefinition of a short closure that just returns the value it receives as a param-\neter. This closure isn\u2019t very useful except for the purposes of this example.\nNote that we haven't added any type annotations to the definition: if we then\ntry to call the closure twice, using a String as an argument the first time and a\nu32 the second time, we'll get an error.\n\nlet example closure = |x| x;\n\nlet s = example_closure(String::from(\"hello\"));\nlet n = example_closure(5);\n\nListing 13-8: Attempting to call a closure whose types are inferred with two different types\n\nThe compiler gives us this error:\n\nerror[E0308]: mismatched types\n--> src/main.rs\n\n|\n\n| let n = example_closure(5);\n\n| * expected struct \u201cstd::string::String\u2019, found\nintegral variable\n\n|\n= note: expected type \u201cstd::string: :String\u201d\nfound type ~ {integer}\n\nThe first time we call example_closure with the String value, the compiler\ninfers the type of x and the return type of the closure to be String. Those\ntypes are then locked into the closure in example_closure, and we get a type\nerror if we try to use a different type with the same closure.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 13.7,
                        "section_name": "Storing Closures Using Generic Parameters and the Fn Traits",
                        "section_path": "./screenshots-images-2/chapter_13/section_7",
                        "images": [
                            "./screenshots-images-2/chapter_13/section_7/a1aeb2e8-c97f-4560-b712-603abe2e9b9f.png",
                            "./screenshots-images-2/chapter_13/section_7/ddd5cf7d-0b29-4820-a43b-b04a0cd90418.png",
                            "./screenshots-images-2/chapter_13/section_7/96fcc5a2-8b66-491f-971f-99dab7aa0f37.png",
                            "./screenshots-images-2/chapter_13/section_7/89fda19c-6dbe-43ad-a384-b1a438c7a211.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Storing Closures Using Generic Parameters and the Fn Traits\n\nLet\u2019s return to our workout generation app. In Listing 13-6, our code was\n\nstill calling the expensive calculation closure more times than it needed to.\nOne option to solve this issue is to save the result of the expensive closure\nin a variable for reuse and use the variable in each place we need the result,\ninstead of calling the closure again. However, this method could result in a\n\nlot of repeated code.\n\nFortunately, another solution is available to us. We can create a struct\nthat will hold the closure and the resulting value of calling the closure.\nThe struct will execute the closure only if we need the resulting value, and\nit will cache the resulting value so the rest of our code doesn\u2019t have to be\nresponsible for saving and reusing the result. You may know this pattern\nas memoization or lazy evaluation.\n\nTo make a struct that holds a closure, we need to specify the type of the\nclosure, because a struct definition needs to know the types of each of its\nfields. Each closure instance has its own unique anonymous type: that is, even\nif two closures have the same signature, their types are still considered differ-\nent. To define structs, enums, or function parameters that use closures, we\nuse generics and trait bounds, as we discussed in Chapter 10.\n\nsrc/main.rs\n\nsrc/main.rs\n\nThe Fn traits are provided by the standard library. All closures imple-\nment at least one of the traits: Fn, FnMut, or FnOnce. We'll discuss the differ-\nence between these traits in \u201cCapturing the Environment with Closures\u201d on\npage 274; in this example, we can use the Fn trait.\n\nWe add types to the Fn trait bound to represent the types of the param-\neters and return values the closures must have to match this trait bound. In\nthis case, our closure has a parameter of type u32 and returns a u32, so the\ntrait bound we specify is Fn(u32) -> u32.\n\nListing 13-9 shows the definition of the Cacher struct that holds a closure\nand an optional result value.\n\nstruct Cacher<T>\nwhere T: Fn(u32) -> u32\n\ncalculation: T,\nvalue: Option<u32>,\n\n}\n\nListing 13-9: Defining a Cacher struct that holds a closure in calculation and an optional\nresult in value\n\nThe Cacher struct has a calculation field of the generic type T. The trait\nbounds on T specify that it\u2019s a closure by using the Fn trait. Any closure we\nwant to store in the calculation field must have one u32 parameter (specified\nwithin the parentheses after Fn) and must return a u32 (specified after the ->).\n\nFunctions can implement all three of the Fn traits, too. If what we want to do doesn't\nrequire capturing a value from the environment, we can use a function rather than a\nclosure where we need something that implements an Fn trait.\n\nThe value field is of type Option<u32>. Before we execute the closure, value\nwill be None. When code using a Cacher asks for the result of the closure, the\nCacher will execute the closure at that time and store the result within a Some\nvariant in the value field. Then if the code asks for the result of the closure\nagain, instead of executing the closure again, the Cacher will return the result\nheld in the Some variant.\n\nThe logic around the value field we've just described is defined in\nListing 13-10.\n\nimpl<T> Cacher<T>\n@ where T: Fn(u32) -> u32\n\n@ fn new(calculation: T) -> Cacher<T> {\n\n\u00ae Cacher {\ncalculation,\nvalue: None,\n}\n\n}\n\n\u00a9 fn value(&mut self, arg: u32) -> u32 {\nmatch self.value {\n\n\u00a9 Some(v) => v,\n\n@ None => {\nlet v = (self.calculation) (arg);\nself.value = Some(v);\nv\n\n}\n\n}\n\nListing 13-10: The caching logic of Cacher\n\nWe want Cacher to manage the struct fields\u2019 values rather than letting\nthe calling code potentially change the values in these fields directly, so\nthese fields are private.\n\nThe Cacher: :new function takes a generic parameter T \u00a9, which we've\ndefined as having the same trait bound as the Cacher struct \u00ae. Then\nCacher: :new returns a Cacher instance \u00ae that holds the closure specified in\nthe calculation field and a None value in the value field, because we haven\u2019t\nexecuted the closure yet.\n\nWhen the calling code needs the result of evaluating the closure, instead\nof calling the closure directly, it will call the value method \u00a9. This method\nchecks whether we already have a resulting value in self.value in a Some; if we\ndo, it returns the value within the Some without executing the closure again \u00a9.\n\nIf self.value is None, the code calls the closure stored in self.calculation,\nsaves the result in self.value for future use, and returns the value as well \u00a9.\n\nListing 13-11 shows how we can use this Cacher struct in the function\ngenerate_workout from Listing 13-6.\n\nsrc/main.rs fn generate _workout(intensity: u32, random_number: u32\n@ let mut expensive result = Cacher::new(|num| {\nprintln! (\"calculating slowly...\");\n\nthread: :sleep(Duration: :from_secs(2));\n\nnum\n\n})3\n\n\"Today, do {} pus st\"\n\n\u00a9 expensive_result. value (intensity)\n\nprint lin!\n\"Next, do {} situps\n@ expensive | result. value (intensity)\n\n} else {\n\nif random_number\nprintln!(\"Take a break today\n\n! Remember to stay hydrated!\"\n\n} else {\nprintln! (\nToday, run for {} minutes!\",\n\u00a9 expensive_result.value(intensity)\n);\n\nListing 13-11: Using Cacher in the generate_workout function to abstract away the caching\nlogic\n\nInstead of saving the closure in a variable directly, we save a new\ninstance of Cacher that holds the closure \u00ae. Then, in each place we want\nthe result @\u00a9 9, we call the value method on the Cacher instance. We can\ncall the value method as many times as we want, or not call it at all, and the\nexpensive calculation will be run a maximum of once.\n\nTry running this program with the main function from Listing 13-2.\nChange the values in the simulated_user_specified_value and simulated_random_\nnumber variables to verify that in all the cases in the various if and else blocks,\ncalculating slowly... appears only once and only when needed. The Cacher\ntakes care of the logic necessary to ensure we aren't calling the expensive cal-\nculation more than we need to so generate_workout can focus on the business\n\nlogic.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 13.8,
                        "section_name": "Limitations of the Cacher Implementation",
                        "section_path": "./screenshots-images-2/chapter_13/section_8",
                        "images": [
                            "./screenshots-images-2/chapter_13/section_8/b1875c91-554a-4c18-aa65-ff61e52a081f.png",
                            "./screenshots-images-2/chapter_13/section_8/b0ec3b98-511c-4233-89d4-da41c541add4.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Limitations of the Cacher Implementation\n\nCaching values is a generally useful behavior that we might want to use in\nother parts of our code with different closures. However, there are two prob-\nlems with the current implementation of Cacher that would make reusing it in\ndifferent contexts difficult.\n\nThe first problem is that a Cacher instance assumes it will always get the\nsame value for the parameter arg to the value method. That is, this test of\nCacher will fail:\n\n[test]\nfn call_with_different_values() {\nlet mut c = Cacher::new(|a| a);\n\nlet vi\nlet v2\n\nc.value(1);\nc.value(2);\n\nassert_eq! (v2, 2);\n\nThis test creates a new Cacher instance with a closure that returns the\nvalue passed into it. We call the value method on this Cacher instance with\nan arg value of 1 and then an arg value of 2, and we expect the call to value\nwith the arg value of 2 to return 2.\n\nRun this test with the Cacher implementation in Listing 13-9 and\nListing 13-10, and the test will fail on the assert_eq! with this message:\n\nthread \u2018call_with_different_values' panicked at \u2018assertion failed: \u201c(left ==\nright)~\nleft: \u201c1\u00b0,\nst\n\nright: \u00bb src/main.rs\n\nThe problem is that the first time we called c.value with 1, the Cacher\ninstance saved Some(1) in self.value. Thereafter, no matter what we pass in\nto the value method, it will always return 1.\n\nTry modifying Cacher to hold a hash map rather than a single value.\nThe keys of the hash map will be the arg values that are passed in, and the\nvalues of the hash map will be the result of calling the closure on that key.\nInstead of looking at whether self.value directly has a Some or a None value,\nthe value function will look up the arg in the hash map and return the value\nif it\u2019s present. If it\u2019s not present, the Cacher will call the closure and save the\nresulting value in the hash map associated with its arg value.\n\nThe second problem with the current Cacher implementation is that it\nonly accepts closures that take one parameter of type u32 and return a u32.\nWe might want to cache the results of closures that take a string slice and\nreturn usize values, for example. To fix this issue, try introducing more\ngeneric parameters to increase the flexibility of the Cacher functionality.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 13.9,
                        "section_name": "Capturing the Environment with Closures",
                        "section_path": "./screenshots-images-2/chapter_13/section_9",
                        "images": [
                            "./screenshots-images-2/chapter_13/section_9/d760b94c-555d-46de-89a3-84d912a2e627.png",
                            "./screenshots-images-2/chapter_13/section_9/a9b8c453-ccb4-4ff2-9e46-5f4a74766243.png",
                            "./screenshots-images-2/chapter_13/section_9/e7def6ee-bc78-463a-9765-7d7737162725.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nsrc/main.rs\n\nO74\n\nClentae 12\n\nCapturing the Environment with Closures\n\nIn the workout generator example, we only used closures as inline anony-\nmous functions. However, closures have an additional capability that func-\ntions don\u2019t have: they can capture their environment and access variables\nfrom the scope in which they're defined.\n\nListing 13-12 has an example of a closure stored in the equal_to_x vari-\nable that uses the x variable from the closure\u2019s surrounding environment.\n\nfn main() {\nlet x =\n\n4;\nlet equal_to_x = |z| z == x;\nlet y = 4;\n\nassert! (equal_to_x(y));\n}\n\nListing 13-12: Example of a closure that refers to a variable in its enclosing scope\n\nHere, even though x is not one of the parameters of equal_to_x, the\nequal_to_x closure is allowed to use the x variable that\u2019s defined in the same\nscope that equal_to_x is defined in.\n\nWe can't do the same with functions; if we try with the following example,\nour code won't compile:\n\nn main\nlet x = 4;\n\nfn equal_to_x(z: i32) -> bool { z == x }\n\nlet y = 4;\n\nWe get an error:\n\nerror[E0434]: can't capture dynamic environment in a fn item; use the || { ...\n} closure form instead\n--> src/main.rs\n\n|\n4 | fn equal_to_x(z: 132) -> bool { z == x }\n\nThe compiler even reminds us that this only works with closures!\n\nWhen a closure captures a value from its environment, it uses memory\nto store the values for use in the closure body. This use of memory is over-\nhead that we don\u2019t want to pay in more common cases where we want to\nexecute code that doesn\u2019t capture its environment. Because functions are\nnever allowed to capture their environment, defining and using functions\nwill never incur this overhead.\n\nClosures can capture values from their environment in three ways,\nwhich directly map to the three ways a function can take a parameter: tak-\ning ownership, borrowing mutably, and borrowing immutably. These are\nencoded in the three Fn traits as follows:\n\n\u00a2 \u2014 FnOnce consumes the variables it captures from its enclosing scope, known\nas the closure\u2019s environment. To consume the captured variables, the clo-\nsure must take ownership of these variables and move them into the\nclosure when it is defined. The Once part of the name represents the fact\nthat the closure can\u2019t take ownership of the same variables more than\nonce, so it can be called only once.\n\ne  FnMut can change the environment because it mutably borrows values.\ne Fn borrows values from the environment immutably.\n\nWhen you create a closure, Rust infers which trait to use based on how\nthe closure uses the values from the environment. All closures implement\nFnOnce because they can all be called at least once. Closures that don\u2019t move\nthe captured variables also implement FnMut, and closures that don\u2019t need\nmutable access to the captured variables also implement Fn. In Listing 13-12,\nthe equal_to_x closure borrows x immutably (so equal_to_x has the Fn trait)\nbecause the body of the closure only needs to read the value in x.\n\nIf you want to force the closure to take ownership of the values it uses\nin the environment, you can use the move keyword before the parameter list.\nThis technique is mostly useful when passing a closure to a new thread to\nmove the data so it\u2019s owned by the new thread.\n\nWe'll have more examples of move closures in Chapter 16 when we talk\nabout concurrency. For now, here\u2019s the code from Listing 13-12 with the\nmove keyword added to the closure definition and using vectors instead of\nintegers, because integers can be copied rather than moved; note that this\ncode will not yet compile.\n\nsrc/main.rs\n\nfn main() {\nlet x = vec![1, 2, 3];\n\nlet equal_to_x = move |z| z == x;\nprintln!(\"can't use x here: {:?}\", x);\nlet y = vec![1, 2, 3];\n\nassert! (equal_to_x(y));\n\nWe receive the following error:\n\nerror[E0382]: use of moved value: \u201cx\n--> src/main.rs:6:40\n\n4| let equal_to_x = move |z| z == x;\nee value moved (into closure) here\n\n|\n5 |\n6 | println!(\"can't use x here: {:?}\", x);\n| * value used here after move\n|\n\nnote: move occurs because \u201cx\u201d has type ~std::vec::Vec<i32>\u00b0, which does\nnot implement the \u201cCopy\u201d trait\n\nThe x value is moved into the closure when the closure is defined,\nbecause we added the move keyword. The closure then has ownership of x,\nand main isn\u2019t allowed to use x anymore in the print1n! statement. Removing\nprint1n! will fix this example.\n\nMost of the time when specifying one of the Fn trait bounds, you can\nstart with Fn and the compiler will tell you if you need FnMut or FnOnce based on\nwhat happens in the closure body.\n\nTo illustrate situations where closures that can capture their environment\nare useful as function parameters, let\u2019s move on to our next topic: iterators.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 13.1,
                        "section_name": "Processing a Series of Items with Iterators",
                        "section_path": "./screenshots-images-2/chapter_13/section_10",
                        "images": [
                            "./screenshots-images-2/chapter_13/section_10/2c01198d-a33b-43d8-b9ba-2db7fd850a21.png",
                            "./screenshots-images-2/chapter_13/section_10/325fd994-fe15-4d7e-9d38-b6d275390b65.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Processing a Series of Items with Iterators\n\nThe iterator pattern allows you to perform some task on a sequence of items\nin turn. An iterator is responsible for the logic of iterating over each item\nand determining when the sequence has finished. When you use iterators,\nyou don\u2019t have to reimplement that logic yourself.\n\nIn Rust, iterators are lazy, meaning they have no effect until you call\nmethods that consume the iterator to use it up. For example, the code in\nListing 13-13 creates an iterator over the items in the vector v1 by calling\nthe iter method defined on Vec<T>. This code by itself doesn\u2019t do anything\nuseful.\n\nlet vi = vec![1, 2, 3];\nlet vi_iter = vi.iter();\n\nListing 13-13: Creating an iterator\n\nOnce we've created an iterator, we can use it in a variety of ways. In\nListing 3-5, we used iterators with for loops to execute some code on each\nitem, although we glossed over what the call to iter did until now.\n\nThe example in Listing 13-14 separates the creation of the iterator from\nthe use of the iterator in the for loop. The iterator is stored in the vi_iter\nvariable, and no iteration takes place at that time. When the for loop is called\nusing the iterator in v1_iter, each element in the iterator is used in one itera-\ntion of the loop, which prints each value.\n\nlet vi = vec![1, 2, 3];\nlet vi_iter = v1.iter();\n\nfor val in vi_iter {\nprintln!(\"Got: {}\", val);\n}\n\nListing 13-14: Using an iterator in a for loop\n\nIn languages that don\u2019t have iterators provided by their standard\nlibraries, you would likely write this same functionality by starting a vari-\nable at index 0, using that variable to index into the vector to get a value,\nand incrementing the variable value in a loop until it reached the total\nnumber of items in the vector.\n\nIterators handle all that logic for you, cutting down on repetitive code\nyou could potentially mess up. Iterators give you more flexibility to use the\nsame logic with many different kinds of sequences, not just data structures\nyou can index into, like vectors. Let\u2019s examine how iterators do that.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 13.11,
                        "section_name": "The Iterator Trait and the next Method",
                        "section_path": "./screenshots-images-2/chapter_13/section_11",
                        "images": [
                            "./screenshots-images-2/chapter_13/section_11/dc1d13b2-af09-41e0-8ce3-9f20e5959b4a.png",
                            "./screenshots-images-2/chapter_13/section_11/45bdac19-e420-47bd-8f4d-82dc79ef503c.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "The Iterator Trait and the next Method\n\nAll iterators implement a trait named Iterator that is defined in the standard\nlibrary. The definition of the trait looks like this:\n\npub trait Iterator {\ntype Item;\n\nfn next(&mut self) -> Option<Self::Item>;\n// methods with default implementations elided\nNotice this definition uses some new syntax: type Item and Self: :Item,\n\nwhich are defining an associated type with this trait. We'll talk about associated\ntypes in depth in Chapter 19. For now, all you need to know is that this code\n\nsre/lib.rs\n\nsays implementing the Iterator trait requires that you also define an Item type,\nand this Item type is used in the return type of the next method. In other\nwords, the Item type will be the type returned from the iterator.\n\nThe Iterator trait only requires implementors to define one method:\nthe next method, which returns one item of the iterator at a time wrapped\nin Some and, when iteration is over, returns None.\n\nWe can call the next method on iterators directly; Listing 13-15 demon-\nstrates what values are returned from repeated calls to next on the iterator\ncreated from the vector.\n\n#[test]\nfn iterator_demonstration() {\nlet vi = vec![1, 2, 3];\n\nlet mut vi_iter = v1.iter();\n\nassert_eq!(v1_iter.next(), Some(&1));\nassert_eq!(v1_iter.next(), Some(&2));\nassert_eq!(v1_iter.next(), Some(&3));\nassert_eq!(v1_iter.next(), None);\n\n}\n\nListing 13-15: Calling the next method on an iterator\n\nNote that we needed to make vi_iter mutable: calling the next method\non an iterator changes internal state that the iterator uses to keep track of\nwhere it is in the sequence. In other words, this code consumes, or uses up,\nthe iterator. Each call to next eats up an item from the iterator. We didn\u2019t\nneed to make v1_iter mutable when we used a for loop because the loop\ntook ownership of v1_iter and made it mutable behind the scenes.\n\nAlso note that the values we get from the calls to next are immutable\nreferences to the values in the vector. The iter method produces an iterator\nover immutable references. If we want to create an iterator that takes own-\nership of vi and returns owned values, we can call into_iter instead of iter.\nSimilarly, if we want to iterate over mutable references, we can call iter_mut\ninstead of iter.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 13.12,
                        "section_name": "Methods That Consume the Iterator",
                        "section_path": "./screenshots-images-2/chapter_13/section_12",
                        "images": [
                            "./screenshots-images-2/chapter_13/section_12/969bfc21-aa5e-4c2a-b01e-d3a334799bd7.png",
                            "./screenshots-images-2/chapter_13/section_12/8ec64549-4a32-4284-bf5d-7c2d6c57fec5.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Methods That Consume the Iterator\n\nThe Iterator trait has a number of different methods with default imple-\nmentations provided by the standard library; you can find out about these\nmethods by looking in the standard library API documentation for the\nIterator trait. Some of these methods call the next method in their defini-\ntion, which is why you're required to implement the next method when\nimplementing the Iterator trait.\n\nMethods that call next are referred to as consuming adaptors, because\ncalling them uses up the iterator. One example is the sum method, which\ntakes ownership of the iterator and iterates through the items by repeatedly\ncalling next, thus consuming the iterator. As it iterates through, it adds each\nitem to a running total and returns the total when iteration is complete.\nListing 13-16 has a test illustrating a use of the sum method.\n\nsrc/lib.rs\n\n#[test]\nfn iterator_sum() {\nlet v1 = vec![1, 2, 3];\nlet vi_iter = vi.iter();\nlet total: i32 = vi_iter.sum();\n\nassert_eq! (total, 6);\n}\n\nListing 13-16: Calling the sum method to get the total of all items in the iterator\n\nWe aren't allowed to use v1_iter after the call to sum because sum takes\nownership of the iterator we call it on.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 13.13,
                        "section_name": "Methods That Produce Other Iterators",
                        "section_path": "./screenshots-images-2/chapter_13/section_13",
                        "images": [
                            "./screenshots-images-2/chapter_13/section_13/a7e3130f-bdd6-48e2-bc9f-6520be35eb28.png",
                            "./screenshots-images-2/chapter_13/section_13/abe800fb-ba18-474a-b9cc-272aa2b38503.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nMethods That Produce Other Iterators\n\nOther methods defined on the Iterator trait, known as iterator adaptors,\nallow you to change iterators into different kinds of iterators. You can\nchain multiple calls to iterator adaptors to perform complex actions in a\nreadable way. But because all iterators are lazy, you have to call one of the\nconsuming adaptor methods to get results from calls to iterator adaptors.\n\nListing 13-17 shows an example of calling the iterator adaptor method\nmap, Which takes a closure to call on each item to produce a new iterator. The\nclosure here creates a new iterator in which each item from the vector has\nbeen incremented by 1. However, this code produces a warning.\n\nlet vi: Vec<i32> = vec![1, 2, 3];\nvi.iter().map(|x| x + 1);\nListing 13-17: Calling the iterator adaptor map to create a new iterator\nThe warning we get is this:\nwarning: unused \u201cstd::iter::Map\u2019 which must be used: iterator adaptors are\nlazy and do nothing unless consumed\n\n--> src/main.rs:4:5\n\n4 vi.iter().map({x| x + 1);\n\n| AAAAAAAAAAAAARAAAAAAAAAAA\n\nnote: #[warn(unused_must_use)] on by default\n\nThe code in Listing 13-17 doesn\u2019t do anything; the closure we've specified\nnever gets called. The warning reminds us why: iterator adaptors are lazy, and\nwe need to consume the iterator here.\n\nTo fix this and consume the iterator, we'll use the collect method, which\nwe used with env:args in Listing 12-1. This method consumes the iterator and\ncollects the resulting values into a collection data type.\n\nsrc/main.rs\n\nIn Listing 13-18, we collect the results of iterating over the iterator that\u2019s\nreturned from the call to map into a vector. This vector will end up containing\neach item from the original vector incremented by 1.\n\nlet vi: Vec<i32> = vec![1, 2, 3];\nlet v2: Vec<_> = vi1.iter().map({x| x + 1).collect();\n\nassert_eq!(v2, vec![2, 3, 4]);\n\nListing 13-18: Calling the map method to create a new iterator and then calling the collect\nmethod to consume the new iterator and create a vector\n\nBecause map takes a closure, we can specify any operation we want to\nperform on each item. This is a great example of how closures let you cus-\ntomize some behavior while reusing the iteration behavior that the Iterator\ntrait provides.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 13.14,
                        "section_name": "Using Closures That Capture Their Environment",
                        "section_path": "./screenshots-images-2/chapter_13/section_14",
                        "images": [
                            "./screenshots-images-2/chapter_13/section_14/c024be80-5d5a-4c37-83c9-840e8e3a8a1d.png",
                            "./screenshots-images-2/chapter_13/section_14/4836dbd9-4ad7-4718-b612-41e6add6def6.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/lib.rs\n\nUsing Closures That Capture Their Environment\n\nNow that we've introduced iterators, we can demonstrate a common use of\nclosures that capture their environment by using the filter iterator adaptor.\nThe filter method on an iterator takes a closure that takes each item from\nthe iterator and returns a Boolean. If the closure returns true, the value will\nbe included in the iterator produced by filter. If the closure returns false,\nthe value won't be included in the resulting iterator.\n\nIn Listing 13-19, we use filter with a closure that captures the shoe_size\nvariable from its environment to iterate over a collection of Shoe struct\ninstances. It will return only shoes that are the specified size.\n\n#[derive(PartialEq, Debug) ]\nstruct Shoe {\n\nsize: u32,\n\nstyle: String,\n}\n\nfn shoes_in_my_size(shoes: Vec<Shoe>, shoe_size: u32) -> Vec<Shoe> {\n\u00a9 shoes. into_iter()\n\n\u00a9 .filter(|s| s.size == shoe_size)\n\n\u00ae .collect()\n}\n\n#[test]\nfn filters by size() {\nlet shoes = vec![\nShoe { size: 10, style: String::from(\"sneaker\") },\nShoe { size: 13, style: String::from(\"sandal\") },\nShoe { size: 10, style: String::from(\"boot\") },\n13\n\nlet in_my size = shoes_in_my size(shoes, 10);\n\nassert_eq!(\nin_my_size,\nvec! [\nShoe { size: 10, style: String::from(\"sneaker\") },\nShoe { size: 10, style: String::from(\"boot\") },\n]\n)3\n}\n\nListing 13-19: Using the filter method with a closure that captures shoe_size\n\nThe shoes_in_my_size function takes ownership of a vector of shoes and\na shoe size as parameters @. It returns a vector containing only shoes of the\nspecified size.\n\nIn the body of shoes_in_my size, we call into_iter to create an iterator that\ntakes ownership of the vector \u00ae. Then we call filter to adapt that iterator\ninto a new iterator that only contains elements for which the closure returns\ntrue \u00ae.\n\nThe closure captures the shoe_size parameter from the environment\nand compares the value with each shoe's size, keeping only shoes of the size\nspecified. Finally, calling collect gathers the values returned by the adapted\niterator into a vector that\u2019s returned by the function \u00a9.\n\nThe test shows that when we call shoes_in_my_size, we get back only shoes\nthat have the same size as the value we specified.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 13.15,
                        "section_name": "Grating Our Own Iterators with the Iterator Trait",
                        "section_path": "./screenshots-images-2/chapter_13/section_15",
                        "images": [
                            "./screenshots-images-2/chapter_13/section_15/5b43dcf9-2e8f-402d-965e-11bf945cbbf0.png",
                            "./screenshots-images-2/chapter_13/section_15/b665f3b9-802c-4620-b44d-7b9f35c514b9.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/lib.rs\n\nCreating Our Own Iterators with the Iterator Trait\n\nWe\u2019ve shown that you can create an iterator by calling iter, into_iter, or\niter_mut on a vector. You can create iterators from the other collection types\nin the standard library, such as hash map. You can also create iterators that\ndo anything you want by implementing the Iterator trait on your own types.\nAs previously mentioned, the only method you're required to provide a defi-\nnition for is the next method. Once you've done that, you can use all other\nmethods that have default implementations provided by the Iterator trait!\n\nTo demonstrate, let\u2019s create an iterator that will only ever count from\n1 to 5. First, we'll create a struct to hold some values. Then we'll make this\nstruct into an iterator by implementing the Iterator trait and using the\nvalues in that implementation.\n\nListing 13-20 has the definition of the Counter struct and an associated\nnew function to create instances of Counter.\n\nstruct Counter {\ncount: u32,\n}\n\nimpl Counter {\nfn new() -> Counter {\nCounter { count: 0 }\n\nsrc/lib.rs\n\n}\n\nListing 13-20: Defining the Counter struct and a new function that creates instances of\nCounter with an initial value of O for count\n\nThe Counter struct has one field named count. This field holds a u32 value\nthat will keep track of where we are in the process of iterating from 1 to 5.\nThe count field is private because we want the implementation of Counter to\nmanage its value. The new function enforces the behavior of always starting\nnew instances with a value of 0 in the count field.\n\nNext, we'll implement the Iterator trait for our Counter type by defining\nthe body of the next method to specify what we want to happen when this\niterator is used, as shown in Listing 13-21.\n\nimpl Iterator for Counter {\ntype Item = u32;\n\nfn next(&mut self) -> Option<Self::Item> {\nself.count += 1;\n\nif self.count < 6 {\nSome(self.count)\n} else {\nNone\n}\n\n}\n\nListing 13-21: Implementing the Iterator trait on our Counter struct\n\nWe set the associated Item type for our iterator to u32, meaning the itera-\ntor will return u32 values. Again, don\u2019t worry about associated types yet, we'll\ncover them in Chapter 19.\n\nWe want our iterator to add 1 to the current state, so we initialized\ncount to 0 so it would return 1 first. If the value of count is less than 6, next\nwill return the current value wrapped in Some, but if count is 6 or higher, our\niterator will return None.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 13.16,
                        "section_name": "Using Our Counter Iterator\u2019s next Method",
                        "section_path": "./screenshots-images-2/chapter_13/section_16",
                        "images": [
                            "./screenshots-images-2/chapter_13/section_16/f683f091-e57f-45fd-93e1-608bae506e6b.png",
                            "./screenshots-images-2/chapter_13/section_16/21fb7c87-9d4c-4b5d-9223-f43b35f20e47.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/lib.rs\n\nUsing Our Counter Iterator\u2019s next Method\n\nOnce we've implemented the Iterator trait, we have an iterator! Listing 13-22\nshows a test demonstrating that we can use the iterator functionality of our\nCounter struct by calling the next method on it directly, just as we did with\nthe iterator created from a vector in Listing 13-15.\n\n#[test]\nfn calling next_directly() {\nlet mut counter = Counter: :new();\n\nassert_eq!(counter.next(), Some(1));\nassert_eq!(counter.next(), Some(2));\nassert_eq!(counter.next(), Some(3));\nassert_eq!(counter.next(), Some(4));\nassert_eq!(counter.next(), Some(S));\nassert_eq!(counter.next(), None);\n\n}\n\nListing 13-22: Testing the functionality of the next method implementation\n\nThis test creates a new Counter instance in the counter variable and then\ncalls next repeatedly, verifying that we have implemented the behavior we\nwant this iterator to have: returning the values from 1 to 5.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 13.17,
                        "section_name": "Using Other Iterator Trait Methods",
                        "section_path": "./screenshots-images-2/chapter_13/section_17",
                        "images": [
                            "./screenshots-images-2/chapter_13/section_17/397864f7-f932-4f63-affb-c1f8511d518d.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/lib.rs\n\nUsing Other Iterator Trait Methods\n\nWe implemented the Iterator trait by defining the next method, so we can\nnow use any Iterator trait method\u2019s default implementations as defined in\nthe standard library, because they all use the next method\u2019s functionality.\n\nFor example, if for some reason we wanted to take the values produced\nby an instance of Counter, pair them with values produced by another Counter\ninstance after skipping the first value, multiply each pair together, keep\nonly those results that are divisible by 3, and add all the resulting values\ntogether, we could do so, as shown in the test in Listing 13-23.\n\n#[test]\nfn using other_iterator_trait_methods() {\nlet sum: u32 = Counter: :new().zip(Counter::new().skip(1))\nsmap(|(a, b)| a * b)\n-filter(|x| x % 3 == 0)\n\u00absum();\nassert_eq!(18, sum);\n}\n\nListing 13-23: Using a variety of Iterator trait methods on our Counter iterator\n\nNote that zip produces only four pairs; the theoretical fifth pair (5, None)\nis never produced because zip returns None when either of its input iterators\nreturns None.\n\nAll of these method calls are possible because we specified how the next\nmethod works, and the standard library provides default implementations\nfor other methods that call next.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 13.18,
                        "section_name": "Improving Our I/O Project",
                        "section_path": "./screenshots-images-2/chapter_13/section_18",
                        "images": [
                            "./screenshots-images-2/chapter_13/section_18/415434b1-7aef-4693-8916-db04ee75efbf.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Improving Our I/O Project\n\nWith this new knowledge about iterators, we can improve the I/O project in\nChapter 12 by using iterators to make places in the code clearer and more\nconcise. Let's look at how iterators can improve our implementation of the\nConfig: :new function and the search function.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 13.19,
                        "section_name": "Removing a clone Using an Iterator",
                        "section_path": "./screenshots-images-2/chapter_13/section_19",
                        "images": [
                            "./screenshots-images-2/chapter_13/section_19/d981ced0-1e81-488b-9a9c-49e385897c31.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/lib.rs\n\nRemoving a clone Using an Iterator\n\nIn Listing 12-6, we added code that took a slice of String values and created an\ninstance of the Config struct by indexing into the slice and cloning the values,\nallowing the Config struct to own those values. In Listing 13-24, we've repro-\nduced the implementation of the Config: :new function as it was in Listing 12-23.\n\nimpl Config {\npub fn new(args: &[String]) -> Result<Config, &'static str> {\nif args.len() < 3 {\nreturn Err(\"not enough arguments\");\n}\n\nlet query = args[1].clone();\nlet filename = args[2].clone();\n\nlet case_sensitive = env::var(\"CASE_INSENSITIVE\").is err();\n\nOk(Config { query, filename, case_sensitive })\n\n}\n}\n\nListing 13-24: Reproduction of the Config: :new function from Listing 12-23\n\nAt the time, we said not to worry about the inefficient clone calls because\nwe would remove them in the future. Well, that time is now!\n\nWe needed clone here because we have a slice with String elements in the\nparameter args, but the new function doesn\u2019t own args. To return ownership of\na Config instance, we had to clone the values from the query and filename fields\nof Config so the Config instance can own its values.\n\nWith our new knowledge about iterators, we can change the new function\nto take ownership of an iterator as its argument instead of borrowing a slice.\nWe'll use the iterator functionality instead of the code that checks the length\nof the slice and indexes into specific locations. This will clarify what the\nConfig: :new function is doing because the iterator will access the values.\n\nOnce Config: :new takes ownership of the iterator and stops using indexing\noperations that borrow, we can move the String values from the iterator into\nConfig rather than calling clone and making a new allocation.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 13.2,
                        "section_name": "Using the Returned Iterator Directly",
                        "section_path": "./screenshots-images-2/chapter_13/section_20",
                        "images": [
                            "./screenshots-images-2/chapter_13/section_20/1c2e2dfa-ab39-48bf-a73a-ec5e89726970.png",
                            "./screenshots-images-2/chapter_13/section_20/a50d5408-1c99-4055-a7e3-2f601b725247.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Using the Returned Iterator Directly\nOpen your I/O project\u2019s sr\u00a2/main.rs file, which should look like this:\n\nsrc/main.rs fn main() {\nlet args: Vec<String> = env::args().collect();\n\nlet config = Config: :new(&args).unwrap or_else(|err| {\neprintln! (\"Problem parsing arguments: {}\", err);\nprocess: :exit(1);\n\n})3\n// --snip--\n\n\nsrc/main.rs\n\nsrc/lib.rs\n\nWe'll change the start of the main function that we had in Listing 12-24\nto the code in Listing 13-25. This won\u2019t compile until we update Config: :new\nas well.\n\nTN main(\nlet config = Config: :new(env::args()). unwrap_or _else(jerr| {\n\ntln!(\"Problem parsing arguments: {}\", err);\n\nexit (4\n\nListing 13-25: Passing the return value of env: :args to Config: :new\n\nThe env: :args function returns an iterator! Rather than collecting\nthe iterator values into a vector and then passing a slice to Config: :new,\nnow we're passing ownership of the iterator returned from env: :args to\nConfig: :new directly.\n\nNext, we need to update the definition of Config: :new. In your I/O\nproject's src/lib.rs file, let\u2019s change the signature of Config: :new to look like\nListing 13-26. This still won\u2019t compile because we need to update the\nfunction body.\n\nontig {\n\npub fn new(mut args: std::env::Args) -> Result<Config, &'static str> {\n\nListing 13-26: Updating the signature of Config: :new to expect an iterator\n\nThe standard library documentation for the env: :args function shows\nthat the type of the iterator it returns is std: :env: :Args. We've updated the\nsignature of the Config: :new function so the parameter args has the type\nstd: :env: :Args instead of &[String]. Because we're taking ownership of args\nand we'll be mutating args by iterating over it, we can add the mut keyword\ninto the specification of the args parameter to make it mutable.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 13.21,
                        "section_name": "Using Iterator Trait Methods Instead of Indexing",
                        "section_path": "./screenshots-images-2/chapter_13/section_21",
                        "images": [
                            "./screenshots-images-2/chapter_13/section_21/f069c103-1d4d-4942-b925-122c7b0cfd39.png",
                            "./screenshots-images-2/chapter_13/section_21/a7b8e8d1-03b8-476f-8fc7-fd99d940bdf5.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/lib.rs\n\nUsing Iterator Trait Methods Instead of Indexing\n\nNext, we'll fix the body of Config: :new. The standard library documentation\nalso mentions that std: :env::Args implements the Iterator trait, so we know\nwe can call the next method on it! Listing 13-27 updates the code from\nListing 12-23 to use the next method.\n\nimpl Config\n\nargs.next();\n\nlet query = match args.next() {\nSome(arg) => arg,\nNone => return Err(\"Didn't get a query string\"),\n\n}3\n\nlet filename = match args.next() {\n\n}\n\nSome(arg) => arg,\nNone => return Err(\"Didn't get a file name\"),\n\nk(Config { query, filename, case_sensitive }\n\nListing 13-27: Changing the body of Config: :new to use iterator methods\n\nRemember that the first value in the return value of env: :args is the name\nof the program. We want to ignore that and get to the next value, so first we\ncall next and do nothing with the return value. Second, we call next to get the\nvalue we want to put in the query field of Config. If next returns a Some, we use\na match to extract the value. If it returns None, it means not enough arguments\nwere given and we return early with an Err value. We do the same thing for\nthe filename value.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 13.22,
                        "section_name": "Making Code Clearer with Iterator Adaptors",
                        "section_path": "./screenshots-images-2/chapter_13/section_22",
                        "images": [
                            "./screenshots-images-2/chapter_13/section_22/0bb0e08d-e8a9-4d6a-9d16-9abecc5ab967.png",
                            "./screenshots-images-2/chapter_13/section_22/edfd6396-536f-4939-81f7-78de11d88543.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Making Code Clearer with Iterator Adaptors\nWe can also take advantage of iterators in the search function in our I/O\n\nproject, which is reproduced in Listing 13-28 as it was in Listing 12-19.\n\nsrc/lib.rs pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {\nlet mut results = Vec::new();\n\nfor line in contents.lines() {\nif line.contains(query) {\nresults.push(line);\n}\n\n}\n\nresults\n\n}\n\nListing 13-28: The implementation of the search function from Listing 12-19\n\nWe can write this code in a more concise way using iterator adap-\ntor methods. Doing so also lets us avoid having a mutable intermediate\nresults vector. The functional programming style prefers to minimize the\namount of mutable state to make code clearer. Removing the mutable state\nmight enable a future enhancement to make searching happen in parallel,\nbecause we wouldn\u2019t have to manage concurrent access to the results vec-\ntor. Listing 13-29 shows this change.\n\nsrc/lib.rs\n\npub fn search<'a>(query: &str, conte\n\ncontents. lines()\n\n-filter(|line| line.contains(query))\n-collect()\n\nListing 13-29: Using iterator adaptor methods in the implementation of the search function\n\nRecall that the search function\u2019s purpose is to return all lines in contents\nthat contain the query. Similar to the filter example in Listing 13-19, this\ncode uses the filter adaptor to keep only the lines that line.contains (query)\nreturns true for. We then collect the matching lines into another vector with\ncollect. Much simpler! Feel free to make the same change to use iterator\nmethods in the search_case_insensitive function as well.\n\nThe next logical question is which style you should choose in your own\ncode and why: the original implementation in Listing 13-28 or the version\nusing iterators in Listing 13-29. Most Rust programmers prefer to use the\niterator style. It\u2019s a bit tougher to get the hang of at first, but once you get\na feel for the various iterator adaptors and what they do, iterators can be\neasier to understand. Instead of fiddling with the various bits of looping\nand building new vectors, the code focuses on the high-level objective of\nthe loop. This abstracts away some of the commonplace code so it\u2019s easier to\nsee the concepts that are unique to this code, such as the filtering condition\neach element in the iterator must pass.\n\nBut are the two implementations truly equivalent? The intuitive assump-\ntion might be that the more low-level loop will be faster. Let\u2019s talk about\nperformance.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 13.23,
                        "section_name": "Comparing Performance: Loops vs. Iterators",
                        "section_path": "./screenshots-images-2/chapter_13/section_23",
                        "images": [
                            "./screenshots-images-2/chapter_13/section_23/97a710cd-7c64-4910-92e8-bb7717842b74.png",
                            "./screenshots-images-2/chapter_13/section_23/9f5c1b62-a0e7-4b11-a21c-564c310dc8e6.png",
                            "./screenshots-images-2/chapter_13/section_23/afb067ab-73b4-405b-ac9a-299dbd7a5a5c.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Comparing Performance: Loops vs. Iterators\n\nTo determine whether to use loops or iterators, you need to know which ver-\nsion of the search function is faster: the version with an explicit for loop or\nthe version with iterators.\n\nWe ran a benchmark by loading the entire contents of The Adventures of\nSherlock Holmes by Sir Arthur Conan Doyle into a String and looking for the\nword the in the contents. Here are the results of the benchmark on the ver-\nsion of search using the for loop and the version using iterators:\n\ntest bench_search_ for ... bench: 19,620,300 ns/iter (+/- 915,700)\ntest bench_search_iter ... bench: 19,234,900 ns/iter (+/- 657,200)\n\nThe iterator version was slightly faster! We won't explain the benchmark\ncode here, because the point is not to prove that the two versions are equiva-\nlent but to get a general sense of how these two implementations compare\nperformance-wise.\n\nFor a more comprehensive benchmark, you should check using vari-\nous texts of various sizes as the contents, different words, words of dif-\nferent lengths as the query, and all kinds of other variations. The point\nis this: iterators, although a high-level abstraction, get compiled down to\nroughly the same code as if you'd written the lower-level code yourself.\nIterators are one of Rust\u2019s zero-cost abstractions, by which we mean using the\nabstraction imposes no additional runtime overhead. This is analogous\nto how Bjarne Stroustrup, the original designer and implementor of C++,\ndefines zero-overhead in \u201cFoundations of C++\u201d (2012):\n\nIn general, C++ implementations obey the zero-overhead prin-\nciple: What you don\u2019t use, you don\u2019t pay for. And further: What\nyou do use, you couldn\u2019t hand code any better.\n\nAs another example, the following code is taken from an audio decoder.\nThe decoding algorithm uses the linear prediction mathematical operation\nto estimate future values based on a linear function of the previous samples.\nThis code uses an iterator chain to do some math on three variables in scope:\na buffer slice of data, an array of 12 coefficients, and an amount by which to\nshift data in qlp_shift. We've declared the variables within this example but\nnot given them any values; although this code doesn\u2019t have much meaning\noutside of its context, it\u2019s still a concise, real-world example of how Rust trans-\nlates high-level ideas to low-level code.\n\nlet buffer: &mut [132];\nlet coefficients: [i64; 12];\nlet qlp_shift: i16;\n\nfor i in 12..buffer.len() {\nlet prediction = coefficients.iter()\n-zip(&buffer[i - 12..i])\n-map(|(&c, &s)| \u00a2 * s as i64)\n\u00absum: :<i64>() >> qlp_shift;\nlet delta\nbuffer[i]\n\nbuffer[i];\nprediction as i32 + delta;\n\nTo calculate the value of prediction, this code iterates through each of\nthe 12 values in coefficients and uses the zip method to pair the coefficient\nvalues with the previous 12 values in buffer. Then, for each pair, we multiply\nthe values together, sum all the results, and shift the bits in the sum qlp_shift\nbits to the right.\n\nCalculations in applications like audio decoders often prioritize perfor-\nmance most highly. Here, we're creating an iterator, using two adaptors, and\nthen consuming the value. What assembly code would this Rust code com-\npile to? Well, as of this writing, it compiles down to the same assembly you'd\nwrite by hand. There\u2019s no loop at all corresponding to the iteration over the\nvalues in coefficients: Rust knows that there are 12 iterations, so it \u201cunrolls\u201d\n\nthe loop. Unrolling is an optimization that removes the overhead of the loop-\ncontrolling code and instead generates repetitive code for each iteration of\nthe loop.\n\nAll of the coefficients get stored in registers, which means accessing the\nvalues is very fast. There are no bounds checks on the array access at run-\ntime. All these optimizations that Rust is able to apply make the resulting\ncode extremely efficient. Now that you know this, you can use iterators and\nclosures without fear! They make code seem like it\u2019s higher level but don\u2019t\nimpose a runtime performance penalty for doing so.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 13.24,
                        "section_name": "Summary",
                        "section_path": "./screenshots-images-2/chapter_13/section_24",
                        "images": [
                            "./screenshots-images-2/chapter_13/section_24/39af56ce-9858-49fc-8d01-028f7cd18f63.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Summary\n\nClosures and iterators are Rust features inspired by functional programming\nlanguage ideas. They contribute to Rust\u2019s capability to clearly express high-\nlevel ideas at low-level performance. The implementations of closures and\niterators are such that runtime performance is not affected. This is part of\nRust\u2019s goal to strive to provide zero-cost abstractions.\n\nNow that we've improved the expressiveness of our I/O project, let\u2019s\nlook at some more features of cargo that will help us share the project with\nthe world.\n",
                        "extracted-code": ""
                    }
                ]
            },
            {
                "chapter_id": 14,
                "chapter_name": "MORE ABOUT CARGO AND\nCRATES.IO",
                "chapter_path": "./screenshots-images-2/chapter_14",
                "sections": [
                    {
                        "section_id": 14.1,
                        "section_name": "MORE ABOUT CARGO AND\nCRATES.IO",
                        "section_path": "./screenshots-images-2/chapter_14/section_1",
                        "images": [
                            "./screenshots-images-2/chapter_14/section_1/a2be01e4-29d8-42a2-8d22-c8c8e3d36103.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "So far we\u2019ve used only the most basic\nfeatures of Cargo to build, run, and test\nour code, but it can do a lot more. In this\nchapter, we\u2019ll discuss some of its other, more\nadvanced features to show you how to do the following:\n\ne\u00a2 Customize your build through release profiles\n\u00a2 Publish libraries on Attps://crates.io/\n\ne Organize large projects with workspaces\n\ne Install binaries from https://crates.io/\n\ne Extend Cargo using custom commands\n\nCargo can do even more than what we cover in this chapter, so for a full\nexplanation of all its features, see its documentation at Attps://doc.rust-lang\n\n.org/cargo/.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 14.2,
                        "section_name": "Customizing Builds with Release Profiles",
                        "section_path": "./screenshots-images-2/chapter_14/section_2",
                        "images": [
                            "./screenshots-images-2/chapter_14/section_2/7e1524bc-1a42-46ec-b482-be628c5dafff.png",
                            "./screenshots-images-2/chapter_14/section_2/9d003f72-de57-4768-9d82-21c107f3c8c3.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Customizing Builds with Release Profiles\n\nCargo.toml\n\nCargo.toml\n\nIn Rust, release profiles are predefined and customizable profiles with different\nconfigurations that allow a programmer to have more control over various\noptions for compiling code. Each profile is configured independently of the\nothers.\n\nCargo has two main profiles: the dev profile Cargo uses when you run\ncargo build and the release profile Cargo uses when you run cargo build\n--release. The dev profile is defined with good defaults for development,\nand the release profile has good defaults for release builds.\n\nThese profile names might be familiar from the output of your builds:\n\n$ cargo build\n\nFinished dev [unoptimized + debuginfo] target(s) in 0.0 secs\n$ cargo build --release\n\nFinished release [optimized] target(s) in 0.0 secs\n\nThe dev and release shown in this build output indicate that the compiler\nis using different profiles.\n\nCargo has default settings for each of the profiles that apply when there\naren\u2019t any [profile.*] sections in the project\u2019s Cargo.toml file. By adding\n[profile.*] sections for any profile you want to customize, you can over-\nride any subset of the default settings. For example, here are the default\nvalues for the opt-level setting for the dev and release profiles:\n\n[profile.dev]\nopt-level = 0\n\n[profile. release]\nopt-level = 3\n\nThe opt-level setting controls the number of optimizations Rust will\napply to your code, with a range of 0 to 3. Applying more optimizations\nextends compiling time, so if you're in development and compiling your\ncode often, you'll want faster compiling even if the resulting code runs\nslower. That is the reason the default opt-level for dev is 0. When you're\nready to release your code, it\u2019s best to spend more time compiling. You'll\nonly compile in release mode once, but you'll run the compiled program\nmany times, so release mode trades longer compile time for code that runs\nfaster. That\u2019s why the default opt-level for the release profile is 3.\n\nYou can override any default setting by adding a different value for it in\nCargo.toml. For example, if we want to use optimization level 1 in the devel-\nopment profile, we can add these two lines to our project\u2019s Cargo.toml file:\n\n[profile.dev]\nopt-level = 1\n\nThis code overrides the default setting of 0. Now when we run cargo\nbuild, Cargo will use the defaults for the dev profile plus our customization\n\nto opt-level. Because we set opt-level to 1, Cargo will apply more optimiza-\ntions than with the default settings, but not as many as in a release build.\n\nFor the full list of configuration options and defaults for each profile,\nsee Cargo\u2019s documentation at https://doc.rust-lang.org/cargo/.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 14.3,
                        "section_name": "Publishing a Crate to Crates.io",
                        "section_path": "./screenshots-images-2/chapter_14/section_3",
                        "images": [
                            "./screenshots-images-2/chapter_14/section_3/31cb3079-4bb5-424d-8187-e988f92c726c.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Publishing a Crate to Crates.io\n\nWe've used packages from https://crates.io/ as dependencies of our project,\nbut you can also share your code with other people by publishing your own\npackages. The crate registry at Attps://crates.io/ distributes the source code\nof your packages, so it primarily hosts code that is open source.\n\nRust and Cargo have features that help make your published package\neasier for people to use and to find in the first place. We'll talk about some\nof these features next and then explain how to publish a package.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 14.4,
                        "section_name": "Making Useful Documentation Comments",
                        "section_path": "./screenshots-images-2/chapter_14/section_4",
                        "images": [
                            "./screenshots-images-2/chapter_14/section_4/87724a59-e01f-436b-a6cd-ce9c2930874b.png",
                            "./screenshots-images-2/chapter_14/section_4/94b3ed35-4e49-4d2f-b287-d9ddcc43bad4.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/lib.rs\n\nMaking Useful Documentation Comments\n\nAccurately documenting your packages will help other users know how and\nwhen to use them, so it\u2019s worth investing the time to write documentation.\nIn Chapter 3, we discussed how to comment Rust code using two slashes, //.\nRust also has a particular kind of comment for documentation, known con-\nveniently as a documentation comment, that will generate HTML documenta-\ntion. The HTML displays the contents of documentation comments for\npublic API items intended for programmers interested in knowing how to\nuse your crate as opposed to how your crate is implemented.\n\nDocumentation comments use three slashes, ///, instead of two and\nsupport Markdown notation for formatting the text. Place documentation\ncomments just before the item they're documenting. Listing 14-1 shows docu-\nmentation comments for an add_one function in a crate named my_crate.\n\n/// Adds one to the number given.\n\nMi\n\n/// # Examples\n\nMi\n\nde\n\n/// let arg = 5;\n\n/// let answer =\n\nMf\n\n/// assert_eq!(6, answer);\n\nWp\n\npub fn add one(x: i32) -> i32 {\nx#1\n\n}\n\nmy_crate::add_one(arg);\n\nListing 14-1: A documentation comment for a function\n\nHere, we give a description of what the add_one function does, start\na section with the heading Examples, and then provide code that demon-\nstrates how to use the add_one function. We can generate the HTML docu-\nmentation from this documentation comment by running cargo doc. This\n\ncommand runs the rustdoc tool distributed with Rust and puts the gener-\nated HTML documentation in the target/doc directory.\n\nFor convenience, running cargo doc --open will build the HTML for your\ncurrent crate\u2019s documentation (as well as the documentation for all of your\ncrate\u2019s dependencies) and open the result in a web browser. Navigate to the\nadd_one function and you'll see how the text in the documentation comments\nis rendered, as shown in Figure 14-1.\n\n\u00a2/  Clicko S\u2019 to search, \u2018?' for more options @\n\nFunctions .\n| Function my_crate::add_one (Hsre]\nadd_one\npub fn add_one(x: 132) -> 132\nCrates\n{-] Adds one to the number given.\nmy crate\nExamples\nlet arg=5\n\nlet answer = my_crate::add_one(arg);\n\nassert_eq!(6, answer);\n\nFigure 14-1: HTML documentation for the add_one function\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 14.5,
                        "section_name": "Commonly Used Sections",
                        "section_path": "./screenshots-images-2/chapter_14/section_5",
                        "images": [
                            "./screenshots-images-2/chapter_14/section_5/8fa923fb-8356-4282-880e-2bb3e7d6637d.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Commonly Used Sections\n\nWe used the # Examples Markdown heading in Listing 14-1 to create a section\nin the HTML with the title \u201cExamples.\u201d Here are some other sections that\ncrate authors commonly use in their documentation:\n\nPanics The scenarios in which the function being documented could\npanic. Callers of the function who don\u2019t want their programs to panic\nshould make sure they don\u2019t call the function in these situations.\n\nErrors If the function returns a Result, describing the kinds of errors\nthat might occur and what conditions might cause those errors to be\nreturned can be helpful to callers so they can write code to handle the\ndifferent kinds of errors in different ways.\n\nSafety If the function is unsafe to call (we discuss unsafety in\nChapter 19), there should be a section explaining why the function\nis unsafe and covering the invariants that the function expects callers\nto uphold.\n\nMost documentation comments don\u2019t need all of these sections, but this\nis a good checklist to remind you of the aspects of your code that people\ncalling your code will be interested in knowing about.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 14.6,
                        "section_name": "Documentation Comments as Tests",
                        "section_path": "./screenshots-images-2/chapter_14/section_6",
                        "images": [
                            "./screenshots-images-2/chapter_14/section_6/892867c4-6f17-4f95-b953-ee6aeabd44a0.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Documentation Comments as Tests\n\nAdding example code blocks to your documentation comments can help\ndemonstrate how to use your library, and doing so has an additional bonus:\nrunning cargo test will run the code examples in your documentation as\ntests! Nothing is better than documentation with examples. But nothing is\nworse than examples that don\u2019t work because the code has changed since\nthe documentation was written. If we run cargo test with the documenta-\ntion for the add_one function from Listing 14-1, we will see a section in the\ntest results like this:\n\nDoc-tests my_crate\n\nrunning 1 test\ntest src/lib.rs - add_one (line 5) ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n\nNow if we change either the function or the example so the assert_eq!\nin the example panics and run cargo test again, we'll see that the doc tests\ncatch that the example and the code are out of syne with each other!\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 14.7,
                        "section_name": "Commenting Contained Items",
                        "section_path": "./screenshots-images-2/chapter_14/section_7",
                        "images": [
                            "./screenshots-images-2/chapter_14/section_7/59ffe11e-d78f-4fec-ac96-a82e9c97b76a.png",
                            "./screenshots-images-2/chapter_14/section_7/318f728a-e77f-42f0-9ebd-1d4b9b758c60.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/lib.rs\n\nCommenting Contained Items\n\nAnother style of doc comment, //!, adds documentation to the item that\ncontains the comments rather than adding documentation to the items fol-\nlowing the comments. We typically use these doc comments inside the crate\nroot file (sr\u00a2/lib.rs by convention) or inside a module to document the crate\nor the module as a whole.\n\nFor example, if we want to add documentation that describes the pur-\npose of the my_crate crate that contains the add_one function, we can add docu-\nmentation comments that start with //! to the beginning of the sr\u00a2/lib.rs file,\nas shown in Listing 14-2.\n\n//\\ # My Crate\n\n//\\\n\n//\\ ~my_crate\u201d is a collection of utilities to make performing certain\n//\\ calculations more convenient.\n\n/// Adds one to the number given.\n// --snip--\n\nListing 14-2: Documentation for the my_crate crate as a whole\n\nNotice there isn\u2019t any code after the last line that begins with //!.\nBecause we started the comments with //! instead of ///, we're document-\ning the item that contains this comment rather than an item that follows\nthis comment. In this case, the item that contains this comment is the\nsrc/lib.rs file, which is the crate root. These comments describe the entire\ncrate.\n\nWhen we run cargo doc --open, these comments will display on the front\npage of the documentation for my_crate above the list of public items in the\ncrate, as shown in Figure 14-2.\n\nCrate my_crate 4 Ss\n\u2018Seo all my_crate\u2019s items)\n\u2014=\u2014\u2014vwrrr\u2014 Crate my_crate [-][src]\nFunctions\n\nMy Crate\n\nCrates\n\nmy_crate is a collection of utilities to make performing certain calculations\nmore convenient.\n\nFunctions\n\nadd_one Adds one to the number given.\n\nFigure 14-2: Rendered documentation for my_crate, including the comment describing the\ncrate as a whole\n\nDocumentation comments within items are useful for describing crates\nand modules especially. Use them to explain the overall purpose of the con-\ntainer to help your users understand the crate\u2019s organization.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 14.8,
                        "section_name": "Exporting a Convenient Public API with pub use",
                        "section_path": "./screenshots-images-2/chapter_14/section_8",
                        "images": [
                            "./screenshots-images-2/chapter_14/section_8/79f55b18-f6af-443d-acd2-ef597aef183f.png",
                            "./screenshots-images-2/chapter_14/section_8/d287153c-4850-4b5d-8401-6eed8ace0234.png",
                            "./screenshots-images-2/chapter_14/section_8/042e2ae9-51c4-4a21-84ca-624f3cee52e2.png",
                            "./screenshots-images-2/chapter_14/section_8/f0f65e00-32c0-4cba-a61c-67a7a81ec785.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Exporting a Convenient Public API with pub use\n\nIn Chapter 7, we covered how to organize our code into modules using the\nmod keyword, how to make items public using the pub keyword, and how to\nbring items into a scope using the use keyword. However, the structure that\nmakes sense to you while you're developing a crate might not be very conve-\nnient for your users. You might want to organize your structs in a hierarchy\ncontaining multiple levels, but then people who want to use a type you've\ndefined deep in the hierarchy could have trouble finding out that type\nexists. They might also be annoyed at having to enter use my_crate::some\n_module::another_module::UsefulType; rather than use my_crate::UsefulType;.\n\nThe structure of your public API is a major consideration when publish-\ning a crate. People who use your crate are less familiar with the structure\nthan you are and might have difficulty finding the pieces they want to use if\nyour crate has a large module hierarchy.\n\nThe good news is that if the structure isn\u2019t convenient for others to use\nfrom another library, you don\u2019t have to rearrange your internal organization:\ninstead, you can re-export items to make a public structure that\u2019s different\nfrom your private structure by using pub use. Re-exporting takes a public item\nin one location and makes it public in another location, as if it were defined\nin the other location instead.\n\nFor example, say we made a library named art for modeling artistic\nconcepts. Within this library are two modules: a kinds module containing\ntwo enums named PrimaryColor and SecondaryColor and a utils module con-\ntaining a function named mix, as shown in Listing 14-3.\n\nsrc/lib.rs //\\ # Art\n//\\\n//\\ A library for modeling artistic concepts.\n\npub mod kinds {\n/// The primary colors according to the RYB color model.\npub enum PrimaryColor {\nRed,\nYellow,\nBlue,\n}\n\n/// The secondary colors according to the RYB color model.\npub enum SecondaryColor {\n\nOrange,\n\nGreen,\n\nPurple,\n\n}\n\npub mod utils {\nuse crate::kinds::*;\n\n/// Combines two primary colors in equal amounts to create\n/// a secondary color.\npub fn mix(ci: PrimaryColor, c2: PrimaryColor) -> SecondaryColor {\n\n// --snip--\n}\n}\n\nListing 14-3: An art library with items organized into kinds and utils modules\n\nFigure 14-3 shows what the front page of the documentation for this\ncrate generated by cargo doc would look like.\n\nCrate art \u00bb press \u2018S' to searct sore o\n\nSee all art's items\n\nCrate art [-I[sre]\n\nModules\n| Art\nA library for modeling artistic concepts.\n\nModules\n\nkinds\nutils\n\nFigure 14-3: Front page of the documentation for art that lists the kinds and utils modules\n\nsrc/main.rs\n\nsrc/lib.rs\n\nNote that the PrimaryColor and SecondaryColor types aren't listed on\nthe front page, nor is the mix function. We have to click kinds and utils to\nsee them.\n\nAnother crate that depends on this library would need use statements\nthat bring the items from art into scope, specifying the module structure\nthat\u2019s currently defined. Listing 14-4 shows an example of a crate that uses\nthe PrimaryColor and mix items from the art crate.\n\nuse art::kinds::PrimaryColor;\nuse art::utils: :mix;\n\nfn main() {\nlet red = PrimaryColor::Red;\nlet yellow = PrimaryColor:: Yellow;\nmix(red, yellow);\n\n}\n\nListing 14-4: A crate using the art crate\u2019s items with its internal structure exported\n\nThe author of the code in Listing 14-4, which uses the art crate, had\nto figure out that PrimaryColor is in the kinds module and mix is in the utils\nmodule. The module structure of the art crate is more relevant to developers\nworking on the art crate than to developers using the art crate. The internal\nstructure that organizes parts of the crate into the kinds module and the\nutils module doesn\u2019t contain any useful information for someone trying to\nunderstand how to use the art crate. Instead, the art crate\u2019s module structure\ncauses confusion because developers have to figure out where to look, and\nthe structure is inconvenient because developers must specify the module\nnames in the use statements.\n\nTo remove the internal organization from the public API, we can modify\nthe art crate code in Listing 14-3 to add pub use statements to re-export the\nitems at the top level, as shown in Listing 14-5.\n\n# Art\n\n! A library for modeling artistic concepts.\n\npub use self::kinds::PrimaryColor;\n\npub use self::kinds::SecondaryColor;\npub use self::utils::mix;\n\npub mod kinds {\n\n}\n\npub mod utils {\n\n-snip--\n\nListing 14-5: Adding pub use statements to re-export items\n\nsrc/main.rs\n\nThe API documentation that cargo doc generates for this crate will now\nlist and link re-exports on the front page, as shown in Figure 14-4, making\nthe PrimaryColor and SecondaryColor types and the mix function easier to find.\n\nCrate art f Click or press 'S\u2019 to search, \u2018?' for more options\nSee all art's items\n\u2018 Crate art\n\nRe-exports\nModules (-] Art\n\nA library for modeling artistic concepts.\n\nRe-exports\n\npub use self::ki rimaryColor;\npub use self::ki econdaryColor;\npub use self::utils::mix;\n\nModules\n\nkinds\nutils\n\nFigure 14-4: The front page of the documentation for art that lists the re-exports\n\nThe art crate users can still see and use the internal structure from\nListing 14-3 as demonstrated in Listing 14-4, or they can use the more con-\nvenient structure in Listing 14-5, as shown in Listing 14-6.\n\nuse art::PrimaryColor;\nuse art::mix;\n\nfn main() {\n\nListing 14-6: A program using the re-exported items from the art crate\n\nIn cases where there are many nested modules, re-exporting the types\nat the top level with pub use can make a significant difference in the experi-\nence of people who use the crate.\n\nCreating a useful public API structure is more of an art than a science,\nand you can iterate to find the API that works best for your users. Choosing\npub use gives you flexibility in how you structure your crate internally and\ndecouples that internal structure from what you present to your users. Look\nat some of the code of crates you've installed to see if their internal structure\ndiffers from their public API.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 14.9,
                        "section_name": "Setting Up a Crates.io Account",
                        "section_path": "./screenshots-images-2/chapter_14/section_9",
                        "images": [
                            "./screenshots-images-2/chapter_14/section_9/3798f365-74b9-4f6a-8e1a-424cd78497e4.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Setting Up a Crates.io Account\n\nBefore you can publish any crates, you need to create an account on https://\ncrates.io/ and get an API token. To do so, visit the home page at Attps://crates\n.io/ and log in via a GitHub account. (The GitHub account is currently a\nrequirement, but the site might support other ways of creating an account\nin the future.) Once you're logged in, visit your account settings at https://\ncrates.io/me/ and retrieve your API key. Then run the cargo login command\nwith your API key, like this:\n\n$ cargo login abcdefghijklmnopqrstuvwxyz012345\n\nThis command will inform Cargo of your API token and store it locally\nin ~/.cargo/credentials. Note that this token is a secret: do not share it with any-\none else. If you do share it with anyone for any reason, you should revoke it\nand generate a new token on https://crates.io/.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 14.1,
                        "section_name": "Adding Metadata to a New Crate",
                        "section_path": "./screenshots-images-2/chapter_14/section_10",
                        "images": [
                            "./screenshots-images-2/chapter_14/section_10/85890dd9-e94f-4165-9f46-cf246ccb891c.png",
                            "./screenshots-images-2/chapter_14/section_10/ab665c9f-7c54-40d3-8b7f-314d2f4eb2d8.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Cargo.toml\n\nAdding Metadata to a New Crate\n\nNow that you have an account, let\u2019s say you have a crate you want to publish.\nBefore publishing, you'll need to add some metadata to your crate by adding\nit to the [package] section of the crate\u2019s Cargo.toml file.\n\nYour crate will need a unique name. While you're working on a crate\nlocally, you can name a crate whatever you'd like. However, crate names\non https://crates.io/ are allocated on a first-come, first-served basis. Once a\ncrate name is taken, no one else can publish a crate with that name. Before\nattempting to publish a crate, search for the name you want to use on the site.\nIf the name has been used by another crate, you will need to find another\nname and edit the name field in the Cargo.toml file under the [package] section\nto use the new name for publishing, like so:\n\n[package]\nname = \u201cguessing game\"\n\nEven if you've chosen a unique name, when you run cargo publish to\npublish the crate at this point, you'll get a warning and then an error:\n\n$ cargo publish\n\nUpdating registry \u201chttps://github.com/rust-lang/crates.io-index\nwarning: manifest has no description, license, license-file, documentation,\nhomepage or repository.\n--snip--\nerror: api errors: missing or empty metadata fields: description, license.\n\nThe reason is that you're missing some crucial information: a descrip-\ntion and license are required so people will know what your crate does and\nunder what terms they can use it. To rectify this error, you need to include\nthis information in the Cargo.tomt file.\n\nAdd a description that is just a sentence or two, because it will appear\nwith your crate in search results. For the license field, you need to give\n\nCargo.tom!\n\nCargo.tom!\n\na license identifier value. The Linux Foundation\u2019s Software Package Data\nExchange (SPDX) at Attp://spdx.org/licenses/ lists the identifiers you can use\nfor this value. For example, to specify that you've licensed your crate using\nthe MIT License, add the MIT identifier:\n\n[package]\nname = \"guessing game\"\nlicense = \"MIT\"\n\nIf you want to use a license that doesn\u2019t appear in the SPDX, you need\nto place the text of that license in a file, include the file in your project, and\nthen use license-file to specify the name of that file instead of using the\nlicense key.\n\nGuidance on which license is appropriate for your project is beyond\nthe scope of this book. Many people in the Rust community license their\nprojects in the same way as Rust by using a dual license of MIT OR Apache-2.0.\nThis practice demonstrates that you can specify multiple license identifiers\nseparated by OR to have multiple licenses for your project.\n\nWith a unique name, the version, the author details that cargo new\nadded when you created the crate, your description, and a license added,\nthe Cargo.toml file for a project that is ready to publish might look like this:\n\n[package]\n\nname = \"guessing game\"\n\nversion = \"0.1.0\"\n\nauthors = [\"Your Name <you@example.com>\"]\n\ndescription = \"A fun game where you guess what number the computer has\nchosen.\"\n\nlicense = \"MIT OR Apache-2.0\"\nedition = \"2018\"\n[dependencies]\n\nCargo\u2019s documentation at Attps://doc.rust-lang.org/cargo/ describes other\nmetadata you can specify to ensure others can discover and use your crate\nmore easily.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 14.11,
                        "section_name": "Publishing to Crates.io",
                        "section_path": "./screenshots-images-2/chapter_14/section_11",
                        "images": [
                            "./screenshots-images-2/chapter_14/section_11/3a7f5686-8d98-4ca1-a143-24a25226e5bb.png",
                            "./screenshots-images-2/chapter_14/section_11/6d9c9fe8-7037-4d31-8ca0-f72a5f69dcd5.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Publishing to Crates.io\n\nNow that you've created an account, saved your API token, chosen a name\nfor your crate, and specified the required metadata, you're ready to publish!\nPublishing a crate uploads a specific version to Attps://crates.io/ for others\nto use.\n\nBe careful when publishing a crate because a publish is permanent.\nThe version can never be overwritten, and the code cannot be deleted.\nOne major goal of https://crates.io/ is to act as a permanent archive of code\nso that builds of all projects that depend on crates from Attps://crates.io/\nwill continue to work. Allowing version deletions would make fulfilling\nthat goal impossible. However, there is no limit to the number of crate\nversions you can publish.\n\nRun the cargo publish command again. It should succeed now:\n\n$ cargo publish\n\nUpdating registry \u201chttps://github.com/rust-lang/crates.io-index\u201d\nPackaging guessing game v0.1.0 (file:///projects/guessing game)\nVerifying guessing game v0.1.0 (file:///projects/guessing game)\nCompiling guessing game v0.1.0\n\n(file:///projects/guessing game/target/package/guessing game-0.1.0)\nFinished dev [unoptimized + debuginfo] target(s) in 0.19 secs\nUploading guessing game v0.1.0 (file:///projects/guessing game)\n\nCongratulations! You've now shared your code with the Rust com-\nmunity, and anyone can easily add your crate as a dependency of their\nproject.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 14.12,
                        "section_name": "Publishing a New Version of an Existing Grate",
                        "section_path": "./screenshots-images-2/chapter_14/section_12",
                        "images": [
                            "./screenshots-images-2/chapter_14/section_12/f6dfba21-c5fd-4929-83d3-61826e860710.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Publishing a New Version of an Existing Crate\n\nWhen you've made changes to your crate and are ready to release a new\nversion, you change the version value specified in your Cargo.toml file and\nrepublish. Use the Semantic Versioning rules at http://semver.org/ to decide\nwhat an appropriate next version number is based on the kinds of changes\nyou've made. Then run cargo publish to upload the new version.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 14.13,
                        "section_name": "Removing Versions from Crates.io with cargo yank",
                        "section_path": "./screenshots-images-2/chapter_14/section_13",
                        "images": [
                            "./screenshots-images-2/chapter_14/section_13/e2a19fdc-138f-4068-87f4-375dd54e6416.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Removing Versions from Crates.io with cargo yank\n\nAlthough you can\u2019t remove previous versions of a crate, you can prevent\nany future projects from adding them as a new dependency. This is useful\nwhen a crate version is broken for one reason or another. In such situations,\nCargo supports yanking a crate version.\n\nYanking a version prevents new projects from starting to depend on\nthat version while allowing all existing projects that depend on it to con-\ntinue to download and depend on that version. Essentially, a yank means\nthat all projects with a Cargo.lock will not break, and any future Cargo.lock\nfiles generated will not use the yanked version.\n\nTo yank a version of a crate, run cargo yank and specify which version\nyou want to yank:\n\n$ cargo yank --vers 1.0.1\n\nBy adding --undo to the command, you can also undo a yank and allow\nprojects to start depending on a version again:\n\n$ cargo yank --vers 1.0.1 --undo\n\nAyank does not delete any code. For example, the yank feature is not\nintended for deleting accidentally uploaded secrets. If that happens, you\nmust reset those secrets immediately.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 14.14,
                        "section_name": "Cargo Workspaces",
                        "section_path": "./screenshots-images-2/chapter_14/section_14",
                        "images": [
                            "./screenshots-images-2/chapter_14/section_14/9348ef5f-e20a-4d1c-ba58-808c65770780.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Cargo Workspaces\n\nIn Chapter 12, we built a package that included a binary crate and a library\ncrate. As your project develops, you might find that the library crate continues\nto get bigger and you want to split up your package further into multiple\nlibrary crates. In this situation, Cargo offers a feature called workspaces that\ncan help manage multiple related packages that are developed in tandem.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 14.15,
                        "section_name": "Creating a Workspace",
                        "section_path": "./screenshots-images-2/chapter_14/section_15",
                        "images": [
                            "./screenshots-images-2/chapter_14/section_15/c097dccb-1b1c-445a-ac32-a452ea1363e6.png",
                            "./screenshots-images-2/chapter_14/section_15/3300dd0e-fbd6-4199-a7a0-47d5306821ff.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Cargo.tom!\n\nCreating a Workspace\n\nAworkspace is a set of packages that share the same Cargo.lock and output\ndirectory. Let\u2019s make a project using a workspace\u2014we'll use trivial code so\nwe can concentrate on the structure of the workspace. There are multiple\nways to structure a workspace; we're going to show one common way. We'll\nhave a workspace containing a binary and two libraries. The binary, which\nwill provide the main functionality, will depend on the two libraries. One\nlibrary will provide an add_one function, and a second library an add_two\nfunction. These three crates will be part of the same workspace. We'll start\nby creating a new directory for the workspace:\n\n$ mkdir add\n$ cd add\n\nNext, in the add directory, we create the Cargo.toml file that will con-\nfigure the entire workspace. This file won't have a [package] section or the\nmetadata we've seen in other Cargo.toml files. Instead, it will start with a\n[workspace] section that will allow us to add members to the workspace by\nspecifying the path to our binary crate; in this case, that path is adder:\n\n{workspace]\n\nmembers = [\n\u201cadder\",\n]\n\nNext, we'll create the adder binary crate by running cargo new within the\nadd directory:\n\n$ cargo new adder\nCreated binary (application) \u201cadder\u201d project\n\nAt this point, we can build the workspace by running cargo build. The\nfiles in your add directory should look like this:\n\nCargo. lock\nCargo. toml\nadder\nCargo.toml\nsrc\nL_\u2014 main.rs\ntarget\n\nThe workspace has one target directory at the top level for the compiled\nartifacts to be placed into; the adder crate doesn\u2019t have its own target directory.\nEven if we were to run cargo build from inside the adder directory, the com-\npiled artifacts would still end up in add/target rather than add/adder/target.\nCargo structures the target directory in a workspace like this because the\ncrates in a workspace are meant to depend on each other. If each crate had\nits own target directory, each crate would have to recompile each of the other\ncrates in the workspace to have the artifacts in its own target directory. By\nsharing one farget directory, the crates can avoid unnecessary rebuilding.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 14.16,
                        "section_name": "Geating the Second Crate in the Workspace",
                        "section_path": "./screenshots-images-2/chapter_14/section_16",
                        "images": [
                            "./screenshots-images-2/chapter_14/section_16/aca5ab20-0f33-4917-b480-fc5f6012360e.png",
                            "./screenshots-images-2/chapter_14/section_16/73f87dd7-6232-4f90-93ec-0b38533b9f44.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Cargo.toml\n\nadd-one/src/lib.rs\n\nGeating the Second Crate in the Workspace\n\nNext, let\u2019s create another member crate in the workspace and call it add-one.\nChange the top-level Cargo.toml to specify the add-one path in the members list:\n\nThen generate a new library crate named add-one:\n\n$ cargo new add-one --lib\nCreated library ~add-one\u201d project\n\nYour add directory should now have these directories and files:\n\nCargo. lock\nCargo. tom]\nadd-one\nCargo.toml\nsrc\nL_ lib.rs\nadder\nCargo.toml\nsrc\nL\u2014 main.rs\ntarget\n\nIn the add-one/src/lib.rs file, let\u2019s add an add_one function:\npub fn add_one(x: 132) -> i32 {\n\nx+1\n}\n\nNow that we have a library crate in the workspace, we can have the\nbinary crate adder depend on the library crate add-one. First, we'll need to\nadd a path dependency on add-one to adder/Cargo.toml.\n\nadder/Cargo.tom!\n\nadder/src/main.rs\n\n[dependencies ]\nadd-one = { path = \"../add-one\" }\n\nCargo doesn\u2019t assume that crates in a workspace will depend on each\nother, so we need to be explicit about the dependency relationships between\nthe crates.\n\nNext, let\u2019s use the add_one function from the add-one crate in the adder\ncrate. Open the adder/src/main.rs file and add a use line at the top to bring\nthe new add-one library crate into scope. Then change the main function to\ncall the add_one function, as in Listing 14-7.\n\nuse add_one;\n\nfn main() {\nlet num = 10;\nprintln!(\"Hello, world! {} plus one is {}!\", num, add_one::add_one(num));\n\nListing 14-7: Using the add-one library crate from the adder crate\n\nLet's build the workspace by running cargo build in the top-level add\ndirectory!\n\n$ cargo build\nCompiling add-one v0.1.0 (file:///projects/add/add-one)\nCompiling adder v0.1.0 (file:///projects/add/adder)\nFinished dev [unoptimized + debuginfo] target(s) in 0.68 secs\n\nTo run the binary crate from the add directory, we need to specify which\npackage in the workspace we want to use by including the -p argument and\nthe package name with cargo run:\n\n$ cargo run -p adder\nFinished dev [unoptimized + debuginfo] target(s) in 0.0 secs\nRunning \u201ctarget/debug/adder\u2122\n\nHello, world! 10 plus one is 11!\n\nThis runs the code in adder/src/main.rs, which depends on the add-one\ncrate.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 14.17,
                        "section_name": "Depending on an External Crate in a Workspace",
                        "section_path": "./screenshots-images-2/chapter_14/section_17",
                        "images": [
                            "./screenshots-images-2/chapter_14/section_17/bae05d92-19d0-439a-a80b-34a00b617a39.png",
                            "./screenshots-images-2/chapter_14/section_17/97679629-a17f-488b-93ef-33e56fcf72d9.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Depending on an External Crate in a Workspace\n\nNotice that the workspace has only one Cargo.lock file at the top level of the\nworkspace rather than having a Cargo.lock in each crate\u2019s directory. This\nensures that all crates are using the same version of all dependencies. If we\nadd the rand crate to the adder/Cargo.toml and add-one/Cargo.toml files, Cargo\nwill resolve both of those to one version of rand and record that in the one\nCargo.lock. Making all crates in the workspace use the same dependencies\nmeans the crates in the workspace will always be compatible with each\n\naddone/Cargo.toml\n\nother. Let\u2019s add the rand crate to the [dependencies] section in the add-one/\nCargo.tomi file to be able to use the rand crate in the add-one crate:\n\n[dependencies]\n\nrand = \"0.3.14\"\n\nWe can now add use rand; to the add-one/src/lib.rs file, and building the\nwhole workspace by running cargo build in the add directory will bring in\nand compile the rand crate:\n\n$ cargo build\n\nUpdating registry \u201chttps://github.com/rust-lang/crates.io-index*\nDownloading rand vO.3.14\n\n--snip--\n\nCompiling rand vO.3.14\n\nCompiling add-one v0.1.0 (file:///projects/add/add-one)\n\nCompiling adder v0.1.0 (file:///projects/add/adder)\n\nFinished dev [unoptimized + debuginfo] target(s) in 10.18 secs\n\nThe top-level Cargo.lock now contains information about the dependency\nof add-one on rand. However, even though rand is used somewhere in the work-\nspace, we can\u2019t use it in other crates in the workspace unless we add rand to\ntheir Cargo.toml files as well. For example, if we add use rand; to the adder/\nsrc/main.rs file for the adder crate, we'll get an error:\n\n$ cargo build\nCompiling adder v0.1.0 (file:///projects/add/adder)\nerror: use of unstable library feature \u2018rand': use \u201crand from crates.io (see\nissue #27703)\n--> adder/src/main.rs:1:1\n\n1 | use rand;\n\nTo fix this, edit the Cargo.toml file for the adder crate and indicate that\nrand is a dependency for that crate as well. Building the adder crate will\nadd rand to the list of dependencies for adder in Cargo.lock, but no addi-\ntional copies of rand will be downloaded. Cargo has ensured that every\ncrate in the workspace using the rand crate will be using the same version.\nUsing the same version of rand across the workspace saves space because\nwe won't have multiple copies and ensures that the crates in the workspace\nwill be compatible with each other.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 14.18,
                        "section_name": "Adding a Test to a Workspace",
                        "section_path": "./screenshots-images-2/chapter_14/section_18",
                        "images": [
                            "./screenshots-images-2/chapter_14/section_18/b781101f-3555-452d-8ba0-bd0a70801e0c.png",
                            "./screenshots-images-2/chapter_14/section_18/3adeb439-8cbe-413c-b3fb-68d144149b67.png",
                            "./screenshots-images-2/chapter_14/section_18/a3f4d7fd-bca2-4df8-a5ac-66d600ff1b81.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Adding a Test to a Workspace\n\nFor another enhancement, let\u2019s add a test of the add_one::add_one function\nwithin the add_one crate:\n\nodd-one/src/lib.rs pub fn add_one(x: i32) -> i32 {\n\n#[cfg(test)]\nmod tests {\nuse super: :*;\n\na[test]\nfn it_works() {\nassert_eq!(3, add_one(2));\n\n}\n}\n\nNow run cargo test in the top-level add directory:\n$ cargo test\n\nCompiling add-one v0.1.0 (file:///projects/add/add-one)\n\nCompiling adder v0.1.0 (file:///projects/add/adder)\n\nFinished dev [unoptimized + debuginfo] target(s) in 0.27 secs\nRunning target/debug/deps/add_one-f0253159197f7841\n\nrunning 1 test\ntest tests::it_works ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\nRunning target/debug/deps/adder-f88af9d2cc175a5e\nrunning 0 tests\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\nDoc-tests add-one\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n\nThe first section of the output shows that the it_works test in the add-one\ncrate passed. The next section shows that zero tests were found in the adder\ncrate, and then the last section shows zero documentation tests were found\nin the add-one crate. Running cargo test in a workspace structured like this\none will run the tests for all the crates in the workspace.\n\nWe can also run tests for one particular crate in a workspace from the\ntop-level directory by using the -p flag and specifying the name of the crate\nwe want to test:\n\n$ cargo test -p add-one\nFinished dev [unoptimized + debuginfo] target(s) in 0.0 secs\nRunning target/debug/deps/add_one-b3235fea9a156f74\n\nrunning 1 test\ntest tests::it_works ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n\nDoc-tests add-one\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n\nThis output shows cargo test only ran the tests for the add-one crate and\ndidn\u2019t run the adder crate tests.\n\nIf you publish the crates in the workspace to https://crates.io/, each crate\nin the workspace will need to be published separately. The cargo publish\ncommand does not have an --all flag or a -p flag, so you must change to\neach crate\u2019s directory and run cargo publish on each crate in the workspace\nto publish the crates.\n\nFor additional practice, add an add-two crate to this workspace in a similar\nway as the add-one crate!\n\nAs your project grows, consider using a workspace: it\u2019s easier to\nunderstand smaller, individual components than one big blob of code.\nFurthermore, keeping the crates in a workspace can make coordination\nbetween them easier if they are often changed at the same time.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 14.19,
                        "section_name": "Installing Binaries from Crates.io with cargo install",
                        "section_path": "./screenshots-images-2/chapter_14/section_19",
                        "images": [
                            "./screenshots-images-2/chapter_14/section_19/9cde7ae4-98b3-43aa-b593-5be6ab5b5c3b.png",
                            "./screenshots-images-2/chapter_14/section_19/8580f416-cbde-4581-a523-f492468ac5d2.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Installing Binaries from Crates.io with cargo install\n\nThe cargo install command allows you to install and use binary crates\nlocally. This isn\u2019t intended to replace system packages; it\u2019s meant to be a\nconvenient way for Rust developers to install tools that others have shared\non https://crates.io/. Note that you can only install packages that have binary\ntargets. A binary target is the runnable program that is created if the crate\nhas a src/main.rs file or another file specified as a binary, as opposed to a\nlibrary target that isn\u2019t runnable on its own but is suitable for including\nwithin other programs. Usually, crates have information in the README\nfile about whether a crate is a library, has a binary target, or both.\n\nAll binaries installed with cargo install are stored in the installation\nroot's bin folder. If you installed Rust using rustup and don\u2019t have any cus-\ntom configurations, this directory will be $HOME/.cargo/bin. Ensure that\ndirectory is in your $PATH to be able to run programs you've installed with\ncargo install.\n\nFor example, in Chapter 12 we mentioned that there\u2019s a Rust implemen-\ntation of the grep tool called ripgrep for searching files. If we want to install\nripgrep, we can run the following:\n\n$ cargo install ripgrep\nUpdating registry \u201chttps: //github.com/rust-lang/crates.io-index\u201d\nDownloading ripgrep v0.3.2\n--snip--\nCompiling ripgrep v0.3.2\nFinished release [optimized + debuginfo] target(s) in 97.91 secs\nInstalling ~/.cargo/bin/rg\n\n\nThe last line of the output shows the location and the name of the\ninstalled binary, which in the case of ripgrep is rg. As long as the installa-\ntion directory is in your $PATH, as mentioned previously, you can then run\nrg --help and start using a faster, rustier tool for searching files!\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 14.2,
                        "section_name": "Extending Cargo with Custom Commands",
                        "section_path": "./screenshots-images-2/chapter_14/section_20",
                        "images": [
                            "./screenshots-images-2/chapter_14/section_20/046f7b15-68e1-41ee-bbbe-275dfb7e2cd0.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Extending Cargo with Custom Commands\n\nCargo is designed so you can extend it with new subcommands without\nhaving to modify Cargo. If a binary in your $PATH is named cargo-something,\nyou can run it as if it were a Cargo subcommand by running cargo something.\nCustom commands like this are also listed when you run cargo --list. Being\nable to use cargo install to install extensions and then run them just like\nthe built-in Cargo tools is a super convenient benefit of Cargo\u2019s design!\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 14.21,
                        "section_name": "Summary",
                        "section_path": "./screenshots-images-2/chapter_14/section_21",
                        "images": [
                            "./screenshots-images-2/chapter_14/section_21/7f0d696b-196b-44dd-8bcd-efaf509bedd2.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Summary\n\nSharing code with Cargo and https://crates.io/ is part of what makes the\nRust ecosystem useful for many different tasks. Rust\u2019s standard library is\nsmall and stable, but crates are easy to share, use, and improve on a time-\nline different from that of the language. Don't be shy about sharing code\nthat\u2019s useful to you on https://crates.io/; it\u2019s likely that it will be useful to\nsomeone else as well!\n",
                        "extracted-code": ""
                    }
                ]
            },
            {
                "chapter_id": 15,
                "chapter_name": "SMART POINTERS",
                "chapter_path": "./screenshots-images-2/chapter_15",
                "sections": [
                    {
                        "section_id": 15.1,
                        "section_name": "SMART POINTERS",
                        "section_path": "./screenshots-images-2/chapter_15/section_1",
                        "images": [
                            "./screenshots-images-2/chapter_15/section_1/3e0dfaf2-48f5-4f1f-b68f-7ae9f6987005.png",
                            "./screenshots-images-2/chapter_15/section_1/099b5ef4-36b1-42e1-8083-85d1f0c26db0.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "A pointer is a general concept for a variable\n\nthat contains an address in memory. This\naddress refers to, or \u201cpoints at,\u201d some other\n\ndata. The most common kind of pointer in Rust\n\nis a reference, which you learned about in Chapter 4.\nReferences are indicated by the & symbol and borrow\nthe value they point to. They don\u2019t have any special\ncapabilities other than referring to data. Also, they\ndon\u2019t have any overhead and are the kind of pointer\nwe use most often.\n\nSmart pointers, on the other hand, are data structures that not only act\nlike a pointer but also have additional metadata and capabilities. The con-\ncept of smart pointers isn\u2019t unique to Rust: smart pointers originated in C++\nand exist in other languages as well. In Rust, the different smart pointers\ndefined in the standard library provide functionality beyond that provided\n\n\nby references. One example that we'll explore in this chapter is the refer-\nence counting smart pointer type. This pointer enables you to have multiple\nowners of data by keeping track of the number of owners and, when no\nowners remain, cleaning up the data.\n\nIn Rust, which uses the concept of ownership and borrowing, an\nadditional difference between references and smart pointers is that refer-\nences are pointers that only borrow data; in contrast, in many cases, smart\npointers own the data they point to.\n\nWe've already encountered a few smart pointers in this book, such as\nString and Vec<T> in Chapter 8, although we didn\u2019t call them smart pointers at\nthe time. Both these types count as smart pointers because they own some\nmemory and allow you to manipulate it. They also have metadata (such as\ntheir capacity) and extra capabilities or guarantees (such as with String\nensuring its data will always be valid UTF-8).\n\nSmart pointers are usually implemented using structs. The charac-\nteristic that distinguishes a smart pointer from an ordinary struct is that\nsmart pointers implement the Deref and Drop traits. The Deref trait allows\nan instance of the smart pointer struct to behave like a reference so you\ncan write code that works with either references or smart pointers. The\nDrop trait allows you to customize the code that is run when an instance\nof the smart pointer goes out of scope. In this chapter, we'll discuss both\ntraits and demonstrate why they're important to smart pointers.\n\nGiven that the smart pointer pattern is a general design pattern used\nfrequently in Rust, this chapter won\u2019t cover every existing smart pointer.\nMany libraries have their own smart pointers, and you can even write\nyour own. We'll cover the most common smart pointers in the standard\nlibrary:\n\n\u00a9 \u2014Box<T> for allocating values on the heap\n\ne  Rc<T>, a reference counting type that enables multiple ownership\n\ne \u2014Ref<T> and RefMut<T>, accessed through RefCell<T>, a type that enforces\nthe borrowing rules at runtime instead of compile time\n\nIn addition, we'll cover the interior mutability pattern where an immutable\ntype exposes an API for mutating an interior value. We'll also discuss reference\ncycles: how they can leak memory and how to prevent them.\n\nLet\u2019s dive in!\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 15.2,
                        "section_name": "Using Box<T> to Point to Data on the Heap",
                        "section_path": "./screenshots-images-2/chapter_15/section_2",
                        "images": [
                            "./screenshots-images-2/chapter_15/section_2/bb3bafa4-ff3c-4a1a-8457-0b653fad0f23.png",
                            "./screenshots-images-2/chapter_15/section_2/99836b4c-ce18-4531-889b-8a124a34537d.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Using Box<T> to Point to Data on the Heap\n\nThe most straightforward smart pointer is a box, whose type is written\nBox<T>. Boxes allow you to store data on the heap rather than the stack.\nWhat remains on the stack is the pointer to the heap data. Refer to\nChapter 4 to review the difference between the stack and the heap.\n\nBoxes don\u2019t have performance overhead, other than storing their data\non the heap instead of on the stack. But they don\u2019t have many extra capa-\nbilities either. You'll use them most often in these situations:\n\ne When you have a type whose size can\u2019t be known at compile time and you\nwant to use a value of that type in a context that requires an exact size\n\ne When you have a large amount of data and you want to transfer owner-\nship but ensure the data won't be copied when you do so\n\ne When you want to own a value and you care only that it\u2019s a type that\nimplements a particular trait rather than being of a specific type\n\nWe'll demonstrate the first situation in \u201cEnabling Recursive Types\nwith Boxes\u201d on page 314. In the second case, transferring ownership of a\nlarge amount of data can take a long time because the data is copied around\non the stack. To improve performance in this situation, we can store the\nlarge amount of data on the heap in a box. Then, only the small amount\nof pointer data is copied around on the stack, while the data it references\nstays in one place on the heap. The third case is known as a frait object, and\nChapter 17 devotes an entire section (\u201cUsing Trait Objects That Allow for\nValues of Different Types\u201d on page 375) just to that topic. So what you learn\nhere you'll apply again in Chapter 17!\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 15.3,
                        "section_name": "Using a Box<T> to Store Data on the Heap",
                        "section_path": "./screenshots-images-2/chapter_15/section_3",
                        "images": [
                            "./screenshots-images-2/chapter_15/section_3/af4483ef-c5c0-4c7c-8518-b3c4c3b02a82.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nUsing a Box<T> to Store Data on the Heap\n\nBefore we discuss this use case for Box<T>, we'll cover the syntax and how to\ninteract with values stored within a Box<T>.\nListing 15-1 shows how to use a box to store an i32 value on the heap.\n\nfn main() {\nlet b = Box::new(5);\nprintln!(\"b = {}\", b);\n\nListing 15-1: Storing an i32 value on the heap using a box\n\nWe define the variable b to have the value of a Box that points to the\nvalue 5, which is allocated on the heap. This program will print b = 5; in\nthis case, we can access the data in the box similar to how we would if this\ndata were on the stack. Just like any owned value, when a box goes out of\nscope, as b does at the end of main, it will be deallocated. The deallocation\nhappens for the box (stored on the stack) and the data it points to (stored\non the heap).\n\nPutting a single value on the heap isn\u2019t very useful, so you won't use\nboxes by themselves in this way very often. Having values like a single i32\non the stack, where they're stored by default, is more appropriate in the\nmajority of situations. Let\u2019s look at a case where boxes allow us to define\ntypes that we wouldn't be allowed to if we didn\u2019t have boxes.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 15.4,
                        "section_name": "Enabling Recursive Types with Boxes",
                        "section_path": "./screenshots-images-2/chapter_15/section_4",
                        "images": [
                            "./screenshots-images-2/chapter_15/section_4/dd433418-3a7f-4908-a8ee-659e2ad9dcf9.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Enabling Recursive Types with Boxes\n\nAt compile time, Rust needs to know how much space a type takes up. One\ntype whose size can\u2019t be known at compile time is a recursive type, where a\nvalue can have as part of itself another value of the same type. Because this\nnesting of values could theoretically continue infinitely, Rust doesn\u2019t know\nhow much space a value of a recursive type needs. However, boxes have\n\na known size, so by inserting a box in a recursive type definition, you can\nhave recursive types.\n\nLet\u2019s explore the cons list, which is a data type common in functional\nprogramming languages, as an example of a recursive type. The cons list\ntype we'll define is straightforward except for the recursion; therefore, the\nconcepts in the example we'll work with will be useful any time you get into\nmore complex situations involving recursive types.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 15.5,
                        "section_name": "More Information About the Cons List",
                        "section_path": "./screenshots-images-2/chapter_15/section_5",
                        "images": [
                            "./screenshots-images-2/chapter_15/section_5/0d9b15a1-3fe7-48be-baf6-181207b2e04f.png",
                            "./screenshots-images-2/chapter_15/section_5/aea8ea59-4cf8-4c91-b478-2a1fab47844d.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nMore Information About the Cons List\n\nA cons list is a data structure that comes from the Lisp programming lan-\nguage and its dialects. In Lisp, the cons function (short for \u201cconstruct func-\ntion\u201d) constructs a new pair from its two arguments, which usually are a\nsingle value and another pair. These pairs containing pairs form a list.\n\nThe cons function concept has made its way into more general functional\nprogramming jargon: \u201cto cons x onto y\u201d informally means to construct a new\ncontainer instance by putting the element x at the start of this new container,\nfollowed by the container y.\n\nEach item in a cons list contains two elements: the value of the current\nitem and the next item. The last item in the list contains only a value called\nNil without a next item. A cons list is produced by recursively calling the cons\nfunction. The canonical name to denote the base case of the recursion is\nNil. Note that this is not the same as the \u201cnull\u201d concept in Chapter 6, which is\nan invalid or absent value.\n\nAlthough functional programming languages use cons lists frequently,\nthe cons list isn\u2019t a commonly used data structure in Rust. Most of the time\nwhen you have a list of items in Rust, Vec<T> is a better choice. Other, more\ncomplex recursive data types are useful in various situations, but by starting\nwith the cons list, we can explore how boxes let us define a recursive data\ntype without much distraction.\n\nListing 15-2 contains an enum definition for a cons list. Note that this\ncode won't compile yet because the List type doesn\u2019t have a known size,\nwhich we'll demonstrate.\n\nenum List {\nCons(i32, List),\nNil,\n\n}\n\nListing 15-2: The first attempt at defining an enum to represent a cons list data structure of\ni32 values\n\nNOTE\n\nsrc/main.rs\n\nWe're implementing a cons list that holds only i32 values for the purposes of\nthis example. We could have implemented it using generics, as we discussed in\nChapter 10, to define a cons list type that could store values of any type.\n\nUsing the List type to store the list 1, 2, 3 would look like the code in\nListing 15-3.\n\nuse crate::List::{Cons, Nil};\n\nfn main() {\nlet list = Cons(1, Cons(2, Cons(3, Nil)));\n}\n\nListing 15-3: Using the List enum to store the list1, 2, 3\n\nThe first Cons value holds 1 and another List value. This List value is\nanother Cons value that holds 2 and another List value. This List value is\none more Cons value that holds 3 and a List value, which is finally Nil, the\nnon-recursive variant that signals the end of the list.\n\nIf we try to compile the code in Listing 15-3, we get the error shown in\nListing 15-4.\n\nerror[E0072]: recursive type \u201cList\u201d has infinite size\n--> src/main.rs:1:1\n\n|\n1 | enum List {\n| *anaeenee recursive type has infinite size\n2 | Cons(i32, List),\n| ween recursive without indirection\n|\n\n= help: insert indirection (e.g., a \u201cBox\u201d, Rc\u2019, or ~&) at some point to\nmake \u201cList\u201d representable\n\nListing 15-4: The error we get when attempting to define a recursive enum\n\nThe error shows this type \u201chas infinite size.\u201d The reason is that we've\ndefined List with a variant that is recursive: it holds another value of itself\ndirectly. As a result, Rust can\u2019t figure out how much space it needs to store a\nList value. Let\u2019s break down why we get this error a bit. First, let\u2019s look at how\nRust decides how much space it needs to store a value of a non-recursive type.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 15.6,
                        "section_name": "Computing the Size of a Non-Recursive Type",
                        "section_path": "./screenshots-images-2/chapter_15/section_6",
                        "images": [
                            "./screenshots-images-2/chapter_15/section_6/00b71b0a-c027-42d8-82bc-e4a1ae78b146.png",
                            "./screenshots-images-2/chapter_15/section_6/b6394489-eed7-47a0-814c-9d1f3da593bc.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Computing the Size of a Non-Recursive Type\n\nRecall the Message enum we defined in Listing 6-2 when we discussed enum\ndefinitions in Chapter 6:\n\nenum Message {\nQuit,\nMove { x: i32, y: i32 },\nWrite(String),\nChangeColor(i32, i32, 132),\n\nTo determine how much space to allocate for a Message value, Rust goes\nthrough each of the variants to see which variant needs the most space. Rust\nsees that Message: :Quit doesn\u2019t need any space, Message: :Move needs enough\nspace to store two i32 values, and so forth. Because only one variant will be\nused, the most space a Message value will need is the space it would take to\nstore the largest of its variants.\n\nContrast this with what happens when Rust tries to determine how\nmuch space a recursive type like the List enum in Listing 15-2 needs. The\ncompiler starts by looking at the Cons\nvariant, which holds a value of type i32\nand a value of type List. Therefore, Cons\nneeds an amount of space equal to the\nsize of an i32 plus the size of a List. To\nfigure out how much memory the List\ntype needs, the compiler looks at the\nvariants, starting with the Cons variant.\nThe Cons variant holds a value of type\ni32 and a value of type List, and this Figure 15-1: An infinite List consist-\nprocess continues infinitely, as shown ing of infinite Cons variants\nin Figure 15-1.\n\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 15.7,
                        "section_name": "Using Box<T> to Get a Recursive Type with a Known Size",
                        "section_path": "./screenshots-images-2/chapter_15/section_7",
                        "images": [
                            "./screenshots-images-2/chapter_15/section_7/a470a55f-1154-4dab-9c3a-7c0e4d97c387.png",
                            "./screenshots-images-2/chapter_15/section_7/b438f262-a858-475a-976d-2eacbda36112.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nUsing Box<T> to Get a Recursive Type with a Known Size\n\nRust can\u2019t figure out how much space to allocate for recursively defined\ntypes, so the compiler gives the error in Listing 15-4. But the error does\ninclude this helpful suggestion:\n\n= help: insert indirection (e.g., a \u201cBox\u201d, \u201cRc\u201d, or ~&) at some point to\nmake \u201cList\u201d representable\n\nIn this suggestion, indirection means that instead of storing a value\ndirectly, we'll change the data structure to store the value indirectly by\nstoring a pointer to the value instead.\n\nBecause a Box<T> is a pointer, Rust always knows how much space a\nBox<T> needs: a pointer\u2019s size doesn\u2019t change based on the amount of data\nit\u2019s pointing to. This means we can put a Box<T> inside the Cons variant\ninstead of another List value directly. The Box<T> will point to the next\nList value that will be on the heap rather than inside the Cons variant.\nConceptually, we still have a list, created with lists \u201cholding\u201d other lists,\nbut this implementation is now more like placing the items next to one\nanother rather than inside one another.\n\nWe can change the definition of the List enum in Listing 15-2 and\nthe usage of the List in Listing 15-3 to the code in Listing 15-5, which will\ncompile.\n\nCons(i32, Box<List>),\n\nNil,\n\n\u00bb Nil};\n\nlet list = Cons(1,\nBox: :new(Cons(2,\nBox: :new(Cons(3,\nBox: :new(Nil))))));\n\nListing 15-5: Definition of List that uses Box<T> in order to have a known size\n\nThe Cons variant will need the size of an i32 plus Cons\nthe space to store the box\u2019s pointer data. The Nil vari-\nant stores no values, so it needs less space than the Cons\nvariant. We now know that any List value will take up\nthe size of an i32 plus the size of a box\u2019s pointer data.\nBy using a box, we've broken the infinite, recursive that i oe\n\n- . oe at is not infinitely\nchain, so the compiler can figure out the size it needs sized because Cons\nto store a List value. Figure 15-2 shows what the Cons holds a Box\nvariant looks like now.\n\nBoxes provide only the indirection and heap allocation; they don\u2019t have\nany other special capabilities, like those we'll see with the other smart pointer\ntypes. They also don\u2019t have any performance overhead that these special\ncapabilities incur, so they can be useful in cases like the cons list where the\nindirection is the only feature we need. We'll look at more use cases for boxes\nin Chapter 17, too.\n\nThe Box<T> type is a smart pointer because it implements the Deref trait,\nwhich allows Box<T> values to be treated like references. When a Box<T> value\ngoes out of scope, the heap data that the box is pointing to is cleaned up as\nwell because of the Drop trait implementation. Let\u2019s explore these two traits\nin more detail. These two traits will be even more important to the func-\ntionality provided by the other smart pointer types we'll discuss in the rest\nof this chapter.\n\nBox\n\nFigure 15-2: A List\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 15.8,
                        "section_name": "Treating Smart Pointers Like Regular References with\nthe Deref Trait",
                        "section_path": "./screenshots-images-2/chapter_15/section_8",
                        "images": [
                            "./screenshots-images-2/chapter_15/section_8/1b06eed2-cc69-4ab6-94c6-7914e65766e3.png",
                            "./screenshots-images-2/chapter_15/section_8/3ae15ecd-e95f-49c5-94e6-dfff53d622ed.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Treating Smart Pointers Like Regular References with\nthe Deref Trait\n\nImplementing the Deref trait allows you to customize the behavior of the\ndereference operator, * (as opposed to the multiplication or glob operator). By\nimplementing Deref in such a way that a smart pointer can be treated like a\nregular reference, you can write code that operates on references and use\nthat code with smart pointers too.\n\nLet's first look at how the dereference operator works with regular\nreferences. Then we'll try to define a custom type that behaves like Box<T>,\nand see why the dereference operator doesn\u2019t work like a reference on our\nnewly defined type. We'll explore how implementing the Deref trait makes\nit possible for smart pointers to work in a similar way as references. Then\nwe'll look at Rust\u2019s deref coercion feature and how it lets us work with either\nreferences or smart pointers.\n\nThere\u2019s one big difference between the MyBox<T> type we're about to build and the real\nBox<T>: our version will not store its data on the heap. We are focusing this example\non Deref, so where the data is actually stored is less important than the pointer-like\n\nbehavior.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 15.9,
                        "section_name": "Following the Pointer to the Value with the Dereference Operator",
                        "section_path": "./screenshots-images-2/chapter_15/section_9",
                        "images": [
                            "./screenshots-images-2/chapter_15/section_9/a0061c04-6b0e-4716-9eae-c905f800a506.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nFollowing the Pointer to the Valve with the Dereference Operator\n\nA regular reference is a type of pointer, and one way to think of a pointer\nis as an arrow to a value stored somewhere else. In Listing 15-6, we create\na reference to an i32 value and then use the dereference operator to follow\nthe reference to the data.\n\nfn main() {\n@ let x = 5;\n@ let y = &;\n\n\u00a9 assert_eq!(5, x);\n\u00a9 assert_eq!(5, *y);\n}\n\nListing 15-6: Using the dereference operator to follow a reference to an i32 value\n\nThe variable x holds an i32 value, 5 @. We set y equal to a reference to\nx \u00a9. We can assert that x is equal to 5 \u00a9. However, if we want to make an\nassertion about the value in y, we have to use *y to follow the reference to the\nvalue it\u2019s pointing to (hence dereference) @. Once we dereference y, we have\naccess to the integer value y is pointing to, which we can compare with 5.\n\nIf we tried to write assert_eq!(5, y); instead, we would get this compi-\nlation error:\n\nerror[E0277]: can't compare ~{integer}\u2019 with ~&{integer}~\n--> src/main.rs:6:5\n\n|\nassert_eq!(5, y);\n\n6 |\n| AAAAARAAAAAMADAAN ng implementation for ~{integer} == &{integer}~\n|\n\nhelp: the trait \u201cstd: :cmp::PartialEq<&{integer}>~ is not implemented for\n*{integer}>\n\nComparing a number and a reference to a number isn\u2019t allowed because\nthey're different types. We must use the dereference operator to follow the\nreference to the value it\u2019s pointing to.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 15.1,
                        "section_name": "Using Box<T> Like a Reference",
                        "section_path": "./screenshots-images-2/chapter_15/section_10",
                        "images": [
                            "./screenshots-images-2/chapter_15/section_10/62a5c5f0-8eaa-4db1-9ffe-f4ce893a749c.png",
                            "./screenshots-images-2/chapter_15/section_10/0bab232b-bd90-4f9f-9e2a-c68e6c7f75e0.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Using Box<T> Like a Reference\n\nWe can rewrite the code in Listing 15-6 to use a Box<T> instead of a reference;\nthe dereference operator will work as shown in Listing 15-7.\n\nsrc/main.rs\n\nfn main(\nlet x = 5;\n\n@ let y = Box::new(x);\n\nassert eq!(5, x);\n\n@ assert_eq!(5, *y);\n\nListing 15-7: Using the dereference operator on a Box<i32>\n\nThe only difference between Listing 15-7 and Listing 15-6 is that here\nwe set y to be an instance of a box pointing to the value in x rather than a\nreference pointing to the value of x @. In the last assertion @, we can use the\ndereference operator to follow the box\u2019s pointer in the same way that we did\nwhen y was a reference. Next, we'll explore what is special about Box<T> that\nenables us to use the dereference operator by defining our own box type.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 15.11,
                        "section_name": "Defining Our Own Smart Pointer",
                        "section_path": "./screenshots-images-2/chapter_15/section_11",
                        "images": [
                            "./screenshots-images-2/chapter_15/section_11/b19acbe0-a408-41f5-9d25-1838c9b569ef.png",
                            "./screenshots-images-2/chapter_15/section_11/aa71cf39-9251-4548-864e-e8777559116f.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nDefining Our Own Smart Pointer\n\nLet's build a smart pointer similar to the Box<T> type provided by the standard\nlibrary to experience how smart pointers behave differently than references\nby default. Then we'll look at how to add the ability to use the dereference\noperator.\n\nThe Box<T> type is ultimately defined as a tuple struct with one element,\nso Listing 15-8 defines a MyBox<T> type in the same way. We'll also define a\nnew function to match the new function defined on Box<T>.\n\nstruct MyBox<T>(T);\n\nimpl<T> MyBox<T> {\n@ fn new(x: T) -> MyBox<T> {\n\u00a9 MyBox(x)\n\n}\n\nListing 15-8: Defining a MyBox<T> type\n\nWe define a struct named MyBox and declare a generic parameter T O,\nbecause we want our type to hold values of any type. The MyBox type is a\ntuple struct with one element of type T. The MyBox: :new function takes one\nparameter of type T @ and returns a MyBox instance that holds the value\npassed in \u00a9.\n\nLet's try adding the main function in Listing 15-7 to Listing 15-8 and\nchanging it to use the MyBox<T> type we've defined instead of Box<T>. The code\nin Listing 15-9 won\u2019t compile because Rust doesn\u2019t know how to dereference\nMyBox.\n\nsrc/main.rs\n\nlet x =\n\nlet y = , Box: :new(x);\n\nListing 15-9: Attempting to use MyBox<T> in the same way we used references and Box<T>\n\nHere\u2019s the resulting compilation error:\n\nerror[E0614]: type \u201cMyBox<{integer}>\u201d cannot be dereferenced\n--> src/main.rs:14:19\n|\n14 | assert_eq!(5, *y);\nnA\n\nOur MyBox<T> type can\u2019t be dereferenced because we haven't implemented\nthat ability on our type. To enable dereferencing with the * operator, we\nimplement the Deref trait.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 15.12,
                        "section_name": "Treating a Type Like a Reference by Implementing the Deref Trait",
                        "section_path": "./screenshots-images-2/chapter_15/section_12",
                        "images": [
                            "./screenshots-images-2/chapter_15/section_12/662cf8bb-de35-448c-88ff-50f9885531fe.png",
                            "./screenshots-images-2/chapter_15/section_12/beb2a1de-9410-4484-9d68-412093466de5.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "stc/main.rs\n\nTreating a Type Like a Reference by Implementing the Deref Trait\n\nAs discussed in Chapter 10, to implement a trait, we need to provide imple-\nmentations for the trait\u2019s required methods. The Deref trait, provided by the\nstandard library, requires us to implement one method named deref that\nborrows self and returns a reference to the inner data. Listing 15-10 con-\ntains an implementation of Deref to add to the definition of MyBox.\n\nuse std::ops::Deref;\n\nimpl<T> Deref for MyBox<T> {\n\u00a9 type Target = T;\n\nfn deref(&self) -> aT {\n\u00a9 aself.o\n\n}\n}\n\nListing 15-10: Implementing Deref on MyBox<T>\n\nThe type Target = T; syntax @ defines an associated type for the Deref\ntrait to use. Associated types are a slightly different way of declaring a\ngeneric parameter, but you don\u2019t need to worry about them for now; we'll\ncover them in more detail in Chapter 19.\n\nWe fill in the body of the deref method with &self.o so deref returns a\nreference to the value we want to access with the * operator \u00ae. The main\nfunction in Listing 15-9 that calls * on the MyBox<T> value now compiles,\nand the assertions pass!\n\nWithout the Deref trait, the compiler can dereference only & references.\nThe deref method gives the compiler the ability to take a value of any type\nthat implements Deref and call the deref method to get a & reference that it\nknows how to dereference.\n\nWhen we entered *y in Listing 15-9, behind the scenes Rust actually ran\nthis code:\n\n*(y.deref())\n\nRust substitutes the * operator with a call to the deref method and then a\nplain dereference so we don\u2019t have to think about whether or not we need to\ncall the deref method. This Rust feature lets us write code that functions iden-\ntically whether we have a regular reference or a type that implements Deref.\n\nThe reason the deref method returns a reference to a value, and that the\nplain dereference outside the parentheses in *(y.deref()) is still necessary, is\nthe ownership system. If the deref method returned the value directly instead\nof a reference to the value, the value would be moved out of self. We don\u2019t\nwant to take ownership of the inner value inside My8ox<T> in this case or in\nmost cases where we use the dereference operator.\n\nNote that the * operator is replaced with a call to the deref method and\nthen a call to the * operator just once, each time we use a * in our code.\nBecause the substitution of the * operator does not recurse infinitely, we end\nup with data of type i32, which matches the 5 in assert_eq! in Listing 15-9.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 15.13,
                        "section_name": "Implicit Deref Coercions with Functions and Methods",
                        "section_path": "./screenshots-images-2/chapter_15/section_13",
                        "images": [
                            "./screenshots-images-2/chapter_15/section_13/3d5c7958-20ea-4e0c-8060-40d157d261bb.png",
                            "./screenshots-images-2/chapter_15/section_13/cd43ee7e-da3f-4eb5-abf2-8bba454e971f.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nImplicit Deref Coercions with Functions and Methods\n\nDeref coercion is a convenience that Rust performs on arguments to functions\nand methods. Deref coercion converts a reference to a type that implements\nDeref into a reference to a type that Deref can convert the original type into.\nDeref coercion happens automatically when we pass a reference to a particu-\nlar type\u2019s value as an argument to a function or method that doesn\u2019t match\nthe parameter type in the function or method definition. A sequence of calls\nto the deref method converts the type we provided into the type the param-\neter needs.\n\nDeref coercion was added to Rust so that programmers writing function\nand method calls don\u2019t need to add as many explicit references and derefer-\nences with & and *. The deref coercion feature also lets us write more code\nthat can work for either references or smart pointers.\n\nTo see deref coercion in action, let\u2019s use the MyBox<T> type we defined\nin Listing 15-8 as well as the implementation of Deref that we added in\nListing 15-10. Listing 15-11 shows the definition of a function that has a\nstring slice parameter.\n\nfn hello(name: &str) {\nprintln!(\"Hello, {}!\", name);\n}\n\nListing 15-11: A hello function that has the parameter name of type &str\n\nsrc/main.rs\n\nsrc/main.rs\n\nWe can call the hello function with a string slice as an argument, such\nas hello(\"Rust\"); for example. Deref coercion makes it possible to call hello\nwith a reference to a value of type MyBox<String>, as shown in Listing 15-12.\n\nfn main() {\nlet m = MyBox::new(String::from(\"Rust\"));\nhello(&m) ;\n\n}\n\nListing 15-12: Calling hello with a reference to a MyBox<String> value, which works\nbecause of deref coercion\n\nHere we're calling the hello function with the argument am, which is a\nreference to a MyBox<String> value. Because we implemented the Deref trait\non MyBox<T> in Listing 15-10, Rust can turn &yBox<String> into &String by\ncalling deref. The standard library provides an implementation of Deref on\nString that returns a string slice, and this is in the API documentation for\nDeref. Rust calls deref again to turn the &String into &str, which matches the\nhello function\u2019s definition.\n\nIf Rust didn\u2019t implement deref coercion, we would have to write the code\nin Listing 15-13 instead of the code in Listing 15-12 to call hello with a value\nof type &MyBox<String>.\n\nfn main\nlet m = MyBox::new(String::from(\"Rust\"));\nhello(&(*m)[..]);\n\n}\n\nListing 15-13: The code we would have to write if Rust didn't have deref coercion\n\nThe (*m) dereferences the MyBox<String> into a String. Then the & and [..]\ntake a string slice of the String that is equal to the whole string to match the\nsignature of hello. The code without deref coercions is harder to read, write,\nand understand with all of these symbols involved. Deref coercion allows Rust\nto handle these conversions for us automatically.\n\nWhen the Deref trait is defined for the types involved, Rust will analyze\nthe types and use Deref: :deref as many times as necessary to get a reference to\nmatch the parameter\u2019s type. The number of times that Deref::deref needs to\nbe inserted is resolved at compile time, so there is no runtime penalty for tak-\ning advantage of deref coercion!\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 15.14,
                        "section_name": "How Deref Coercion Interacts with Mutability",
                        "section_path": "./screenshots-images-2/chapter_15/section_14",
                        "images": [
                            "./screenshots-images-2/chapter_15/section_14/ab9ae053-4dfb-4be5-971c-f8ae3699d340.png",
                            "./screenshots-images-2/chapter_15/section_14/bdb132e5-207d-4a89-b10b-95c40529a5be.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "How Deref Coercion Interacts with Mutability\n\nSimilar to how you use the Deref trait to override the * operator on immu-\ntable references, you can use the DerefMut trait to override the * operator\non mutable references.\n\nRust does deref coercion when it finds types and trait implementations\nin three cases:\n\ne From &t to &U when T: Deref<Target=U>\ne From &mut T to &mut U when T: DerefMut<Target=U>\ne From &mut T to 80 when T: Deref<Target=U>\n\nThe first two cases are the same except for mutability. The first case\nstates that if you have a &T, and T implements Deref to some type U, you can\nget a &U transparently. The second case states that the same deref coercion\nhappens for mutable references.\n\nThe third case is trickier: Rust will also coerce a mutable reference to\nan immutable one. But the reverse is not possible: immutable references will\nnever coerce to mutable references. Because of the borrowing rules, if you\nhave a mutable reference, that mutable reference must be the only refer-\nence to that data (otherwise, the program wouldn't compile). Converting\none mutable reference to one immutable reference will never break the bor-\nrowing rules. Converting an immutable reference to a mutable reference\nwould require that there is only one immutable reference to that data, and\nthe borrowing rules don\u2019t guarantee that. Therefore, Rust can\u2019t make the\nassumption that converting an immutable reference to a mutable reference\nis possible.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 15.15,
                        "section_name": "Running Code on Cleanup with the Drop Trait",
                        "section_path": "./screenshots-images-2/chapter_15/section_15",
                        "images": [
                            "./screenshots-images-2/chapter_15/section_15/6f14a340-93bc-40c8-bdb9-954184e16fe1.png",
                            "./screenshots-images-2/chapter_15/section_15/422574b0-8f6d-4a2d-ae6e-37412362bb35.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Running Code on Cleanup with the Drop Trait\n\nThe second trait important to the smart pointer pattern is Drop, which lets\nyou customize what happens when a value is about to go out of scope. You\ncan provide an implementation for the Drop trait on any type, and the code\nyou specify can be used to release resources like files or network connec-\ntions. We're introducing Drop in the context of smart pointers because the\nfunctionality of the Drop trait is almost always used when implementing a\nsmart pointer. For example, 8ox<T> customizes Drop to deallocate the space\non the heap that the box points to.\n\nIn some languages, the programmer must call code to free memory\nor resources every time they finish using an instance of a smart pointer. If\nthey forget, the system might become overloaded and crash. In Rust, you\ncan specify that a particular bit of code be run whenever a value goes out of\nscope, and the compiler will insert this code automatically. As a result, you\ndon\u2019t need to be careful about placing cleanup code everywhere in a pro-\ngram that an instance of a particular type is finished with\u2014you still won't\nleak resources!\n\nSpecify the code to run when a value goes out of scope by implementing\nthe Drop trait. The Drop trait requires you to implement one method named\ndrop that takes a mutable reference to self. To see when Rust calls drop, let\u2019s\nimplement drop with print1n! statements for now.\n\nsrc/main.rs\n\nListing 15-14 shows a CustomSmartPointer struct whose only custom func-\ntionality is that it will print Dropping CustomSmartPointer! when the instance\ngoes out of scope. This example demonstrates when Rust runs the drop\nfunction.\n\nstruct CustomSmartPointer {\ndata: String,\n}\n\nimpl Drop for CustomSmartPointer {\nfn drop(&mut self) {\n\u00a9 println! (\"Dropping CustomSmartPointer with data \u201c{}\u00b0!\", self.data);\n\n}\n\nfn main() {\n\u00a9 let c = CustomSmartPointer { data: String::from(\"my stuff\") };\n\n\u00a9 let d = CustomSmartPointer { data: String::from(\"other stuff\") };\n\u00a9 println!(\"CustomSmartPointers created.\");\n\n}\n\nListing 15-14: A CustomSmartPointer struct that implements the Drop trait where we would\nput our cleanup code\n\nThe Drop trait is included in the prelude, so we don\u2019t need to bring it\ninto scope. We implement the Drop trait on CustomSmartPointer \u00ae and provide\nan implementation for the drop method that calls println! @. The body of\nthe drop function is where you would place any logic that you wanted to\nrun when an instance of your type goes out of scope. We're printing some\ntext here to demonstrate when Rust will call drop.\n\nIn main, we create two instances of CustomSmartPointer \u00a9@ and then\nprint CustomSmartPointers created. \u00a9. At the end of main \u00a9, our instances of\nCustomSmartPointer will go out of scope, and Rust will call the code we put in\nthe drop method \u00ae, printing our final message. Note that we didn\u2019t need to\ncall the drop method explicitly.\n\nWhen we run this program, we'll see the following output:\n\nCustomSmartPointers created.\nDropping CustomSmartPointer with data \u201cother stuff!\nDropping CustomSmartPointer with data \u201cmy stuff!\n\nRust automatically called drop for us when our instances went out of\nscope, calling the code we specified. Variables are dropped in the reverse\norder of their creation, so d was dropped before c. This example gives you\na visual guide to how the drop method works; usually you would specify the\ncleanup code that your type needs to run rather than a print message.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 15.16,
                        "section_name": "Dropping a Value Early with std::mem::drop",
                        "section_path": "./screenshots-images-2/chapter_15/section_16",
                        "images": [
                            "./screenshots-images-2/chapter_15/section_16/4419589c-d47a-487a-a941-8905fa2a7d21.png",
                            "./screenshots-images-2/chapter_15/section_16/41455247-e0c6-44d7-b212-b761ac626e93.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nDropping a Value Early with std::mem::drop\n\nUnfortunately, it\u2019s not straightforward to disable the automatic drop func-\ntionality. Disabling drop isn\u2019t usually necessary; the whole point of the Drop\ntrait is that it\u2019s taken care of automatically. Occasionally, however, you might\nwant to clean up a value early. One example is when using smart pointers\nthat manage locks: you might want to force the drop method that releases\nthe lock to run so other code in the same scope can acquire the lock. Rust\ndoesn\u2019t let you call the Drop trait\u2019s drop method manually; instead you have\nto call the std: :mem::drop function provided by the standard library if you\nwant to force a value to be dropped before the end of its scope.\n\nIf we try to call the Drop trait\u2019s drop method manually by modifying the\nmain function in Listing 15-14, as shown in Listing 15-15, we'll get a com-\npiler error.\n\nfn main() {\nlet c = CustomSmartPointer { data: String::from(\"some data\") };\nprintln!(\"CustomSmartPointer created.\");\nc.drop();\nprintln!(\"CustomSmartPointer dropped before the end of main.\");\n}\n\nListing 15-15: Attempting to call the drop method from the Drop trait manually to clean up\nearly\n\nWhen we try to compile this code, we'll get this error:\n\nerror[E0040]: explicit use of destructor method\n--> src/main.rs:14:7\n\n|\n14 | c.drop()\n| *aa* explicit destructor calls not allowed\n\nThis error message states that we're not allowed to explicitly call drop.\nThe error message uses the term destructor, which is the general program-\nming term for a function that cleans up an instance. A destructor is analo-\ngous to a constructor, which creates an instance. The drop function in Rust is\none particular destructor.\n\nRust doesn't let us call drop explicitly because Rust would still automati-\ncally call drop on the value at the end of main. This would be a double free error\nbecause Rust would be trying to clean up the same value twice.\n\nWe can\u2019t disable the automatic insertion of drop when a value goes out\nof scope, and we can\u2019t call the drop method explicitly. So, if we need to force\na value to be cleaned up early, we can use the std: :mem::drop function.\n\nThe std: :mem: :drop function is different from the drop method in the\nDrop trait. We call it by passing the value we want to force to be dropped\nearly as an argument. The function is in the prelude, so we can modify\nmain in Listing 15-15 to call the drop function, as shown in Listing 15-16.\n\nsrc/main.rs\n\nfn main()\n\nlet c = Cus tring::from(\"some data\") };\n\nprintln! (\"(\ndrop(c);\n\nprintln!(\u201cCustomSmartPointer dropped before the end of main.\")\n\n}\n\nListing 15-16: Calling std: :mem: :drop to explicitly drop a value before it goes out of scope\n\nRunning this code will print the following:\n\nCustomSmartPointer created.\nDropping CustomSmartPointer with data \u201csome data\u2019!\nCustomSmartPointer dropped before the end of main.\n\nThe text Dropping CustomSmartPointer with data \u201csome data*! is printed\nbetween the CustomSmartPointer created. and CustomSmartPointer dropped before\nthe end of main. text, showing that the drop method code is called to drop c at\nthat point.\n\nYou can use code specified in a Drop trait implementation in many ways\nto make cleanup convenient and safe: for instance, you could use it to create\nyour own memory allocator! With the Drop trait and Rust\u2019s ownership system,\nyou don\u2019t have to remember to clean up because Rust does it automatically.\n\nYou also don\u2019t have to worry about problems resulting from accidentally\ncleaning up values still in use: the ownership system that makes sure refer-\nences are always valid also ensures that drop gets called only once when the\nvalue is no longer being used.\n\nNow that we've examined Box<T> and some of the characteristics of smart\npointers, let's look at a few other smart pointers defined in the standard\nlibrary.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 15.17,
                        "section_name": "Re<T>, the Reference Counted Smart Pointer",
                        "section_path": "./screenshots-images-2/chapter_15/section_17",
                        "images": [
                            "./screenshots-images-2/chapter_15/section_17/99d793cf-b5a7-4ec0-8c43-dc815d782b0f.png",
                            "./screenshots-images-2/chapter_15/section_17/6d618547-9f2c-41c9-ab43-46bd292003b6.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Re<T>, the Reference Counted Smart Pointer\n\nIn the majority of cases, ownership is clear: you know exactly which variable\nowns a given value. However, there are cases when a single value might have\nmultiple owners. For example, in graph data structures, multiple edges might\npoint to the same node, and that node is conceptually owned by all of the\nedges that point to it. A node shouldn't be cleaned up unless it doesn\u2019t have\nany edges pointing to it.\n\nTo enable multiple ownership, Rust has a type called Rc<T>, which is an\nabbreviation for reference counting. The Rc<T> type keeps track of the number\nof references to a value, which determines whether or not a value is still\nin use. If there are zero references to a value, the value can be cleaned up\nwithout any references becoming invalid.\n\nImagine Rc<T> as a TV in a family room. When one person enters to\nwatch TV, they turn it on. Others can come into the room and watch the\nTV. When the last person leaves the room, they turn off the TV because\nit\u2019s no longer being used. If someone turns off the TV while others are still\nwatching it, there would be uproar from the remaining TV watchers!\n\nWe use the Rc<T> type when we want to allocate some data on the heap\nfor multiple parts of our program to read and we can\u2019t determine at compile\ntime which part will finish using the data last. If we knew which part would\nfinish last, we could just make that part the data\u2019s owner, and the normal\nownership rules enforced at compile time would take effect.\n\nNote that Rc<T> is only for use in single-threaded scenarios. When we\ndiscuss concurrency in Chapter 16, we'll cover how to do reference count-\ning in multithreaded programs.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 15.18,
                        "section_name": "Using Re<T> to Share Data",
                        "section_path": "./screenshots-images-2/chapter_15/section_18",
                        "images": [
                            "./screenshots-images-2/chapter_15/section_18/f1d62665-dff2-45d4-aa02-04a0d3602276.png",
                            "./screenshots-images-2/chapter_15/section_18/f7e377a1-b65f-449f-9c82-a5e3c5bedcb4.png",
                            "./screenshots-images-2/chapter_15/section_18/6e9b2c2f-c838-4450-91f1-82e2a5221f0d.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nUsing Re<T> to Share Data\n\nLet\u2019s return to our cons list example in Listing 15-5. Recall that we defined\nit using Box<T>. This time, we'll create two lists that share ownership of a\nthird list. Conceptually, this looks similar to Figure 15-3.\n\nFigure 15-3: Two lists, b and c, sharing ownership of\na third list, a\n\nWe'll create list a that contains 5 and then 10. Then we'll make two\nmore lists: b that starts with 3 and c that starts with 4. Both b and c lists will\nthen continue on to the first a list containing 5 and 10. In other words, both\nlists will share the first list containing 5 and 10.\n\nTrying to implement this scenario using our definition of List with Box<T>\nwon't work, as shown in Listing 15-17.\n\nlet a = Cons(5,\n\nBox: :new(Cons(10,\nBox: :new(Nil))));\nCons(3, Box: :new(a));\nCons(4, Box: :new(a));\n\n@ let b\n@ let c\n\nListing 15-17: Demonstrating we're not allowed to have two lists using Box<T> that try to\nshare ownership of a third list\n\nsrc/main.rs\n\nWhen we compile this code, we get this error:\n\nerror[E0382]: use of moved value: \u201ca\u201d\n--> src/main.rs:13:30\n\n12 let b = Cons(3, Box::new(a));\n- value moved here\n= Cons(4, Box: :new(a));\n\n|\n|\n13 | let c\n| * value used here after move\n|\n= note: move occurs because \u201ca has type \u201cList\u2019, which does not implement\nthe \u201cCopy\u201d trait\n\nThe Cons variants own the data they hold, so when we create the b list O,\na is moved into b and b owns a. Then, when we try to use a again when creat-\ning c @, we're not allowed to because a has been moved.\n\nWe could change the definition of Cons to hold references instead, but\nthen we would have to specify lifetime parameters. By specifying lifetime\nparameters, we would be specifying that every element in the list will live at\nleast as long as the entire list. The borrow checker wouldn't let us compile\nlet a = Cons(10, &Nil); for example, because the temporary Nil value would\nbe dropped before a could take a reference to it.\n\nInstead, we'll change our definition of List to use Rc<T> in place of Box<T>,\nas shown in Listing 15-18. Each Cons variant will now hold a value and an Rc<T>\npointing to a List. When we create b, instead of taking ownership of a, we'll\nclone the Rc<List> that a is holding, thereby increasing the number of refer-\nences from one to two and letting a and b share ownership of the data in that\nRe<List>. We'll also clone a when creating c, increasing the number of refer-\nences from two to three. Every time we call Rc::clone, the reference count to\nthe data within the Rc<List> will increase, and the data won't be cleaned up\nunless there are zero references to it.\n\nenum\n\nCons(i32, Re<List>),\n\nNil,\n\nuse crate::List::{Cons, Nil};\n\nuse std::\n\nfn main {\n\n@ let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc: :new(Nil)))));\n@ let b = Cons(3, Rc::clone(&a));\n\n@ let c = Cons(4, Rc::clone(&a));\n\n}\n\nListing 15-18: A definition of List that uses Rc<T>\n\nWe need to add a use statement to bring Rc<T> into scope @ because it\u2019s\nnot in the prelude. In main, we create the list holding 5 and 10 and store it in\na new Rc<List> ina @. Then when we create b @ and c 9, we call the Re: :clone\nfunction and pass a reference to the Rc<List> in a as an argument.\n\nWe could have called a.clone() rather than Rc: :clone(&a), but Rust\u2019s\nconvention is to use Rc: :clone in this case. The implementation of Rc: :clone\ndoesn\u2019t make a deep copy of all the data as most types\u2019 implementations of\nclone do. The call to Rc: :clone only increments the reference count, which\ndoesn\u2019t take much time. Deep copies of data can take a lot of time. By using\nRc: :clone for reference counting, we can visually distinguish between the\ndeep-copy kinds of clones and the kinds of clones that increase the refer-\nence count. When looking for performance problems in the code, we only\nneed to consider the deep-copy clones and can disregard calls to Rc: :clone.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 15.19,
                        "section_name": "Goning an Re<T> Increases the Reference Count",
                        "section_path": "./screenshots-images-2/chapter_15/section_19",
                        "images": [
                            "./screenshots-images-2/chapter_15/section_19/a0b908fa-f185-4055-a0f6-ecd37fe985e9.png",
                            "./screenshots-images-2/chapter_15/section_19/57d88406-6678-4bb1-b0de-980c7188da1d.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Cloning an Re<T> Increases the Reference Count\n\nLet\u2019s change our working example in Listing 15-18 so we can see the refer-\n\nence counts changing as we create and drop references to the Rc<List> in a.\nIn Listing 15-19, we'll change main so it has an inner scope around list c;\n\nthen we can see how the reference count changes when c goes out of scope.\n\nsrc/main.rs fn main() {\nlet a = Reser\nprintln! (\u201ccount\nlet b Cons(3, Rc: :clone(&a));\nprintln!(\"count after creating b = {}\", Rc::strong_count(&a));\n\n10, R new(Nil\n\n0\", \u2018Re: :strong_count(&a));\n\nlet c = Cons(4, Rc::clone(&a));\n\nprintln!(\"count after creating c = {}\", Rc::strong_count(&a)) ;\n\nprintln!(\"count after c goes out of scope = {}\", Rc::strong_count(&a));\n\nListing 15-19: Printing the reference count\n\nAt each point in the program where the reference count changes, we\nprint the reference count, which we can get by calling the Rc: :strong_count\nfunction. This function is named strong_count rather than count because\nthe Rc<T> type also has a weak_count; we'll see what weak_count is used for in\n\u201cPreventing Reference Cycles: Turning an Rc<T> into a Weak<T>\u201d on page 341.\n\nThis code prints the following:\n\ncount after creating a = 1\ncount after creating b = 2\ncount after creating c = 3\n\ncount after c goes out of scope = 2\n\nWe can see that the Re<List> in a has an initial reference count of 1; then\neach time we call clone, the count goes up by 1. When c goes out of scope, the\ncount goes down by 1. We don\u2019t have to call a function to decrease the refer-\nence count like we have to call Rc::clone to increase the reference count: the\nimplementation of the Drop trait decreases the reference count automatically\nwhen an Rc<T> value goes out of scope.\n\nWhat we can\u2019t see in this example is that when b and then a go out of\nscope at the end of main, the count is then 0, and the Rc<List> is cleaned up\ncompletely at that point. Using Rc<T> allows a single value to have multiple\nowners, and the count ensures that the value remains valid as long as any of\nthe owners still exist.\n\nVia immutable references, Rc<T> allows you to share data between mul-\ntiple parts of your program for reading only. If Rc<T> allowed you to have\nmultiple mutable references too, you might violate one of the borrowing\nrules discussed in Chapter 4: multiple mutable borrows to the same place\ncan cause data races and inconsistencies. But being able to mutate data\nis very useful! In the next section, we'll discuss the interior mutability pat-\ntern and the RefCell<T> type that you can use in conjunction with an Rc<T> to\nwork with this immutability restriction.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 15.2,
                        "section_name": "RefCell<T> and the Interior Mutability Pattern",
                        "section_path": "./screenshots-images-2/chapter_15/section_20",
                        "images": [
                            "./screenshots-images-2/chapter_15/section_20/96c747cc-abb1-46dc-b723-02af32fb50ae.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "RefCell<T> and the Interior Mutability Pattern\n\nInterior mutability is a design pattern in Rust that allows you to mutate data\neven when there are immutable references to that data; normally, this action\nis disallowed by the borrowing rules. To mutate data, the pattern uses unsafe\ncode inside a data structure to bend Rust\u2019s usual rules that govern mutation\nand borrowing. We haven't yet covered unsafe code; we will in Chapter 19.\nWe can use types that use the interior mutability pattern when we can ensure\nthat the borrowing rules will be followed at runtime, even though the com-\npiler can\u2019t guarantee that. The unsafe code involved is then wrapped in a safe\nAPI, and the outer type is still immutable.\n\nLet's explore this concept by looking at the RefCell<T> type that follows\nthe interior mutability pattern.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 15.21,
                        "section_name": "Enforcing Borrowing Rules at Runtime with RefCell<T>",
                        "section_path": "./screenshots-images-2/chapter_15/section_21",
                        "images": [
                            "./screenshots-images-2/chapter_15/section_21/5af0bc58-7b80-47bd-b545-e252698b22a2.png",
                            "./screenshots-images-2/chapter_15/section_21/43c4c1ec-9adb-4cb5-94da-1c0a56ff087f.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Enforcing Borrowing Rules at Runtime with RefCell<T>\n\nUnlike Rc<T>, the RefCell<T> type represents single ownership over the data it\nholds. So, what makes RefCell<T> different from a type like Box<T>? Recall the\nborrowing rules you learned in Chapter 4:\n\ne Atany given time, you can have either but not both of the following: one\nmutable reference or any number of immutable references.\n\ne References must always be valid.\n\nWith references and Box<T>, the borrowing rules\u2019 invariants are enforced\nat compile time. With RefCell<T>, these invariants are enforced at runtime.\nWith references, if you break these rules, you'll get a compiler error. With\nRefCell<T>, if you break these rules, your program will panic and exit.\n\nThe advantages of checking the borrowing rules at compile time are\nthat errors will be caught sooner in the development process, and there is no\nimpact on runtime performance because all the analysis is completed before-\nhand. For those reasons, checking the borrowing rules at compile time is the\nbest choice in the majority of cases, which is why this is Rust\u2019s default.\n\nThe advantage of checking the borrowing rules at runtime instead is\nthat certain memory-safe scenarios are then allowed, whereas they are disal-\nlowed by the compile-time checks. Static analysis, like the Rust compiler, is\ninherently conservative. Some properties of code are impossible to detect by\nanalyzing the code: the most famous example is the Halting Problem, which\nis beyond the scope of this book but is an interesting topic to research.\n\nBecause some analysis is impossible, if the Rust compiler can\u2019t be sure\nthe code complies with the ownership rules, it might reject a correct pro-\ngram; in this way, it\u2019s conservative. If Rust accepted an incorrect program,\nusers wouldn't be able to trust in the guarantees Rust makes. However, if\nRust rejects a correct program, the programmer will be inconvenienced,\nbut nothing catastrophic can occur. The RefCell<T> type is useful when\nyou're sure your code follows the borrowing rules but the compiler is\nunable to understand and guarantee that.\n\nSimilar to Rc<T>, RefCell<T> is only for use in single-threaded scenarios\nand will give you a compile-time error if you try using it in a multithreaded\ncontext. We'll talk about how to get the functionality of RefCell<T> in a multi-\nthreaded program in Chapter 16.\n\nHere is a recap of the reasons to choose Box<T>, Rc<T>, or RefCell<T>:\n\n\u00a9 =Rc<T> enables multiple owners of the same data; Box<T> and RefCell<T>\nhave single owners.\n\n\u00a9 \u2014 Box<T> allows immutable or mutable borrows checked at compile time;\nRc<T> allows only immutable borrows checked at compile time; RefCell<T>\nallows immutable or mutable borrows checked at runtime.\n\ne Because RefCell<T> allows mutable borrows checked at runtime, you\ncan mutate the value inside the RefCell<T> even when the RefCell<T> is\nimmutable.\n\nMutating the value inside an immutable value is the interior mutability\npattern. Let\u2019s look at a situation in which interior mutability is useful and\nexamine how it\u2019s possible.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 15.22,
                        "section_name": "Interior Mutability: A Mutable Borrow to an Immutable Value",
                        "section_path": "./screenshots-images-2/chapter_15/section_22",
                        "images": [
                            "./screenshots-images-2/chapter_15/section_22/ee3441b9-b263-4231-9247-e36190d137e7.png",
                            "./screenshots-images-2/chapter_15/section_22/4265031e-22c5-430f-9a31-d1d693134825.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Interior Mutability: A Mutable Borrow to an Immutable Value\n\nA consequence of the borrowing rules is that when you have an immutable\nvalue, you can\u2019t borrow it mutably. For example, this code won't compile:\n\nfn main() {\nlet x = 5;\nlet y = &mut x;\n\nIf you tried to compile this code, you'd get the following error:\n\nerror[E0596]: cannot borrow immutable local variable 'x' as mutable\n--> src/main.rs:3:18\n\n2] let x = 5;\n\n| - consider changing this to \u2018mut x'\n3] let y = &mut x;\n\n|\n\n* cannot borrow mutably\n\nHowever, there are situations in which it would be useful for a value\nto mutate itself in its methods but appear immutable to other code.\nCode outside the value\u2019s methods would not be able to mutate the value.\nUsing RefCell<T> is one way to get the ability to have interior mutability. But\nRefCell<T> doesn\u2019t get around the borrowing rules completely: the borrow\nchecker in the compiler allows this interior mutability, and the borrowing\nrules are checked at runtime instead. If you violate the rules, you'll get a\npanic! instead of a compiler error.\n\nLet\u2019s work through a practical example where we can use RefCell<T> to\nmutate an immutable value and see why that is useful.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 15.23,
                        "section_name": "A Use Case for Interior Mutability: Mock Objects",
                        "section_path": "./screenshots-images-2/chapter_15/section_23",
                        "images": [
                            "./screenshots-images-2/chapter_15/section_23/30996c73-de6e-4700-b031-aa6c0cce1a5b.png",
                            "./screenshots-images-2/chapter_15/section_23/ad0a0f83-18ff-4640-b0c5-8010741872df.png",
                            "./screenshots-images-2/chapter_15/section_23/71733fa4-39b3-4125-8418-3a561edb0cfd.png",
                            "./screenshots-images-2/chapter_15/section_23/30cdaab7-012d-4857-9a53-b95a521ac16b.png",
                            "./screenshots-images-2/chapter_15/section_23/d7f69355-c422-4e73-b5f4-f37b4fbb7919.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/lib.rs\n\nA Use Case for Interior Mutability: Mock Objects\n\nA test double is the general programming concept for a type used in place of\nanother type during testing. Mock objects are specific types of test doubles\nthat record what happens during a test so you can assert that the correct\nactions took place.\n\nRust doesn\u2019t have objects in the same sense as other languages have\nobjects, and Rust doesn\u2019t have mock object functionality built into the stan-\ndard library as some other languages do. However, you can definitely create\na struct that will serve the same purposes as a mock object.\n\nHere's the scenario we'll test: we'll create a library that tracks a value\nagainst a maximum value and sends messages based on how close to the\nmaximum value the current value is. This library could be used to keep\ntrack of a user\u2019s quota for the number of API calls they're allowed to make,\nfor example.\n\nOur library will only provide the functionality of tracking how close\nto the maximum a value is and what the messages should be at what times.\nApplications that use our library will be expected to provide the mecha-\nnism for sending the messages: the application could put a message in the\napplication, send an email, send a text message, or something else. The\nlibrary doesn\u2019t need to know that detail. All it needs is something that\nimplements a trait we'll provide called Messenger. Listing 15-20 shows the\nlibrary code.\n\npub trait Messenger {\n@ fn send(&self, msg: &str);\n}\n\npub struct LimitTracker<'a, T: 'a + Messenger> {\n\nmessenger: &'a T,\nvalue: usize,\nmax: usize,\n\n}\n\nimpl<'a, T> LimitTracker<'a, T>\nwhere T: Messenger {\npub fn new(messenger: &T, max: usize) -> LimitTracker<T> {\nLimitTracker {\nmessenger,\nvalue: 0,\nmax,\n\n}\n\n\u00a9 pub fn set_value(&mut self, value: usize) {\nself.value = value;\n\nlet percentage_of_max = self.value as f64 / self.max as f64;\n\nif percentage _of_max >= 1.0 {\nself.messenger.send(\"Error: You are over your quota!\");\n} else if percentage of_max >= 0.9 {\nself .messenger.send(\"Urgent warning: You've used up over 90% of\nyour quota!\");\n} else if percentage of_max >= 0.75 {\nself.messenger.send(\"Warning: You\u2019ve used up over 75% of your\nquota!\");\n\n}\n}\n}\n\nListing 15-20: A library to keep track of how close a value is to a maximum value and\nwarn when the value is at certain levels\n\nOne important part of this code is that the Messenger trait has one\nmethod called send that takes an immutable reference to self and the text\nof the message \u00ae. This is the interface our mock object needs to have. The\nother important part is that we want to test the behavior of the set_value\nmethod on the LimitTracker @. We can change what we pass in for the value\nparameter, but set_value doesn\u2019t return anything for us to make assertions\non. We want to be able to say that if we create a LimitTracker with something\nthat implements the Messenger trait and a particular value for max, when we\npass different numbers for value, the messenger is told to send the appropri-\nate messages.\n\nWe need a mock object that, instead of sending an email or text message\nwhen we call send, will only keep track of the messages it\u2019s told to send. We\ncan create a new instance of the mock object, create a LimitTracker that uses\nthe mock object, call the set_value method on LimitTracker, and then check\nthat the mock object has the messages we expect. Listing 15-21 shows an\nattempt to implement a mock object to do just that, but the borrow checker\nwon't allow it.\n\nsrc/lib.rs\n\n#[cfg(test)]\nmod tests {\nuse super::*;\n\n@ struct MockMessenger {\n@ sent_messages: Vec<String>,\n\n}\n\nimpl MockMessenger {\n\u00a9 fn new() -> MockMessenger {\nMockMessenger { sent_messages: vec![] }\n}\n\n}\n\n\u00a9 impl Messenger for MockMessenger {\nfn send(&self, message: &str) {\n\u00a9 self.sent_messages.push(String: : from(message)) ;\n}\n}\n\n[test]\n@\u00ae fn it_sends_an_over_75_percent_warning message() {\nlet mock_messenger = MockMessenger: :new() ;\nlet mut limit_tracker = LimitTracker: :new(&mock_messenger, 100);\n\nlimit_tracker.set_value(80);\n\nassert_eq! (mock_messenger.sent_messages.len(), 1);\n}\n\nListing 15-21: An attempt to implement a MockMessenger that isn't allowed by the borrow\nchecker\n\nThis test code defines a MockMessenger struct @ that has a sent_messages\nfield with a Vec of String values @ to keep track of the messages it\u2019s told to\nsend. We also define an associated function new \u00a9 to make it convenient\nto create new MockMessenger values that start with an empty list of messages.\nWe then implement the Messenger trait for MockMessenger @ so we can give a\nMockMessenger to a LimitTracker. In the definition of the send method \u00a9, we\ntake the message passed in as a parameter and store it in the MockMessenger\nlist of sent_messages.\n\nIn the test, we're testing what happens when the LimitTracker is told\nto set value to something that is more than 75 percent of the max value \u00a9.\nFirst, we create a new MockMessenger, which will start with an empty list of\nmessages. Then we create a new LimitTracker and give it a reference to the\nnew MockMessenger and a max value of 100. We call the set_value method on\nthe LimitTracker with a value of 80, which is more than 75 percent of 100.\nThen we assert that the list of messages the MockMessenger is keeping track of\nshould now have one message in it.\n\nsrc/lib.rs\n\nHowever, there\u2019s one problem with this test, as shown here:\n\nerror[E0596]: cannot borrow immutable field \u2018self.sent_messages' as mutable\n--> src/lib.rs:52:13\n|\n\n51 | fn send(&self, message: &str) {\nfo eee use '&mut self\u2019 here to make mutable\n52 | self.sent_messages.push(String: : from(message)) ;\n\n| AAAAABARAAARARAADN Cannot mutably borrow immutable field\n\nWe can\u2019t modify the MockMessenger to keep track of the messages, because\n\nthe send method takes an immutable reference to self. We also can\u2019t take the\n\nsuggestion from the error text to use &mut self instead, because then the sig-\nnature of send wouldn't match the signature in the Messenger trait definition\n(feel free to try it out and see what error message you get).\n\nThis is a situation in which interior mutability can help! We'll store the\nsent_messages within a RefCell<T>, and then the send message will be able to\nmodify sent_messages to store the messages we've seen. Listing 15-22 shows\nwhat that looks like.\n\n#[cfg(test) ]\n\nmod t\nuse super::*;\n\nuse std::cell::RefCell;\n\nstruct MockMessenger {\n\n@ sent_messages: RefCell<Vec<String>>,\n}\n\nimp1 MockMessenger {\n\nfn new()\n\u00a9 MockMessenger { sent_messages: RefCell::new(vec![]) }\n\n-> MockMessenger {\n\n}\ner for MockMessenger {\nfn self, message: &str) {\n\n\u00a9 self.sent_messages.borrow_mut().push(String: : from(message) ) ;\n\nimpl Mess:\n\n}\n\n#[test]\nfn f\n\nit_sends_an_over_75_percent_warning_message() {\n\nsnip\n\n\u00a9 assert_eq! (mock_messenger.sent_messages.borrow().len(), 1);\n}\n\nListing 15-22: Using RefCell<T> to mutate an inner value while the outer value is consid-\nered immutable\n\nThe sent_messages field is now of type RefCell<Vec<String>> \u00ae instead\nof Vec<String>. In the new function, we create a new RefCell<Vec<String>>\ninstance around the empty vector \u00ae.\n\nFor the implementation of the send method, the first parameter is\nstill an immutable borrow of self, which matches the trait definition. We\ncall borrow_mut on the RefCell<Vec<String>> in self.sent_messages \u00ae to geta\nmutable reference to the value inside the RefCell<Vec<String>>, which is the\nvector. Then we can call push on the mutable reference to the vector to keep\ntrack of the messages sent during the test.\n\nThe last change we have to make is in the assertion: to see how many\nitems are in the inner vector, we call borrow on the RefCell<Vec<String>> to get\nan immutable reference to the vector 9.\n\nNow that you've seen how to use RefCell<T\u00bb, let\u2019s dig into how it works!\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 15.24,
                        "section_name": "Keeping Track of Borrows at Runtime with RefCell<T>",
                        "section_path": "./screenshots-images-2/chapter_15/section_24",
                        "images": [
                            "./screenshots-images-2/chapter_15/section_24/cc24a5d4-dfa6-4a45-ba66-4bfd95adc074.png",
                            "./screenshots-images-2/chapter_15/section_24/024f5445-1903-454e-aad9-85a2600cfdf7.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "sre/lib.rs\n\nKeeping Track of Borrows at Runtime with RefCell<T>\n\nWhen creating immutable and mutable references, we use the & and &mut syn-\ntax, respectively. With RefCell<T>, we use the borrow and borrow_mut methods,\nwhich are part of the safe API that belongs to RefCell<T>. The borrow method\nreturns the smart pointer type Ref<T>, and borrow_mut returns the smart\npointer type RefMut<T>. Both types implement Deref, so we can treat them like\nregular references.\n\nThe RefCell<T> keeps track of how many Ref<T> and RefMut<T> smart\npointers are currently active. Every time we call borrow, the RefCell<T>\nincreases its count of how many immutable borrows are active. When a\nRef<T> value goes out of scope, the count of immutable borrows goes down\nby one. Just like the compile-time borrowing rules, RefCell<T> lets us have\nmany immutable borrows or one mutable borrow at any point in time.\n\nIf we try to violate these rules, rather than getting a compiler error as\nwe would with references, the implementation of RefCell<T> will panic at\nruntime. Listing 15-23 shows a modification of the implementation of send\nin Listing 15-22. We're deliberately trying to create two mutable borrows\nactive for the same scope to illustrate that RefCell<T> prevents us from doing\nthis at runtime.\n\nimpl Messenger for MockMe\n\nfn send(&self, message: &str) {\nlet mut one_borrow = self.sent_messages.borrow_mut();\nlet mut two_borrow = self.sent_messages.borrow_mut();\n\none_borrow.push(String: : from(message));\ntwo_borrow.push(String: :from(message) ) ;\n\n}\n\nListing 15-23: Creating two mutable references in the same scope to see that RefCell<T>\nwill panic\n\nWe create a variable one_borrow for the RefMut<T> smart pointer returned\nfrom borrow_mut. Then we create another mutable borrow in the same way\nin the variable two_borrow. This makes two mutable references in the same\nscope, which isn\u2019t allowed. When we run the tests for our library, the code\nin Listing 15-23 will compile without any errors, but the test will fail:\n\n---- tests::it_sends_an_over_75_percent_warning_message stdout ----\n\nthread 'tests::it_sends_an_over_75_percent_warning message\u2019 panicked\nat \u2018already borrowed: BorrowMutError\u2019, src/libcore/result.rs:906:4\nnote: Run with 'RUST_BACKTRACE=1' for a backtrace.\n\nNotice that the code panicked with the message already borrowed:\nBorrow4utError. This is how RefCell<T> handles violations of the borrowing\nrules at runtime.\n\nCatching borrowing errors at runtime rather than compile time means\nthat you would find a mistake in your code later in the development process\nand possibly not until your code was deployed to production. Also, your code\nwould incur a small runtime performance penalty as a result of keeping\ntrack of the borrows at runtime rather than compile time. However, using\nRefCell<T> makes it possible to write a mock object that can modify itself to\nkeep track of the messages it has seen while you're using it in a context where\nonly immutable values are allowed. You can use RefCell<T> despite its trade-\noffs to get more functionality than regular references provide.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 15.25,
                        "section_name": "Having Multiple Owners of Mutable Data by Combining Re<T> and\nRefCell<T>",
                        "section_path": "./screenshots-images-2/chapter_15/section_25",
                        "images": [
                            "./screenshots-images-2/chapter_15/section_25/7ee999de-fb21-4a82-939f-9fa5b7e6c32b.png",
                            "./screenshots-images-2/chapter_15/section_25/a87583da-54b9-4417-86c1-a2fec630310b.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nHaving Multiple Owners of Mutable Data by Combining Re<T> and\nRefCell<T>\n\nA common way to use RefCell<T> is in combination with Rce<T>. Recall that\nRc<T> lets you have multiple owners of some data, but it only gives immutable\naccess to that data. If you have an Rc<T> that holds a RefCell<T>, you can get a\nvalue that can have multiple owners and that you can mutate!\n\nFor example, recall the cons list example in Listing 15-18 where we used\nRc<T> to allow multiple lists to share ownership of another list. Because Rc<T>\nholds only immutable values, we can\u2019t change any of the values in the list\nonce we've created them. Let\u2019s add in RefCell<T> to gain the ability to change\nthe values in the lists. Listing 15-24 shows that by using a RefCell<T> in the Cons\ndefinition, we can modify the value stored in all the lists.\n\n#[derive(Debug) ]\nCons (Rc<RefCell<i32>>, Rc<List>),\n\n1\n\nuse std::cell::RefCell;\n\nn main\n\n@ let value = Re::new(RefCell: :new(S));\n\u00a9 let a = Rc::new(Cons(Rc::clone(&value), Rc::new(Nil)));\n\nlet b\nlet\n\nCons(Re::new(RefCell: :new(6)), Re::clone(&a));\nCons(Rc::new(RefCell: :new(10)), Re: :clone(&a));\n\n\u00a9 *value.borrow_mut() += 10;\n\nprintln!(\"a after = {:?}\", a);\n\nprintln!(\"b after = {:?}\", b);\n\nprintln!(\"c after = {:?}\", c);\n}\n\nListing 15-24: Using Rc<RefCe11<i32>> to create a List that we can mutate\n\nWe create a value that is an instance of Rc<RefCell<i32>> and store it in a\nvariable named value @ so we can access it directly later. Then we create a\nList in a with a Cons variant that holds value @. We need to clone value so\nboth a and value have ownership of the inner 5 value rather than transfer-\nring ownership from value to a or having a borrow from value.\n\nWe wrap the list a in an Rc<T> so when we create lists b and c, they can\nboth refer to a, which is what we did in Listing 15-18.\n\nAfter we've created the lists in a, b, and c, we add 10 to the value in\nvalue \u00ae. We do this by calling borrow_mut on value, which uses the automatic\ndereferencing feature we discussed in Chapter 5 (see \u201cWhere\u2019s the ->\nOperator?\u201d on page 94) to dereference the Rc<T> to the inner RefCell<T>\nvalue. The borrow mut method returns a RefMut<T> smart pointer, and we use\nthe dereference operator on it and change the inner value.\n\nWhen we print a, b, and c, we can see that they all have the modified\nvalue of 15 rather than 5:\n\na after = Cons(RefCell { value: 15 }, Nil)\nb after = Cons(RefCell { value: 6 }, Cons(RefCell { value: 15 }, Nil))\nc after = Cons(RefCell { value: 10 }, Cons(RefCell { value: 15 }, Nil))\n\nThis technique is pretty neat! By using RefCell<T>, we have an outwardly\nimmutable List value. But we can use the methods on RefCell<T> that pro-\nvide access to its interior mutability so we can modify our data when we\nneed to. The runtime checks of the borrowing rules protect us from data\nraces, and it\u2019s sometimes worth trading a bit of speed for this flexibility in\nour data structures.\n\nThe standard library has other types that provide interior mutability,\nsuch as Cell<T>, which is similar except that instead of giving references to\nthe inner value, the value is copied in and out of the Cell<T>. There's also\nMutex<T>, which offers interior mutability that\u2019s safe to use across threads;\nwe'll discuss its use in Chapter 16. Check out the standard library docs for\nmore details on the differences between these types.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 15.26,
                        "section_name": "Reference Cycles Can Leak Memory",
                        "section_path": "./screenshots-images-2/chapter_15/section_26",
                        "images": [
                            "./screenshots-images-2/chapter_15/section_26/27f46c44-427f-4fb8-89d3-68f6cf73e51d.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Reference Cycles Can Leak Memory\n\nRust\u2019s memory safety guarantees make it difficult, but not impossible, to\naccidentally create memory that is never cleaned up (known as a memory\nleak). Preventing memory leaks entirely is not one of Rust\u2019s guarantees\n\nin the same way that disallowing data races at compile time is, meaning\nmemory leaks are memory safe in Rust. We can see that Rust allows memory\nleaks by using Rc<T> and RefCell<T>: it\u2019s possible to create references where\nitems refer to each other in a cycle. This creates memory leaks because the\nreference count of each item in the cycle will never reach 0, and the values\nwill never be dropped.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 15.27,
                        "section_name": "Grating a Reference Cycle",
                        "section_path": "./screenshots-images-2/chapter_15/section_27",
                        "images": [
                            "./screenshots-images-2/chapter_15/section_27/4eafed03-258f-47ad-b347-0af8de4d916a.png",
                            "./screenshots-images-2/chapter_15/section_27/059bd7cc-ba9e-4117-9a27-fd24720f5404.png",
                            "./screenshots-images-2/chapter_15/section_27/00cc1a7f-ec40-425e-b005-da1c8fe37bef.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nGrating a Reference Cycle\n\nLet's look at how a reference cycle might happen and how to prevent it, start-\ning with the definition of the List enum and a tail method in Listing 15-25.\n\nuse std::rc::Re;\nuse std::cell::RefCell;\nuse crate::List::{Cons, Nil};\n\n#[derive (Debug) ]\n\nenum List {\n\n\u00a9 Cons(i32, RefCell<Rc<List>>),\nNil,\n\n}\n\nimpl List {\n\u00a9 fn tail(&self) -> Option<&RefCell<Re<List>>> {\nmatch self {\nCons(_, item) => Some(item),\nNil => None,\n\n}\n\nListing 15-25: A cons list definition that holds a RefCell<T> so we can modify what a Cons\nvariant is referring to\n\nWe're using another variation of the List definition from Listing 15-5.\nThe second element in the Cons variant is now RefCell<Rc<List>> @, mean-\ning that instead of having the ability to modify the i32 value as we did in\nListing 15-24, we want to modify which List value a Cons variant is pointing\nto. We're also adding a tail method \u00ae to make it convenient for us to access\nthe second item if we have a Cons variant.\n\nIn Listing 15-26, we\u2019re adding a main function that uses the definitions\nin Listing 15-25. This code creates a list in a and a list in b that points to\nthe list in a. Then it modifies the list in a to point to b, creating a reference\ncycle. There are println! statements along the way to show what the refer-\nence counts are at various points in this process.\n\nsrc/main.rs\n\nfn main() {\n\n@ let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));\n\nprintln!(\"a initial rc count = {}\", Rc::strong_count(&a));\nprintln!(\"a next item = {:?}\", a.tail());\n\n@ let b = Rce::new(Cons(10, RefCell::new(Rc::clone(&a))));\n\nprintln!(\"a rc count after b creation = {}\", Rc::strong_count(&a));\nprintln!(\"b initial rc count = {}\", Rc::strong_count(&b));\nprintln!(\"b next item = {:?}\", b.tail());\n\n\u00a9 if let Some(link) = a.tail() {\n\u00a9 *Link.borrow_mut() = Rc: :clone(&b) ;\n}\n\nprintln!(\"b rc count after changing a\n\n= {}\", Re::strong_count(&b));\nprintln!(\"a rc count after changing a = {\n\n\", Rez:strong_count(&a));\n\n// Uncomment the next line to see that we have a cycle;\n// it will overflow the stack.\n// println!(\"a next item = {:?}\", a.tail());\n\n}\n\nListing 15-26: Creating a reference cycle of two List values pointing to each other\n\nWe create an Rc<List> instance holding a List value in the variable a\nwith an initial list of 5, Nil @. We then create an Rc<List> instance holding\nanother List value in the variable b that contains the value 10 and points to\nthe list in a @.\n\nWe modify a so it points to b instead of Nil, creating a cycle. We do that\nby using the tail method to get a reference to the RefCell<Rc<List>> in a,\nwhich we put in the variable link \u00a9. Then we use the borrow_mut method on\nthe RefCell<Rc<List>> to change the value inside from an Rc<List> that holds\na Nil value to the Re<List> in b \u00ae.\n\nWhen we run this code, keeping the last println! commented out for\nthe moment, we'll get this output:\n\na initial re count = 1\n\na next item = Some(RefCell { value: Nil })\n\na rc count after b creation = 2\n\nb initial re count = 1\n\nb next item = Some(RefCell { value: Cons(5, RefCell { value: Nil }) })\nb re count after changing a = 2\n\na re count after changing a = 2\n\nThe reference count of the Rc<List> instances in both a and b are 2 after\nwe change the list in a to point to b. At the end of main, Rust will try to drop\nb first, which will decrease the count of the Rc<List> instance in b by 1.\n\nHowever, because a is still referencing the Rc<List> that was in b, that\nRe<List> has a count of 1 rather than 0, so the memory the Rc<List> has on\nthe heap won't be dropped. The memory will just sit there with a count\n\nof 1, forever. To visualize this reference cycle, we've [a | rs]\ncreated the diagram in Figure 15-4.\n\nIf you uncomment the last print1n! and run\nthe program, Rust will try to print this cycle with Lio| | | >|\na pointing to b pointing to a and so forth until it\noverflows the stack.\n\nIn this case, right after we create the reference\ncycle, the program ends. The consequences of this\ncycle aren\u2019t very dire. However, if a more complex\nprogram allocated lots of memory in a cycle and\nheld onto it for a long time, the program would use more memory than it\nneeded and might overwhelm the system, causing it to run out of available\nmemory.\n\nCreating reference cycles is not easily done, but it\u2019s not impossible either.\nIf you have RefCell<T> values that contain Rc<T> values or similar nested com-\nbinations of types with interior mutability and reference counting, you must\nensure that you don\u2019t create cycles; you can\u2019t rely on Rust to catch them.\nCreating a reference cycle would be a logic bug in your program that you\nshould use automated tests, code reviews, and other software development\npractices to minimize.\n\nAnother solution for avoiding reference cycles is reorganizing your data\nstructures so that some references express ownership and some references\ndon't. As a result, you can have cycles made up of some ownership relation-\nships and some non-ownership relationships, and only the ownership rela-\ntionships affect whether or not a value can be dropped. In Listing 15-25, we\nalways want Cons variants to own their list, so reorganizing the data structure\nisn\u2019t possible. Let\u2019s look at an example using graphs made up of parent nodes\nand child nodes to see when non-ownership relationships are an appropriate\nway to prevent reference cycles.\n\nFigure 15-4: A reference\ncycle of lists a and b\npointing to each other\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 15.28,
                        "section_name": "Preventing Reference Cycles: Turning an Rc<T> into a Weak<T>",
                        "section_path": "./screenshots-images-2/chapter_15/section_28",
                        "images": [
                            "./screenshots-images-2/chapter_15/section_28/db32878a-af9f-4d9c-9170-aa6f419fc70c.png",
                            "./screenshots-images-2/chapter_15/section_28/10cb476d-42b6-46cf-8075-fc62e1743e9c.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Preventing Reference Cycles: Turning an Rc<T> into a Weak<T>\n\nSo far, we've demonstrated that calling Rc: :clone increases the strong_count\nof an Rc<T> instance, and an Rc<T> instance is only cleaned up if its strong_count\nis 0. You can also create a weak reference to the value within an Rc<T> instance\nby calling Rc: :downgrade and passing a reference to the Rc<T>. When you call\nRc: :downgrade, you get a smart pointer of type Weak<T>. Instead of increasing\nthe strong_count in the Rc<T> instance by 1, calling Rc: :downgrade increases\n\nthe weak_count by 1. The Rc<T> type uses weak_count to keep track of how many\nWeak<T> references exist, similar to strong_count. The difference is the weak_count\ndoesn\u2019t need to be 0 for the Rc<T> instance to be cleaned up.\n\nStrong references are how you can share ownership of an Rc<T> instance.\nWeak references don\u2019t express an ownership relationship. They won't cause\na reference cycle because any cycle involving some weak references will be\nbroken once the strong reference count of values involved is 0.\n\nBecause the value that Weak<T> references might have been dropped,\nto do anything with the value that a Weak<T> is pointing to, you must make\nsure the value still exists. Do this by calling the upgrade method on a Weak<T>\n\ninstance, which will return an Option<Rc<T>>. You'll get a result of Some if the\nRc<T> value has not been dropped yet and a result of None if the Re<T> value has\nbeen dropped. Because upgrade returns an Option<T>, Rust will ensure that the\nSome case and the None case are handled, and there won't be an invalid pointer.\n\nAs an example, rather than using a list whose items know only about\nthe next item, we'll create a tree whose items know about their children\nitems and their parent items.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 15.29,
                        "section_name": "Creating a Tree Data Structure: a Node with Child Nodes",
                        "section_path": "./screenshots-images-2/chapter_15/section_29",
                        "images": [
                            "./screenshots-images-2/chapter_15/section_29/71abf2c8-5302-444e-b36f-3263c661abf5.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nsrc/main.rs\n\nCreating a Tree Data Structure: a Node with Child Nodes\n\nTo start, we'll build a tree with nodes that know about their child nodes. We'll\ncreate a struct named Node that holds its own i32 value as well as references to\nits children Node values:\n\nuse std::rc::Re;\nuse std::cell::RefCell;\n\n#[derive(Debug) ]\nstruct Node {\nvalue: i32,\nchildren: RefCell<Vec<Rc<Node>>>,\n\nWe want a Node to own its children, and we want to share that ownership\nwith variables so we can access each Node in the tree directly. To do this, we\ndefine the Vec<T> items to be values of type Rc<Node>. We also want to modify\nwhich nodes are children of another node, so we have a RefCell<T> in children\naround the Vec<Rc<Node>>.\n\nNext, we'll use our struct definition and create one Node instance named\nleaf with the value 3 and no children, and another instance named branch\nwith the value 5 and leaf as one of its children, as shown in Listing 15-27.\n\nfn main() {\nlet leaf = Re::new(Node {\nvalue: 3,\nchildren: RefCell::new(vec![]),\n})3\nlet branch = Rc::new(Node {\nvalue: 5,\nchildren: RefCell::new(vec![Rc::clone(&leaf)]),\n})3\n}\n\nListing 15-27: Creating a leaf node with no children and a branch node with leaf as one\nof its children\n\nWe clone the Rc<Node> in leaf and store that in branch, meaning the\nNode in leaf now has two owners: leaf and branch. We can get from branch to\nleaf through branch.children, but there\u2019s no way to get from leaf to branch.\nThe reason is that leaf has no reference to branch and doesn\u2019t know they\u2019re\nrelated. We want leaf to know that branch is its parent. We'll do that next.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 15.3,
                        "section_name": "Adding a Reference from a Child to Its Parent",
                        "section_path": "./screenshots-images-2/chapter_15/section_30",
                        "images": [
                            "./screenshots-images-2/chapter_15/section_30/7daa50d5-347a-4425-ba0f-af480969fb5b.png",
                            "./screenshots-images-2/chapter_15/section_30/69a40684-7e79-4fef-9b5e-35982c3ea861.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nsrc/main.rs\n\nAdding a Reference from a Child to Its Parent\n\nTo make the child node aware of its parent, we need to add a parent field to\nour Node struct definition. The trouble is in deciding what the type of parent\nshould be. We know it can\u2019t contain an Re<T>, because that would create a ref-\nerence cycle with leaf.parent pointing to branch and branch.children pointing\nto leaf, which would cause their strong_count values to never be 0.\n\nThinking about the relationships another way, a parent node should own\nits children: if a parent node is dropped, its child nodes should be dropped as\nwell. However, a child should not own its parent: if we drop a child node, the\nparent should still exist. This is a case for weak references!\n\nSo instead of Rc<T>, we'll make the type of parent use Weak<T>, specifically\na RefCell<Weak<Node>>. Now our Node struct definition looks like this:\n\nuse std: ire: 2{Re, Perit\n\nNod\n\nparent: RefCeleaketode>>,\nchildre efCell<Vec<Rc<Node\n\nA node will be able to refer to its parent node but doesn\u2019t own its par-\nent. In Listing 15-28, we update main to use this new definition so the leaf\nnode will have a way to refer to its parent, branch.\n\nTN main(\nlet leaf = Re::new(Node {\n3,\ne parent: RefCell: :new(Weak: inew()),\n\ndren: RefCell: :new(vec![]),\n\nb)5\n\u00a9 println! (\"leaf parent = {:?}\", leaf.parent.borrow().upgrade());\n\nlet branch = Rc::new(Node {\n\nje\n\n\u00a9 parent: RefCell: :new (Weak: inew()),\nchildren: RefCell::new(vec! [Rc::clone(&leaf)]),\n\n\u00a9 *leaf.parent.borrow_mut() = Rc::downgrade(&branch) ;\n\n\u00a9 println! (\"leaf parent = {:?}\", leaf.parent.borrow().upgrade());\n\nListing 15-28: A leaf node with a weak reference to its parent node branch\n\nCreating the leaf node looks similar to how creating the leaf node\nlooked in Listing 15-27 with the exception of the parent field: leaf starts out\nwithout a parent, so we create a new, empty Weak<Node> reference instance O.\n\nAt this point, when we try to get a reference to the parent of leaf by using\nthe upgrade method, we get a None value. We see this in the output from the\nfirst println! statement @:\n\nleaf parent = None\n\nWhen we create the branch node, it will also have a new Weak<Node> refer-\nence in the parent field \u00a9, because branch doesn\u2019t have a parent node. We still\nhave leaf as one of the children of branch. Once we have the Node instance in\nbranch, we can modify leaf to give it a Weak<Node> reference to its parent \u00a9. We\nuse the borrow_mut method on the RefCell<Weak<Node>> in the parent field of leaf,\nand then we use the Rc: : downgrade function to create a Weak<Node> reference to\nbranch from the Rc<Node> in branch.\n\nWhen we print the parent of leaf again \u00a9, this time we'll get a Some vari-\nant holding branch: now leaf can access its parent! When we print leaf, we\nalso avoid the cycle that eventually ended in a stack overflow like we had in\nListing 15-26; the Weak<Node> references are printed as (weak):\n\nleaf parent = Some(Node { value: 5, parent: RefCell { value: (Weak) },\nchildren: RefCell { value: [Node { value: 3, parent: RefCell { value: (Weak)\n}, children: RefCell { value: [] } }] } })\n\nThe lack of infinite output indicates that this code didn\u2019t create a refer-\nence cycle. We can also tell this by looking at the values we get from calling\nRe::strong_count and Rc::weak_count.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 15.31,
                        "section_name": "Visualizing Changes to strong_count and weak_count",
                        "section_path": "./screenshots-images-2/chapter_15/section_31",
                        "images": [
                            "./screenshots-images-2/chapter_15/section_31/99939b8b-680b-488d-b417-b0e388389c6d.png",
                            "./screenshots-images-2/chapter_15/section_31/55a6f94b-a299-4114-b7eb-5c372784d495.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Visualizing Changes to strong_count and weak_count\n\nLet\u2019s look at how the strong_count and weak_count values of the Rc<Node>\ninstances change by creating a new inner scope and moving the creation\nof branch into that scope. By doing so, we can see what happens when\nbranch is created and then dropped when it goes out of scope. The mod-\nifications are shown in Listing 15-29.\n\nsrc/main.rs fn main\n\n\u00ae printin!(\n\u201cleaf strong = {}, weak = {}\",\nRc::strong_count(&leaf),\nRe: :weak_count(&leaf),\n\n)3\n\n-parent.borrow_mut() = Rc: :downgrade(&branck\n\n\u00a9 println!(\n\u201cbranch strong = {}, weak = {}\",\nRc::strong_count(&branch),\nRc: :weak_count(&branch),\n\n)3\n\n\u00a9 println!(\n\u201cleaf strong = {}, weak = {}\",\nRc::strong_count(&leaf),\nRc: :weak_count(&leaf),\n)s\n@}\n\n@ printlr eaf parent = {:?}\", leaf.parent.borrow().upgrade());\n@ println!(\n\u201cleaf strong = {}, weak = {}\",\nRc::strong_count(&leaf),\nRc: :weak_count(&leaf),\n)s\n}\n\nListing 15-29: Creating branch in an inner scope and examining strong and weak reference\ncounts\n\nAfter leaf is created, its Rc<Node> has a strong count of 1 and a weak count\nof 0 @. In the inner scope \u00ae, we create branch and associate it with leaf, at\nwhich point when we print the counts \u00ae, the Rc<Node> in branch will have a\nstrong count of 1 and a weak count of 1 (for leaf.parent pointing to branch\nwith a Weak<Node>). When we print the counts in leaf @, we'll see it will have\na strong count of 2, because branch now has a clone of the Rc<Node> of leaf\nstored in branch.children, but will still have a weak count of 0.\n\nWhen the inner scope ends \u00a9, branch goes out of scope and the strong\ncount of the Rc<Node> decreases to 0, so its Node is dropped. The weak count\nof 1 from leaf.parent has no bearing on whether or not Node is dropped, so\nwe don\u2019t get any memory leaks!\n\nIf we try to access the parent of leaf after the end of the scope, we'll get\nNone again @. At the end of the program @, the Rc<Node> in leaf has a strong\ncount of 1 and a weak count of 0, because the variable leaf is now the only\nreference to the Rc<Node> again.\n\nAll of the logic that manages the counts and value dropping is built into\nRc<T> and Weak<T> and their implementations of the Drop trait. By specifying\nthat the relationship from a child to its parent should be a Weak<T> reference\nin the definition of Node, you're able to have parent nodes point to child nodes\nand vice versa without creating a reference cycle and memory leaks.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 15.32,
                        "section_name": "Summary",
                        "section_path": "./screenshots-images-2/chapter_15/section_32",
                        "images": [
                            "./screenshots-images-2/chapter_15/section_32/edb4d1f1-78b5-4da8-9645-3d840f149478.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Summary\n\nThis chapter covered how to use smart pointers to make different guarantees\nand trade-offs than those Rust makes by default with regular references. The\nBox<T> type has a known size and points to data allocated on the heap. The\nRce<T> type keeps track of the number of references to data on the heap so\nthat data can have multiple owners. The RefCell<T> type with its interior\nmutability gives us a type that we can use when we need an immutable type\nbut need to change an inner value of that type; it also enforces the borrow-\ning rules at runtime instead of at compile time.\n\nAlso discussed were the Deref and Drop traits, which enable a lot of the\nfunctionality of smart pointers. We explored reference cycles that can cause\nmemory leaks and how to prevent them using Weak<T>.\n\nIf this chapter has piqued your interest and you want to implement your\nown smart pointers, check out The Rustonomicon at https://doc.rust-lang.org/\nstable/nomicon/ for more information.\n\nNext, we'll talk about concurrency in Rust. You'll even learn about a few\nnew smart pointers.\n",
                        "extracted-code": ""
                    }
                ]
            },
            {
                "chapter_id": 16,
                "chapter_name": "FEARLESS CONCURRENCY",
                "chapter_path": "./screenshots-images-2/chapter_16",
                "sections": [
                    {
                        "section_id": 16.1,
                        "section_name": "FEARLESS CONCURRENCY",
                        "section_path": "./screenshots-images-2/chapter_16/section_1",
                        "images": [
                            "./screenshots-images-2/chapter_16/section_1/ac2fef95-0e07-49ea-9b00-64cf28f84c62.png",
                            "./screenshots-images-2/chapter_16/section_1/5e3be6df-f368-43e0-bbc1-6c66bad9d465.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Handling concurrent programming safely\nand efficiently is another of Rust\u2019s major\ngoals. Concurrent programming, where differ-\nent parts of a program execute independently,\nand parallel programming, where different parts of\na program execute at the same time, are becom-\ning increasingly important as more computers take\nadvantage of their multiple processors. Historically,\nprogramming in these contexts has been difficult and\nerror prone: Rust hopes to change that.\n\nInitially, the Rust team thought that ensuring memory safety and pre-\nventing concurrency problems were two separate challenges to be solved\nwith different methods. Over time, the team discovered that the owner-\nship and type systems are a powerful set of tools to help manage memory\nsafety and concurrency problems! By leveraging ownership and type check-\ning, many concurrency errors are compile-time errors in Rust rather than\n\n\nruntime errors. Therefore, rather than making you spend lots of time\ntrying to reproduce the exact circumstances under which a runtime con-\ncurrency bug occurs, incorrect code will refuse to compile and present\n\nan error explaining the problem. As a result, you can fix your code while\nyou're working on it rather than potentially after it has been shipped to pro-\nduction. We've nicknamed this aspect of Rust fearless concurrency. Fearless\nconcurrency allows you to write code that is free of subtle bugs and is easy\nto refactor without introducing new bugs.\n\nFor simplicity\u2019s sake, we'll refer to many of the problems as concurrent rather than\nbeing more precise by saying concurrent and/or parallel. If this book were about\nconcurrency and/or parallelism, wed be more specific. For this chapter, please men-\ntally substitute concurrent and/or parallel whenever we use concurrent.\n\nMany languages are dogmatic about the solutions they offer for handling\nconcurrent problems. For example, Erlang has elegant functionality for\nmessage-passing concurrency but has only obscure ways to share state\nbetween threads. Supporting only a subset of possible solutions is a reason-\nable strategy for higher-level languages, because a higher-level language\npromises benefits from giving up some control to gain abstractions. However,\nlower-level languages are expected to provide the solution with the best\nperformance in any given situation and have fewer abstractions over the\nhardware. Therefore, Rust offers a variety of tools for modeling problems in\nwhatever way is appropriate for your situation and requirements.\n\nHere are the topics we'll cover in this chapter:\n\ne How to create threads to run multiple pieces of code at the same time\n\ne  Message-passing concurrency, where channels send messages between\nthreads\n\ne  Shared-state concurrency, where multiple threads have access to some\npiece of data\n\ne The Sync and Send traits, which extend Rust\u2019s concurrency guarantees to\nuser-defined types as well as types provided by the standard library\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 16.2,
                        "section_name": "Using Threads to Run Code Simultaneously",
                        "section_path": "./screenshots-images-2/chapter_16/section_2",
                        "images": [
                            "./screenshots-images-2/chapter_16/section_2/c2cd8333-7e25-4ef7-b059-07553ff40340.png",
                            "./screenshots-images-2/chapter_16/section_2/743ca43b-6e1f-482c-a2e0-93662270a43c.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Using Threads to Run Code Simultaneously\n\nIn most current operating systems, an executed program\u2019s code is run\nin a process, and the operating system manages multiple processes at\nonce. Within your program, you can also have independent parts that\nrun simultaneously. The features that run these independent parts are\ncalled threads.\n\nSplitting the computation in your program into multiple threads can\nimprove performance because the program does multiple tasks at the same\ntime, but it also adds complexity. Because threads can run simultaneously,\n\nthere\u2019s no inherent guarantee about the order in which parts of your code\non different threads will run. This can lead to problems, such as:\n\ne Race conditions, where threads are accessing data or resources in an\ninconsistent order\n\ne Deadlocks, where two threads are waiting for each other to finish\nusing a resource the other thread has, preventing both threads from\ncontinuing\n\ne Bugs that happen only in certain situations and are hard to reproduce\nand fix reliably\n\nRust attempts to mitigate the negative effects of using threads, but\nprogramming in a multithreaded context still takes careful thought and\nrequires a code structure that is different from that in programs running\nin a single thread.\n\nProgramming languages implement threads in a few different ways. Many\noperating systems provide an API for creating new threads. This model where\na language calls the operating system APIs to create threads is sometimes\ncalled J:J, meaning one operating system thread per one language thread.\n\nMany programming languages provide their own special implementa-\ntion of threads. Programming language\u2014provided threads are known as green\nthreads, and languages that use these green threads will execute them in the\ncontext of a different number of operating system threads. For this reason,\nthe green-threaded model is called the M:N model: there are 4 green threads\nper 4 operating system threads, where M and N are not necessarily the same\nnumber.\n\nEach model has its own advantages and trade-offs, and the trade-off\nmost important to Rust is runtime support. Runtime is a confusing term and\ncan have different meanings in different contexts.\n\nIn this context, by runtime we mean code that is included by the language\nin every binary. This code can be large or small depending on the language,\nbut every non-assembly language will have some amount of runtime code.\nFor that reason, colloquially when people say a language has \u201cno runtime,\u201d\nthey often mean \u201csmall runtime.\u201d Smaller runtimes have fewer features but\nhave the advantage of resulting in smaller binaries, which make it easier to\ncombine the language with other languages in more contexts. Although\nmany languages are okay with increasing the runtime size in exchange for\nmore features, Rust needs to have nearly no runtime and cannot compromise\non being able to call into C to maintain performance.\n\nThe green-threading M:N model requires a larger language runtime to\nmanage threads. As such, the Rust standard library only provides an imple-\nmentation of 1:1 threading. Because Rust is such a low-level language, there\nare crates that implement M:N threading if you would rather trade overhead\nfor aspects such as more control over which threads run when and lower costs\nof context switching, for example.\n\nNow that we've defined threads in Rust, let\u2019s explore how to use the\nthread-related API provided by the standard library.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 16.3,
                        "section_name": "Geating a New Thread with spawn",
                        "section_path": "./screenshots-images-2/chapter_16/section_3",
                        "images": [
                            "./screenshots-images-2/chapter_16/section_3/8dcaabce-90a5-4294-a51f-9d4a47865182.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nGeating a New Thread with spawn\n\nTo create a new thread, we call the thread: : spawn function and pass it a clo-\nsure (we talked about closures in Chapter 13) containing the code we want\nto run in the new thread. The example in Listing 16-1 prints some text\nfrom a main thread and other text from a new thread.\n\nuse std:: thread;\nuse std::time::Duration;\n\nfn main() {\nthread: :spawn(|| {\nfor i in 1..10 {\nprintln!(\"hi number {} from the spawned thread!\", i);\nthread: :sleep(Duration: :from_millis(1));\n}\n})3\n\nfor i in1..5 {\nprintln!(\"hi number {} from the main thread!\", i);\nthread: :sleep(Duration: :from_millis(1));\n\n}\n\nListing 16-1: Creating a new thread to print one thing while the main thread prints some-\nthing else\n\nNote that with this function, the new thread will be stopped when the\nmain thread ends, whether or not it has finished running. The output from\nthis program might be a little different every time, but it will look similar to\nthe following:\n\nhi number 1 from the main thread!\nhi number 1 from the spawned thread!\nhi number 2 from the main thread!\nhi number 2 from the spawned thread!\nhi number 3 from the main thread!\nhi number 3 from the spawned thread!\nhi number 4 from the main thread!\nhi number 4 from the spawned thread!\nhi number 5 from the spawned thread!\n\nThe calls to thread: :sleep force a thread to stop its execution for a short\nduration, allowing a different thread to run. The threads will probably take\nturns, but that isn\u2019t guaranteed: it depends on how your operating system\nschedules the threads. In this run, the main thread printed first, even\nthough the print statement from the spawned thread appears first in the\ncode. And even though we told the spawned thread to print until i is 9, it\nonly got to 5 before the main thread shut down.\n\nIf you run this code and only see output from the main thread, or don\u2019t\nsee any overlap, try increasing the numbers in the ranges to create more\nopportunities for the operating system to switch between the threads.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 16.4,
                        "section_name": "Waiting for All Threads to Finish Using join Handles",
                        "section_path": "./screenshots-images-2/chapter_16/section_4",
                        "images": [
                            "./screenshots-images-2/chapter_16/section_4/d5e5e83a-4e21-4ad1-ae90-befabf5b833d.png",
                            "./screenshots-images-2/chapter_16/section_4/e6f0389f-5a1b-4e67-a8dc-09430a1230c5.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nWaiting for All Threads to Finish Using join Handles\n\nThe code in Listing 16-1 not only stops the spawned thread prematurely\nmost of the time due to the main thread ending, but also can\u2019t guarantee\nthat the spawned thread will get to run at all. The reason is that there is no\nguarantee on the order in which threads run!\n\nWe can fix the problem of the spawned thread not getting to run, or not\ngetting to run completely, by saving the return value of thread: : spawn in a vari-\nable. The return type of thread: :spawn is JoinHandle. A JoinHandle is an owned\nvalue that, when we call the join method on it, will wait for its thread to fin-\nish. Listing 16-2 shows how to use the JoinHandle of the thread we created in\nListing 16-1 and call join to make sure the spawned thread finishes before\nmain exits.\n\nuse std:: thread;\nise std:: time: :Duratior\n\nlet handle = thread::spawn(|| {\n\nni(\"hi number {} from the spawned thread!\", i);\n\nfrom_millis(1))\n\nhandle. join().unwrap();\n\nListing 16-2: Saving a JoinHandle from thread: :spawn to guarantee the thread is run to\ncompletion\n\nCalling join on the handle blocks the thread currently running until\nthe thread represented by the handle terminates. Blocking a thread means\nthat thread is prevented from performing work or exiting. Because we've\nput the call to join after the main thread\u2019s for loop, running Listing 16-2\nshould produce output similar to this:\n\nhi number 1 from the main thread!\nhi number 2 from the main thread!\nhi number 1 from the spawned thread!\nhi number 3 from the main thread!\nhi number 2 from the spawned thread!\nhi number 4 from the main thread!\nhi number 3 from the spawned thread!\nhi number 4 from the spawned thread!\nhi number 5 from the spawned thread!\n\nsrc/main.rs\n\nhi number 6 from the spawned thread!\nhi number 7 from the spawned thread!\nhi number 8 from the spawned thread!\nhi number 9 from the spawned thread!\n\nThe two threads continue alternating, but the main thread waits\nbecause of the call to handle. join() and does not end until the spawned\nthread is finished.\n\nBut let\u2019s see what happens when we instead move handle. join() before\nthe for loop in main, like this:\n\nuse std:: thread;\n\nuse std::time::Duration;\n\nfn main() {\nlet handle = thread::spawn(|| {\nfor i in 1..10 {\nprintln\n\nhi number {}\n\nfrom the spawned thread!\", i);\nsleep(Duration: :from_millis(1));\n\nhandle. join() .unwrap();\n\nfor i in 1..5 {\nprintln!(\"hi number {} from the main thread!\", i)\n\nthread: :sleep(Duration: :from_millis(1));\n\nThe main thread will wait for the spawned thread to finish and then\nrun its for loop, so the output won't be interleaved anymore, as shown here:\n\nhi number 1 from the spawned thread!\nhi number 2 from the spawned thread!\nhi number 3 from the spawned thread!\nhi number 4 from the spawned thread!\nhi number 5 from the spawned thread!\nhi number 6 from the spawned thread!\nhi number 7 from the spawned thread!\nhi number 8 from the spawned thread!\nhi number 9 from the spawned thread!\nhi number 1 from the main thread!\nhi number 2 from the main thread!\nhi number 3 from the main thread!\nhi number 4 from the main thread!\n\nSmall details, such as where join is called, can affect whether or not\nyour threads run at the same time.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 16.5,
                        "section_name": "Using move Closures with Threads",
                        "section_path": "./screenshots-images-2/chapter_16/section_5",
                        "images": [
                            "./screenshots-images-2/chapter_16/section_5/753ad125-9bc7-4240-9d62-abcb6ce78e8e.png",
                            "./screenshots-images-2/chapter_16/section_5/c3d198ab-4258-4ca0-8f32-f29aa92d04a9.png",
                            "./screenshots-images-2/chapter_16/section_5/0f564ea8-fc20-4e09-a411-619dc34fb5ef.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nUsing move Closures with Threads\n\nThe move closure is often used alongside thread: : spawn because it allows you\nto use data from one thread in another thread.\n\nIn Chapter 13, we mentioned we can use the move keyword before the\nparameter list of a closure to force the closure to take ownership of the\nvalues it uses in the environment. This technique is especially useful when\ncreating new threads in order to transfer ownership of values from one\nthread to another.\n\nNotice in Listing 16-1 that the closure we pass to thread: :spawn takes no\narguments: we're not using any data from the main thread in the spawned\nthread\u2019s code. To use data from the main thread in the spawned thread,\nthe spawned thread\u2019s closure must capture the values it needs. Listing 16-3\nshows an attempt to create a vector in the main thread and use it in the\nspawned thread. However, this won't yet work, as you'll see in a moment.\n\nuse std:: thread;\n\nfn main() {\nlet v = vec![1, 2, 3];\n\nlet handle = thread::spawn(|| {\nprintln!(\"Here's a vector: {:?}\", v);\n\nns\n\nhandle. join().unwrap();\n}\n\nListing 16-3: Attempting to use a vector created by the main thread in another thread\n\nThe closure uses v, so it will capture v and make it part of the closure\u2019s\nenvironment. Because thread: : spawn runs this closure in a new thread, we\nshould be able to access v inside that new thread. But when we compile this\nexample, we get the following error:\n\nerror[E\u00a30373]: closure may outlive the current function, but it borrows \u201cv\u2019,\nwhich is owned by the current function\n--> src/main.rs:6:32\n\n|\n6 | let handle = thread::spawn(|| {\n| ** may outlive borrowed value ~v\u201d\n7| println!(\"Here's a vector: {:?}\", v);\n| - \u2018v\u2019 is borrowed here\n|\n\nhelp: to force the closure to take ownership of \u201cv\u2019 (and any other referenced\nvariables), use the \u201cmove\u201d keyword\n\n|\nlet handle = thread::spawn(move || {\n\n| AARAAAA\n\n6\n\nsrc/main.rs\n\nsrc/main.rs\n\nRust infers how to capture v, and because println! only needs a reference\nto v, the closure tries to borrow v. However, there\u2019s a problem: Rust can\u2019t tell\nhow long the spawned thread will run, so it doesn\u2019t know whether the refer-\nence to v will always be valid.\n\nListing 16-4 provides a scenario that\u2019s more likely to have a reference to\nv that won't be valid.\n\ndrop(v); // oh no!\n\nhandle. join().unwrap();\n\n}\n\nListing 16-4: A thread with a closure that attempts to capture a reference to v from a main\nthread that drops v\n\nIf we were allowed to run this code, there's a possibility the spawned\nthread would be immediately put in the background without running at all.\nThe spawned thread has a reference to v inside, but the main thread imme-\ndiately drops v, using the drop function we discussed in Chapter 15. Then,\nwhen the spawned thread starts to execute, v is no longer valid, so a refer-\nence to it is also invalid. Oh no!\n\nTo fix the compiler error in Listing 16-3, we can use the error message\u2019s\nadvice:\n\nhelp: to force the closure to take ownership of \u201cv\u2019 (and any other referenced\nvariables), use the \u201cmove\u201d keyword\n\n|\n6 | let handle = thread::spawn(move || {\n\n| ARARAAN\n\nBy adding the move keyword before the closure, we force the closure to\ntake ownership of the values it\u2019s using rather than allowing Rust to infer\nthat it should borrow the values. The modification to Listing 16-3 shown in\nListing 16-5 will compile and run as we intend.\n\nuse std:: thread;\n\nfn main() {\n\nlet handle = thread::spawn(move || {\nprintlr ?}\"\n\ns a vector: {:?7}\", v)\n\nhandle. join() .unwrap();\n\nListing 16-5: Using the move keyword to force a closure to take ownership of the values\nit uses\n\nWhat would happen to the code in Listing 16-4 where the main thread\ncalled drop if we used a move closure? Would move fix that case? Unfortunately,\nno; we would get a different error because what Listing 16-4 is trying to do\nisn\u2019t allowed for a different reason. If we added move to the closure, we would\nmove v into the closure\u2019s environment, and we could no longer call drop on it\nin the main thread. We would get this compiler error instead:\n\nerror[E0382]: use of moved value: \u201cv\u201d\n--> src/main.rs:10:10\n|\n6 | let handle = thread::spawn(move || {\nfe value moved (into closure) here\n\n10 drop(v); // oh no!\n\n|\n| * value used here after move\n|\n\nnote: move occurs because \u201cv\u201d has type ~std::vec::Vec<i32>\", which does\nnot implement the \u201cCopy\u201d trait\n\nRust\u2019s ownership rules have saved us again! We got an error from the\ncode in Listing 16-3 because Rust was being conservative and only borrow-\ning v for the thread, which meant the main thread could theoretically inval-\nidate the spawned thread's reference. By telling Rust to move ownership\nof v to the spawned thread, we're guaranteeing Rust that the main thread\nwon't use v anymore. If we change Listing 16-4 in the same way, we're then\nviolating the ownership rules when we try to use v in the main thread. The\nmove keyword overrides Rust's conservative default of borrowing; it doesn\u2019t\nlet us violate the ownership rules.\n\nWith a basic understanding of threads and the thread API, let's look at\nwhat we can do with threads.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 16.6,
                        "section_name": "Using Message Passing to Transfer Data Between Threads",
                        "section_path": "./screenshots-images-2/chapter_16/section_6",
                        "images": [
                            "./screenshots-images-2/chapter_16/section_6/97bf313f-1acf-4bd7-be36-10b0e2ef3f7b.png",
                            "./screenshots-images-2/chapter_16/section_6/f0c91f12-1213-4d00-bafd-c6da53573d0c.png",
                            "./screenshots-images-2/chapter_16/section_6/017c4784-f7cf-481f-9f8f-ffabed428d1c.png",
                            "./screenshots-images-2/chapter_16/section_6/9d998d5c-e081-44ea-ba13-eec0d89089da.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Using Message Passing to Transfer Data Between Threads\n\nOne increasingly popular approach to ensuring safe concurrency is message\npassing, where threads or actors communicate by sending each other messages\ncontaining data. Here's the idea in a slogan from the Go language docu-\nmentation (http://golang.org/doc/effective_go.html): \u201cDo not communicate by\nsharing memory; instead, share memory by communicating.\u201d\n\nOne major tool Rust has for accomplishing message-sending concurrency\nis the channel, a programming concept that Rust\u2019s standard library provides\nan implementation of. You can imagine a channel in programming as being\n\nstc/main.rs\n\nlike a channel of water, such as a stream or river. If you put something like\na rubber duck or boat into a stream, it will travel downstream to the end of\nthe waterway.\n\nA channel in programming has two halves: a transmitter and a receiver.\nThe transmitter half is the upstream location where you put rubber ducks\ninto the river, and the receiver half is where the rubber duck ends up\ndownstream. One part of your code calls methods on the transmitter with\nthe data you want to send, and another part checks the receiving end for\narriving messages. A channel is said to be closed if either the transmitter or\nreceiver half is dropped.\n\nHere, we'll work up to a program that has one thread to generate values\nand send them down a channel, and another thread that will receive the\nvalues and print them. We\u2019ll be sending simple values between threads\nusing a channel to illustrate the feature. Once you're familiar with the tech-\nnique, you could use channels to implement a chat system or a system where\nmany threads perform parts of a calculation and send the parts to one thread\nthat aggregates the results.\n\nFirst, in Listing 16-6, we'll create a channel but not do anything with it.\nNote that this won\u2019t compile yet because Rust can\u2019t tell what type of values\nwe want to send over the channel.\n\nuse std::sync::mpsc;\n\nfn main() {\nlet (tx, rx) = mpsc::channel();\n}\n\nListing 16-6: Creating a channel and assigning the two halves to tx and rx\n\nWe create a new channel using the mpsc: : channel function; mpsc stands\nfor multiple producer, single consumer. In short, the way Rust\u2019s standard library\nimplements channels means a channel can have multiple sending ends\nthat produce values but only one receiving end that consumes those values.\nImagine multiple streams flowing together into one big river: everything sent\ndown any of the streams will end up in one river at the end. We'll start with\na single producer for now, but we'll add multiple producers when we get this\nexample working.\n\nThe mpsc: :channel function returns a tuple, the first element of which\nis the sending end and the second element the receiving end. The abbrevia-\ntions tx and rx are traditionally used in many fields for transmitter and receiver,\nrespectively, so we name our variables as such to indicate each end. We're\nusing a let statement with a pattern that destructures the tuples; we'll discuss\nthe use of patterns in let statements and destructuring in Chapter 18. Using\na let statement this way is a convenient approach to extract the pieces of the\ntuple returned by mpsc: : channel.\n\nLet\u2019s move the transmitting end into a spawned thread and have it send\none string so the spawned thread is communicating with the main thread, as\nshown in Listing 16-7. This is like putting a rubber duck in the river upstream\nor sending a chat message from one thread to another.\n\nsrc/main.rs\n\nsrc/main.rs\n\nuse std:: thread;\n\nise\n\nlet (tx, rx) = mpsc::channel();\n\nthread::spawn(move || {\nlet val = String: :from(\"hi\");\ntx.send(val).unwrap() ;\n\nns\n\nListing 16-7: Moving tx to a spawned thread and sending \"hi\"\n\nAgain, we're using thread: :spawn to create a new thread and then using\nmove to move tx into the closure so the spawned thread owns tx. The spawned\nthread needs to own the transmitting end of the channel to be able to send\nmessages through the channel.\n\nThe transmitting end has a send method that takes the value we want to\nsend. The send method returns a Result<T, E> type, so if the receiving end has\nalready been dropped and there\u2019s nowhere to send a value, the send opera-\ntion will return an error. In this example, we're calling unwrap to panic in case\nof an error. But in a real application, we would handle it properly: return to\nChapter 9 to review strategies for proper error handling.\n\nIn Listing 16-8, we'll get the value from the receiving end of the channel\nin the main thread. This is like retrieving the rubber duck from the water at\nthe end of the river or like getting a chat message.\n\nfn main()\nlet (tx, rx) = mpsc::channel()\n\nthread: : spawn (move\nlet = String: :fz\ntx. i(val).unwrap();\n\nb)5\n\nlet received = rx.recv().unwrap();\nprintln!(\"Got: {}\", received);\n\nListing 16-8: Receiving the value \"hi\" in the main thread and printing it\n\nThe receiving end of a channel has two useful methods: recv and try_recv.\nWe're using recv, short for receive, which will block the main thread\u2019s execu-\ntion and wait until a value is sent down the channel. Once a value is sent,\nrecv will return it in a Result<T, E>. When the sending end of the channel\ncloses, recv will return an error to signal that no more values will be coming.\n\nThe try_recv method doesn\u2019t block, but will instead return a Result<T, E>\nimmediately: an 0k value holding a message if one is available and an Err\n\nvalue if there aren\u2019t any messages this time. Using try_recv is useful if this\nthread has other work to do while waiting for messages: we could write a\nloop that calls try_recv every so often, handles a message if one is available,\nand otherwise does other work for a little while until checking again.\n\nWe've used recv in this example for simplicity; we don\u2019t have any other\nwork for the main thread to do other than wait for messages, so blocking\nthe main thread is appropriate.\n\nWhen we run the code in Listing 16-8, we'll see the value printed from\nthe main thread:\n\nGot: hi\n\nPerfect!\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 16.7,
                        "section_name": "Channels and Ownership Transference",
                        "section_path": "./screenshots-images-2/chapter_16/section_7",
                        "images": [
                            "./screenshots-images-2/chapter_16/section_7/b9cbf521-eddc-45ec-96b4-2c8e0c249b56.png",
                            "./screenshots-images-2/chapter_16/section_7/fc94de4c-6724-4312-8276-bb0b7cfec13d.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nChannels and Ownership Transference\n\nThe ownership rules play a vital role in message sending because they\nhelp you write safe, concurrent code. Preventing errors in concurrent pro-\ngramming is the advantage of thinking about ownership throughout your\nRust programs. Let's do an experiment to show how channels and owner-\nship work together to prevent problems: we'll try to use a val value in the\nspawned thread after we've sent it down the channel. Try compiling the\ncode in Listing 16-9 to see why this code isn\u2019t allowed.\n\nuse std:: thread;\n\nString: :from(\"hi\");\nal).unwrap()\n\n\"val is {} , val);\n\nListing 16-9: Attempting to use val after we've sent it down the channel\n\nHere, we try to print val after we've sent it down the channel via tx. send.\nAllowing this would be a bad idea: once the value has been sent to another\nthread, that thread could modify or drop it before we try to use the value\nagain. Potentially, the other thread\u2019s modifications could cause errors or\nunexpected results due to inconsistent or nonexistent data. However, Rust\ngives us an error if we try to compile the code in Listing 16-9.\n\nerror[E0382]: use of moved value: \u201cval\n--> src/main.rs:10:31\n\n9 tx.send(val) .unwrap();\n\n|\n|\n| --- value moved here\n10 | println!(\"val is {}\", val);\n| *** value used here after move\n|\n\nnote: move occurs because \u201cval~ has type ~std::string::String\u2019, which\ndoes not implement the \u201cCopy\u201d trait\n\nOur concurrency mistake has caused a compile-time error. The send\nfunction takes ownership of its parameter, and when the value is moved,\nthe receiver takes ownership of it. This stops us from accidentally using the\nvalue again after sending it; the ownership system checks that everything\nis okay.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 16.8,
                        "section_name": "Sending Multiple Values and Seeing the Receiver Waiting",
                        "section_path": "./screenshots-images-2/chapter_16/section_8",
                        "images": [
                            "./screenshots-images-2/chapter_16/section_8/2b989f43-be00-4e79-9143-c99428baef3d.png",
                            "./screenshots-images-2/chapter_16/section_8/f4857aec-f7db-4b96-9f41-59b026a8c798.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nSending Multiple Values and Seeing the Receiver Waiting\n\nThe code in Listing 16-8 compiled and ran, but it didn\u2019t clearly show us\nthat two separate threads were talking to each other over the channel.\n\nIn Listing 16-10, we've made some modifications that will prove the code in\nListing 16-8 is running concurrently: the spawned thread will now send mul-\ntiple messages and pause for a second between each message.\n\nise std:: thread;\nuse sta yr NPSC ;\nuse std::time::Duration;\n\nlet (tx, rx) mpsc: :channel()\n\nthread: : spawn(move\nlet vals = vec![\nString: :from(\"hi\"),\nString: :from(\"from\"),\nString: :from(\"the\"),\nString: :from(\"thread\"),\n13\n\nfor val in vals {\ntx.send(val).unwrap();\nthread: :sleep(Duration: :from_secs(1));\n\n}\n\n})\n\nfor received in rx {\nprintln!(\"Got: {}\", received);\n}\n\nListing 16-10: Sending multiple messages and pausing between each\n\nThis time, the spawned thread has a vector of strings that we want to\nsend to the main thread. We iterate over them, sending each individually,\nand pause between each by calling the thread: :sleep function with a Duration\nvalue of 1 second.\n\nIn the main thread, we're not calling the recv function explicitly any-\nmore: instead, we're treating rx as an iterator. For each value received,\nwe're printing it. When the channel is closed, iteration will end.\n\nWhen running the code in Listing 16-10, you should see the following\noutput with a 1-second pause between each line:\n\nGot: hi\nGot: from\nGot: the\nGot: thread\n\nBecause we don\u2019t have any code that pauses or delays in the for loop in\nthe main thread, we can tell that the main thread is waiting to receive values\nfrom the spawned thread.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 16.9,
                        "section_name": "Geating Multiple Producers by Coning the Transmitter",
                        "section_path": "./screenshots-images-2/chapter_16/section_9",
                        "images": [
                            "./screenshots-images-2/chapter_16/section_9/6b54b009-14b6-43a1-b165-8a450547b078.png",
                            "./screenshots-images-2/chapter_16/section_9/552cfc4f-193f-46a8-abed-8940471f4379.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nGeating Multiple Producers by Coning the Transmitter\n\nEarlier we mentioned that mpsc was an acronym for multiple producer, single\nconsumer. Let\u2019s put mpsc to use and expand the code in Listing 16-10 to create\nmultiple threads that all send values to the same receiver. We can do so by\ncloning the transmitting half of the channel, as shown in Listing 16-11.\n\nlet (tx, rx) mpsc::channel();\n\nlet tx1 = mpsc::Sender::clone(&tx);\nthreac Dawn (move {\n\ntx1.send(val) .unwrap();\nthread: :sleep(Duratio from_secs(1));\n\nthread: :spawn(move || {\nlet vals = vec![\nString: :from(\"more\"),\nString: :from(\"messages\"),\nString: :from(\"for\"),\nString: :from(\"you\"),\n13\n\nfor val in vals {\ntx. send(val).unwrap() ;\nthread: :sleep(Duration: : from_secs(1));\n\nListing 16-11: Sending multiple messages from multiple producers\n\nThis time, before we create the first spawned thread, we call clone on\nthe sending end of the channel. This will give us a new sending handle we\ncan pass to the first spawned thread. We pass the original sending end of\nthe channel to a second spawned thread. This gives us two threads, each\nsending different messages to the receiving end of the channel.\n\nWhen you run the code, your output should look something like this:\n\nGot: hi\n\nGot: more\nGot: from\nGot: messages\nGot: for\nGot: the\nGot: thread\nGot: you\n\nYou might see the values in another order; it depends on your system.\nThis is what makes concurrency interesting as well as difficult. If you experi-\nment with thread: :sleep, giving it various values in the different threads, each\nrun will be more nondeterministic and create different output each time.\n\nNow that we\u2019ve looked at how channels work, let\u2019s look at a different\nmethod of concurrency.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 16.1,
                        "section_name": "Shared-State Concurrency",
                        "section_path": "./screenshots-images-2/chapter_16/section_10",
                        "images": [
                            "./screenshots-images-2/chapter_16/section_10/1e7759dd-fe75-453c-b996-7db3481a6107.png",
                            "./screenshots-images-2/chapter_16/section_10/3b14c74a-e22b-4e99-aec6-71226d67e860.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Shared-State Concurrency\n\nMessage passing is a fine way of handling concurrency, but it\u2019s not the only\none. Consider this part of the slogan from the Go language documentation\nagain: \u201ccommunicate by sharing memory.\u201d\n\nWhat would communicating by sharing memory look like? In addition,\nwhy would message-passing enthusiasts not use it and do the opposite instead?\n\nIn a way, channels in any programming language are similar to single\nownership, because once you transfer a value down a channel, you should\nno longer use that value. Shared memory concurrency is like multiple\nownership: multiple threads can access the same memory location at the\nsame time. As you saw in Chapter 15, where smart pointers made multiple\nownership possible, multiple ownership can add complexity because these\n\ndifferent owners need managing. Rust\u2019s type system and ownership rules\ngreatly assist in getting this management correct. For an example, let\u2019s look\nat mutexes, one of the more common concurrency primitives for shared\nmemory.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 16.11,
                        "section_name": "Using Mutexes to Allow Access to Data from One Thread at a Time",
                        "section_path": "./screenshots-images-2/chapter_16/section_11",
                        "images": [
                            "./screenshots-images-2/chapter_16/section_11/603f3fea-f316-4479-a0ba-c6ed66ef5c9a.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Using Mutexes to Allow Access to Data from One Thread at a Time\n\nMutex is an abbreviation for mutual exclusion, as in, a mutex allows only one\nthread to access some data at any given time. To access the data in a mutex,\na thread must first signal that it wants access by asking to acquire the mutex\u2019s\nlock. The lock is a data structure that is part of the mutex that keeps track\nof who currently has exclusive access to the data. Therefore, the mutex is\ndescribed as guarding the data it holds via the locking system.\n\nMutexes have a reputation for being difficult to use because you have to\nremember two rules:\n\ne You must attempt to acquire the lock before using the data.\n\ne When you're done with the data that the mutex guards, you must\nunlock the data so other threads can acquire the lock.\n\nFor a real-world metaphor for a mutex, imagine a panel discussion at\na conference with only one microphone. Before a panelist can speak, they\nhave to ask or signal that they want to use the microphone. When they get\nthe microphone, they can talk for as long as they want and then hand the\nmicrophone to the next panelist who requests to speak. If a panelist forgets\nto hand the microphone off when they're finished with it, no one else is\nable to speak. If management of the shared microphone goes wrong, the\npanel won't work as planned!\n\nManagement of mutexes can be incredibly tricky to get right, which is why\nso many people are enthusiastic about channels. However, thanks to Rust\u2019's\ntype system and ownership rules, you can\u2019t get locking and unlocking wrong.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 16.12,
                        "section_name": "The API of Mutex<T>",
                        "section_path": "./screenshots-images-2/chapter_16/section_12",
                        "images": [
                            "./screenshots-images-2/chapter_16/section_12/aee93c60-7559-4645-bc76-257a64e39b3f.png",
                            "./screenshots-images-2/chapter_16/section_12/d5b5f4a3-51df-4776-8178-3d00665c0ab1.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nThe API of Mutex<T>\n\nAs an example of how to use a mutex, let's start by using a mutex in a single-\nthreaded context, as shown in Listing 16-12.\n\nuse std::sync::Mutex;\n\nfn main() {\n@ let m = Mutex::new(S);\n{\n\u00a9 let mut num = m.lock().unwrap();\n\u00a9 *num = 6;\n0}\n\n\u00a9 println!(\"m = {:2?}\", m);\n}\n\nListing 16-12: Exploring the AP! of Mutex<T> in a single-threaded context for simplicity\n\nAs with many types, we create a Mutex<T> using the associated func-\ntion new @. To access the data inside the mutex, we use the lock method to\nacquire the lock \u00ae. This call will block the current thread so it can\u2019t do any\nwork until it\u2019s our turn to have the lock.\n\nThe call to lock would fail if another thread holding the lock panicked.\nIn that case, no one would ever be able to get the lock, so we've chosen to\nuse unwrap and have this thread panic if we're in that situation.\n\nAfter we've acquired the lock, we can treat the return value, named num\nin this case, as a mutable reference to the data inside \u00a9. The type system\nensures that we acquire a lock before using the value in m: Mutex<i32> is not\nan i32, so we must acquire the lock to be able to use the i32 value. We can\u2019t\nforget; the type system won't let us access the inner i32 otherwise.\n\nAs you might suspect, Mutex<T> is a smart pointer. More accurately, the\ncall to lock returns a smart pointer called MutexGuard. This smart pointer\nimplements Deref to point at our inner data; the smart pointer also has a\nDrop implementation that releases the lock automatically when a MutexGuard\ngoes out of scope, which happens at the end of the inner scope \u00ae. As\na result, we don\u2019t risk forgetting to release the lock and blocking the\nmutex from being used by other threads because the lock release happens\nautomatically.\n\nAfter dropping the lock, we can print the mutex value and see that we\nwere able to change the inner i32 to 6 @.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 16.13,
                        "section_name": "Sharing a Mutex<T> Between Multiple Threads",
                        "section_path": "./screenshots-images-2/chapter_16/section_13",
                        "images": [
                            "./screenshots-images-2/chapter_16/section_13/9f0a4cf6-b414-49c0-a56f-7e8368175aa4.png",
                            "./screenshots-images-2/chapter_16/section_13/5411112b-9e56-4798-9a3d-fce066951709.png",
                            "./screenshots-images-2/chapter_16/section_13/8eec7593-c8ab-44ab-806c-983f2d5d03ea.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Sharing a Mutex<T> Between Multiple Threads\n\nNow, let's try to share a value between multiple threads using Mutex<T>. We'll\nspin up 10 threads and have them each increment a counter value by 1, so the\ncounter goes from 0 to 10. Note that the next few examples will have compiler\nerrors, and we'll use those errors to learn more about Mutex<T> and how Rust\nhelps us implement it correctly. Listing 16-13 has our starting example.\n\nsrc/main.rs use std::sync: :Mutex;\nuse std:: thread;\n\nfn main() {\n@ let counter = Mutex::new(0);\nlet mut handles = vec![];\n\n@ for _ in 0..10 {\n\u00a9 let handle = thread::spawn(move || {\n@ let mut num = counter. lock().unwrap();\n\n\u00a9 *num += 1;\n\n})3\n@\u00ae handles. push(handle) ;\n}\n\nfor handle in handles {\n@ handle. join().unwrap() ;\n\n}\n\n\u00ae println!(\"Result: {}\", *counter.lock().unwrap());\n\nListing 16-13: Ten threads each increment a counter guarded by a Mutex<T>\n\nWe create a counter variable to hold an i32 inside a Mutex<T> @, as we\ndid in Listing 16-12. Next, we create 10 threads by iterating over a range\nof numbers \u00a9. We use thread: : spawn and give all the threads the same clo-\nsure, one that moves the counter into the thread \u00ae, acquires a lock on the\nMutex<T> by calling the lock method 9, and then adds | to the value in the\nmutex \u00a9. When a thread finishes running its closure, num will go out of\nscope and release the lock so another thread can acquire it.\n\nIn the main thread, we collect all the join handles \u00a9. Then, as we did\nin Listing 16-2, we call join on each handle to make sure all the threads\nfinish @. At that point, the main thread will acquire the lock and print\nthe result of this program \u00a9.\n\nWe hinted that this example wouldn't compile. Now let\u2019s find out why!\n\nerror[\u00a30382]: capture of moved value: ~counter~\n--> src/main.rs:10:27\n|\n9 | let handle = thread::spawn(move || {\nfe value moved (into closure) here\n10 | let mut num = counter. lock().unwrap();\n| aaannew value captured here after move\n|\n= note: move occurs because \u201ccounter\u201d has type ~std::sync: :Mutex<i32>\u00b0,\nwhich does not implement the \u201cCopy\u201d trait\n\nerror[\u00a30382]: use of moved value: \u201ccounter\n--> src/main.rs:21:29\n|\n\n9 | let handle = thread::spawn(move || {\nfe value moved (into closure) here\n\n21 println!(\"Result: {}\", *counter.lock().unwrap());\n\n|\n| AAAAASN Value used here after move\n|\n\nnote: move occurs because \u201ccounter\u201d has type ~std::sync::Mutex<i32>\u00b0,\nwhich does not implement the \u201cCopy\u201d trait\n\nerror: aborting due to 2 previous errors\n\nThe error message states that the counter value is moved into the closure\nand then captured when we call lock. That description sounds like what we\nwanted, but it\u2019s not allowed!\n\nLet\u2019s figure this out by simplifying the program. Instead of making\n10 threads in a for loop, let\u2019s just make 2 threads without a loop and see what\nhappens. Replace the first for loop in Listing 16-13 with the following code\ninstead.\n\nlet handle = thread::spawn(move || {\nlet mut num = counter.lock().unwrap();\n\n*num += 1;\n})3\nhandles .push(handle);\n\nlet handle2 = thread: :spawn(move || {\nlet mut num2 = counter. lock().unwrap();\n\n*num2 += 1;\n\n})3\nhandles -push(handle2) ;\n\nWe make two threads and change the variable names used with the\nsecond thread to handle2 and num2. When we run the code this time, com-\npiling gives us the following:\n\nerror[E\u00a30382]: capture of moved value: ~counter\u2122\n--> src/main.rs:16:24\n\n|\n8 | let handle = thread: :spawn(move || {\n\nPo eee value moved (into closure) here\n\n16 let mut num2 = counter. lock().unwrap();\n\n|\n| AAAA44* value captured here after move\n|\n\nnote: move occurs because \u201ccounter\u201d has type ~std::sync: :Mutex<i32>\u00b0,\nwhich does not implement the \u201cCopy\u201d trait\n\nerror[E0382]: use of moved value: \u201ccounter\n--> src/main.rs:26:29\n\n|\n8 | let handle = thread::spawn(move || {\n\nPo nee value moved (into closure) here\n\n26 | println!(\"Result: {}\", *counter.lock().unwrap());\n| anaanan value used here after move\n|\n\nnote: move occurs because \u201ccounter\u201d has type ~std::sync: :Mutex<i32>\u00b0,\nwhich does not implement the \u201cCopy\u201d trait\n\nerror: aborting due to 2 previous errors\n\nAha! The first error message indicates that counter is moved into the\nclosure for the thread associated with handle. That move is preventing us\nfrom capturing counter when we try to call lock on it and store the result in\nnum2 in the second thread! So Rust is telling us that we can\u2019t move ownership\nof counter into multiple threads. This was hard to see earlier because our\nthreads were in a loop, and Rust can\u2019t point to different threads in different\niterations of the loop. Let's fix the compiler error with a multiple-ownership\nmethod.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 16.14,
                        "section_name": "Multiple Ownership with Multiple Threads",
                        "section_path": "./screenshots-images-2/chapter_16/section_14",
                        "images": [
                            "./screenshots-images-2/chapter_16/section_14/b7500fd5-5553-4094-bf53-da647f194f9d.png",
                            "./screenshots-images-2/chapter_16/section_14/2e5acaee-80b4-4788-8151-083fe5040c97.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "stc/main.rs\n\nMultiple Ownership with Multiple Threads\n\nIn Chapter 15, we gave a value multiple owners by using the smart pointer\nRc<T> to create a reference counted value. Let\u2019s do the same here and see\nwhat happens. We'll wrap the Mutex<T> in Rc<T> in Listing 16-14 and clone\nthe Rc<T> before moving ownership to the thread. Now that we've seen the\nerrors, we'll also switch back to using the for loop, and we\u2019ll keep the move\nkeyword with the closure.\n\nmain() {\nlet counter = Rc: :new(Mutex::new(0));\nlet mut handles = vec $\nfor _ in 0..10 {\nlet counter = Rc: :clone(&counter) ;\nlet handle = thread\n\nlet mut num = counter. lock().unwrap()\n\nawn (move {\n\nfor handle in handles\n\nhandle. join() .unwrap();\nprintln!(\"Result: {}\", *counter.lock().unwrap());\n\nListing 16-14: Attempting to use Rc<T> to allow multiple threads to own the Mutex<T>\n\nOnce again, we compile and get . . . different errors! The compiler is\nteaching us a lot.\n\nerror[E0277]: the trait bound ~std::rc::Rc<std::sync: :Mutex<i32>>:\nstd::marker::Send> is not satisfied in ~[closure@src/main.rs:11:36: 15:10\ncounter: std::rc::Re<std: : sync: :Mutex<i32>>]~\n\n--> src/main.rs:11:22\n\n|\n\n11 | let handle = thread::spawn(move || {\ne| AARAABAHAABAN ~ stdzzxc: :Re<std: :sync: :Mutex<i32>>\u00b0\ncannot be sent between threads safely\n\n= help: within ~[closure@src/main.rs:11:36: 15:10 counter:std::rc::Rc<std::\nsync: :Mutex<i32>>]\u00b0, the trait \u201cstd::marker::Send\u2019 is not implemented for \u201cstd\nrire: :Re<std::syne: :Mutex<i32>>\u00b0\n\n= note: required because it appears within the type ~[closure@src/main.\n\u00a5$:11:36: 15:10 counter:std::rc::Rc<std:: sync: :Mutex<i32>>]~\n\n= note: required by ~std::thread::spawn\u201d\n\nWow, that error message is very wordy! Here are some important parts\nto focus on: the first inline error says ~std::rc::Re<std:: sync: :Mutex<i32>>\u00b0\ncannot be sent between threads safely @. The reason for this is in the next\nimportant part to focus on, the error message. The distilled error message\nsays the trait bound \u201cSend\u201d is not satisfied \u00ae. We'll talk about Send in the\nnext section: it\u2019s one of the traits that ensures the types we use with threads\nare meant for use in concurrent situations.\n\nUnfortunately, Rc<T> is not safe to share across threads. When Rc<T>\nmanages the reference count, it adds to the count for each call to clone and\nsubtracts from the count when each clone is dropped. But it doesn\u2019t use any\nconcurrency primitives to make sure that changes to the count can\u2019t be inter-\nrupted by another thread. This could lead to wrong counts\u2014subtle bugs that\ncould in turn lead to memory leaks or a value being dropped before we're\ndone with it. What we need is a type exactly like Rc<T> but one that makes\nchanges to the reference count in a thread-safe way.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 16.15,
                        "section_name": "Atomic Reference Counting with Arc<T>",
                        "section_path": "./screenshots-images-2/chapter_16/section_15",
                        "images": [
                            "./screenshots-images-2/chapter_16/section_15/a418665b-7e47-45a7-805f-acae1c37e1d9.png",
                            "./screenshots-images-2/chapter_16/section_15/c9129b24-081c-43d8-ba74-00406259dbc1.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nAtomic Reference Counting with Arc<T>\n\nFortunately, Arc<T> isa type like Rc<T> that is safe to use in concurrent situ-\nations. The a stands for atomic, meaning it\u2019s an atomically reference counted\ntype. Atomics are an additional kind of concurrency primitive that we\nwon't cover in detail here: see the standard library documentation for\nstd::sync::atomic for more details. At this point, you just need to know that\natomics work like primitive types but are safe to share across threads.\n\nYou might then wonder why all primitive types aren\u2019t atomic and why\nstandard library types aren\u2019t implemented to use Arc<T> by default. The rea-\nson is that thread safety comes with a performance penalty that you only want\nto pay when you really need to. If you're just performing operations on values\nwithin a single thread, your code can run faster if it doesn\u2019t have to enforce\nthe guarantees atomics provide.\n\nLet's return to our example: Arc<T> and Rc<T> have the same API, so we\nfix our program by changing the use line, the call to new, and the call to\nclone. The code in Listing 16-15 will finally compile and run.\n\nuse std::sync::{Mutex, Arc};\n\nise std:: thread;\n\n+ main( )\nlet counter = Arc::new(Mutex::new(0));\nlet mut handles vec![];\n\nfor in 0..10 {\nlet counter = Arc::clone(&counter) ;\n\nlet handle = thread:\n\n-unwrap();\n\n*num += 1;\n\nfor handle in handles {\n\nhandle. join().unwrap();\n\n\"Result: {}\", *counter.lock().unwrap());\n\nListing 16-15: Using an Arc<T> to wrap the Mutex<T> to be able to share ownership across\nmultiple threads\n\nThis code will print the following:\n\nResult: 10\n\nWe did it! We counted from 0 to 10, which may not seem very impres-\nsive, but it did teach us a lot about Mutex<T> and thread safety. You could also\nuse this program\u2019s structure to do more complicated operations than just\nincrementing a counter. Using this strategy, you can divide a calculation\ninto independent parts, split those parts across threads, and then use a\nMutex<T> to have each thread update the final result with its part.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 16.16,
                        "section_name": "Similarities Between RefCell<T>/Re<T> and Mutex<T>/Arc<T>",
                        "section_path": "./screenshots-images-2/chapter_16/section_16",
                        "images": [
                            "./screenshots-images-2/chapter_16/section_16/a9615614-c636-4419-bcfb-e71ca0e0f55c.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Similarities Between RefCell<T>/Re<T> and Mutex<T>/Arc<T>\n\nYou might have noticed that counter is immutable but we could get a mutable\nreference to the value inside it; this means Mutex<T> provides interior mutabil-\nity, as the Cell family does. In the same way we used RefCell<T> in Chapter 15\nto allow us to mutate contents inside an Rc<T>, we use Mutex<T> to mutate con-\ntents inside an Arc<T>.\n\nAnother detail to note is that Rust can\u2019t protect you from all kinds of\nlogic errors when you use Mutex<T>. Recall in Chapter 15 that using Rc<T>\ncame with the risk of creating reference cycles, where two Rc<T> values refer\nto each other, causing memory leaks. Similarly, Mutex<T> comes with the\nrisk of creating deadlocks. These occur when an operation needs to lock two\nresources and two threads have each acquired one of the locks, causing\nthem to wait for each other forever. If you're interested in deadlocks, try\ncreating a Rust program that has a deadlock; then research deadlock miti-\ngation strategies for mutexes in any language and have a go at implement-\ning them in Rust. The standard library API documentation for Mutex<T> and\nMutexGuard offers useful information.\n\nWe'll round out this chapter by talking about the Send and Sync traits\nand how we can use them with custom types.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 16.17,
                        "section_name": "Extensible Concurrency with the Sync and Send Traits",
                        "section_path": "./screenshots-images-2/chapter_16/section_17",
                        "images": [
                            "./screenshots-images-2/chapter_16/section_17/92be6b22-0a78-4169-95f4-2ac942d3cddc.png",
                            "./screenshots-images-2/chapter_16/section_17/583e3240-368f-463b-aaca-0bd43ec927be.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Extensible Concurrency with the Sync and Send Traits\n\nInterestingly, the Rust language has very few concurrency features. Almost\nevery concurrency feature we've talked about so far in this chapter has been\npart of the standard library, not the language. Your options for handling\nconcurrency are not limited to the language or the standard library; you\ncan write your own concurrency features or use those written by others.\n\nHowever, two concurrency concepts are embedded in the language: the\nstd: :marker traits Sync and Send.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 16.18,
                        "section_name": "Allowing Transference of Ownership Between Threads with Send",
                        "section_path": "./screenshots-images-2/chapter_16/section_18",
                        "images": [
                            "./screenshots-images-2/chapter_16/section_18/8c343fd9-b7d2-4a07-95a7-fa9183743795.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Allowing Transference of Ownership Between Threads with Send\n\nThe Send marker trait indicates that ownership of the type implementing\nSend can be transferred between threads. Almost every Rust type is Send, but\nthere are some exceptions, including Rc<T>: this cannot be Send because if you\ncloned an Rc<T> value and tried to transfer ownership of the clone to another\nthread, both threads might update the reference count at the same time.\nFor this reason, Rc<T> is implemented for use in single-threaded situations\nwhere you don\u2019t want to pay the thread-safe performance penalty.\n\nTherefore, Rust\u2019s type system and trait bounds ensure that you can never\naccidentally send an Rc<T> value across threads unsafely. When we tried to\ndo this in Listing 16-14, we got the error the trait Send is not implemented for\nRc<Mutex<i32>>. When we switched to Arc<T>, which is Send, the code compiled.\n\nAny type composed entirely of Send types is automatically marked as Send\nas well. Almost all primitive types are Send, aside from raw pointers, which\nwe'll discuss in Chapter 19.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 16.19,
                        "section_name": "Allowing Access from Multiple Threads with Sync",
                        "section_path": "./screenshots-images-2/chapter_16/section_19",
                        "images": [
                            "./screenshots-images-2/chapter_16/section_19/f785caae-a6cb-4b7e-9e8f-3b98ddc2a7e8.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Allowing Access from Multiple Threads with Sync\n\nThe Syne marker trait indicates that it is safe for the type implementing Sync\nto be referenced from multiple threads. In other words, any type T is Sync if &T\n(a reference to T) is Send, meaning the reference can be sent safely to another\nthread. Similar to Send, primitive types are Sync, and types composed entirely\nof types that are Sync are also Sync.\n\nThe smart pointer Rc<T> is also not Sync for the same reasons that it\u2019s\nnot Send. The RefCell<T> type (which we talked about in Chapter 15) and\nthe family of related Cell<T> types are not Sync. The implementation of\nborrow checking that RefCell<T> does at runtime is not thread-safe. The\nsmart pointer Mutex<T> is Sync and can be used to share access with multiple\nthreads, as you saw in \u201cSharing a Mutex<T> Between Multiple Threads\u201d on\npage 363.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 16.2,
                        "section_name": "Implementing Send and Sync Manually Is Unsafe",
                        "section_path": "./screenshots-images-2/chapter_16/section_20",
                        "images": [
                            "./screenshots-images-2/chapter_16/section_20/25c3a033-746b-4139-808c-ff614927e1f1.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Implementing Send and Sync Manually Is Unsafe\n\nBecause types that are made up of Send and Sync traits are automatically also\nSend and Sync, we don\u2019t have to implement those traits manually. As marker\ntraits, they don\u2019t even have any methods to implement. They\u2019re just useful\nfor enforcing invariants related to concurrency.\n\nManually implementing these traits involves implementing unsafe Rust\ncode. We'll talk about using unsafe Rust code in Chapter 19; for now, the\nimportant information is that building new concurrent types not made up of\nSend and Sync parts requires careful thought to uphold the safety guarantees.\nThe Rustonomicon at https://doc.rust-lang.org/stable/nomicon/ has more informa-\ntion about these guarantees and how to uphold them.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 16.21,
                        "section_name": "Summary",
                        "section_path": "./screenshots-images-2/chapter_16/section_21",
                        "images": [
                            "./screenshots-images-2/chapter_16/section_21/b6682a68-b262-4aed-bc66-2d8a4e6aef0b.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Summary\n\nThis isn\u2019t the last you'll see of concurrency in this book: the project in\nChapter 20 will use the concepts in this chapter in a more realistic situa-\ntion than the smaller examples discussed here.\n\nAs mentioned earlier, because very little of how Rust handles concur-\nrency is part of the language, many concurrency solutions are implemented\nas crates. These evolve more quickly than the standard library, so be sure to\nsearch online for the current, state-of-the-art crates to use in multithreaded\nsituations.\n\nThe Rust standard library provides channels for message passing and\nsmart pointer types, such as Mutex<T> and Arc<T>, that are safe to use in con-\ncurrent contexts. The type system and the borrow checker ensure that the\ncode using these solutions won't end up with data races or invalid references.\nOnce you get your code to compile, you can rest assured that it will happily\nrun on multiple threads without the kinds of hard-to-track-down bugs com-\nmon in other languages. Concurrent programming is no longer a concept to\nbe afraid of: go forth and make your programs concurrent, fearlessly!\n\nNext, we'll talk about idiomatic ways to model problems and structure\nsolutions as your Rust programs get bigger. In addition, we'll discuss how\nRust\u2019s idioms relate to those you might be familiar with from object-oriented\nprogramming.\n",
                        "extracted-code": ""
                    }
                ]
            },
            {
                "chapter_id": 17,
                "chapter_name": "OBJECT-ORIENTED\nPROGRAMMING FEATURES\nOF RUST",
                "chapter_path": "./screenshots-images-2/chapter_17",
                "sections": [
                    {
                        "section_id": 17.1,
                        "section_name": "OBJECT-ORIENTED\nPROGRAMMING FEATURES\nOF RUST",
                        "section_path": "./screenshots-images-2/chapter_17/section_1",
                        "images": [
                            "./screenshots-images-2/chapter_17/section_1/79fd6f5b-0f40-4333-bb69-61202f4d310a.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "OBJECT-ORIENTED\nPROGRAMMING FEATURES\nOF RUST\n\nObject-oriented programming (OOP) is a\nway of modeling programs. Objects came\nfrom Simula in the 1960s. Those objects\ninfluenced Alan Kay\u2019s programming architec-\nture in which objects pass messages to each other. He\ncoined the term object-oriented programming in 1967 to\n\ndescribe this architecture. Many competing definitions describe what OOP\nis; some definitions would classify Rust as object oriented, but other defi-\nnitions would not. In this chapter, we'll explore certain characteristics\nthat are commonly considered object oriented and how those characteris-\ntics translate to idiomatic Rust. We'll then show you how to implement an\nobject-oriented design pattern in Rust and discuss the trade-offs of doing\nso versus implementing a solution using some of Rust\u2019s strengths instead.\n\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 17.2,
                        "section_name": "Characteristics of Object-Oriented Languages",
                        "section_path": "./screenshots-images-2/chapter_17/section_2",
                        "images": [
                            "./screenshots-images-2/chapter_17/section_2/1a17b5ed-6314-4085-8ffa-20d0a0e9b055.png",
                            "./screenshots-images-2/chapter_17/section_2/b2531ccc-e029-4c10-a35d-da08edc5e93e.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Characteristics of Object-Oriented Languages\n\nThere is no consensus in the programming community about what features\na language must have to be considered object oriented. Rust is influenced by\n\nmany programming paradigms, including OOP; for example, we explored\nthe features that came from functional programming in Chapter 13.\nArguably, OOP languages share certain common characteristics, namely\nobjects, encapsulation, and inheritance. Let's look at what each of those\ncharacteristics means and whether Rust supports it.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 17.3,
                        "section_name": "Objects Contain Data and Behavior",
                        "section_path": "./screenshots-images-2/chapter_17/section_3",
                        "images": [
                            "./screenshots-images-2/chapter_17/section_3/f5d068cb-3634-4224-bbe3-c9b3d2d57097.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Objects Contain Data and Behavior\n\nThe book Design Patterns: Elements of Reusable Object-Oriented Software by Erich\nGamma, Richard Helm, Ralph Johnson, and John Vlissides (Addison-Wesley\nProfessional, 1994) colloquially referred to as The Gang of Four book, is a\ncatalog of object-oriented design patterns. It defines OOP this way:\n\nObject-oriented programs are made up of objects. An object pack-\nages both data and the procedures that operate on that data. The\nprocedures are typically called methods or operations.\n\nUsing this definition, Rust is object oriented: structs and enums have\ndata, and impl blocks provide methods on structs and enums. Even though\nstructs and enums with methods aren't called objects, they provide the same\nfunctionality, according to the Gang of Four\u2019s definition of objects.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 17.4,
                        "section_name": "Encapsulation That Hides Implementation Details",
                        "section_path": "./screenshots-images-2/chapter_17/section_4",
                        "images": [
                            "./screenshots-images-2/chapter_17/section_4/2c5eca85-71e5-4daf-9edc-c27a32ebf5a7.png",
                            "./screenshots-images-2/chapter_17/section_4/abf1b3eb-5168-4685-9f5d-7de66b699e3d.png",
                            "./screenshots-images-2/chapter_17/section_4/de0aa112-863c-4cc8-9b37-9f23ef5b2bb7.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/lib.rs\n\nEncapsulation That Hides Implementation Details\n\nAnother aspect commonly associated with OOP is the idea of encapsulation,\nwhich means that the implementation details of an object aren't accessible to\ncode using that object. Therefore, the only way to interact with an object is\nthrough its public API; code using the object shouldn't be able to reach into\nthe object\u2019s internals and change data or behavior directly. This enables the\nprogrammer to change and refactor an object's internals without needing to\nchange the code that uses the object.\n\nWe discussed how to control encapsulation in Chapter 7: we can use\nthe pub keyword to decide which modules, types, functions, and methods\nin our code should be public, and by default everything else is private. For\nexample, we can define a struct AveragedCollection that has a field contain-\ning a vector of i32 values. The struct can also have a field that contains\nthe average of the values in the vector, meaning the average doesn\u2019t have\nto be computed on demand whenever anyone needs it. In other words,\nAveragedCol lection will cache the calculated average for us. Listing 17-1 has\nthe definition of the AveragedCollection struct.\n\npub struct AveragedCollection {\nlist: Vec<i32>,\naverage: f64,\n\n}\n\nListing 17-1: An AveragedCollection struct that maintains a list of integers and the average\nof the items in the collection\n\nThe struct is marked pub so that other code can use it, but the fields\nwithin the struct remain private. This is important in this case because we\n\nsrc/lib.rs\n\nwant to ensure that whenever a value is added or removed from the list, the\naverage is also updated. We do this by implementing add, remove, and average\nmethods on the struct, as shown in Listing 17-2.\n\nimpl AveragedCollection {\npub fn add(&mut self, value: i32) {\nself.list.push(value) ;\nself.update_average() ;\n\n}\n\npub fn remove(&mut self) -> Option<i32> {\nlet result = self.list.pop();\nmatch result {\nSome(value) => {\nself.update_average();\nSome(value)\n\nhs\n\nNone => None,\n\n}\n}\n\npub fn average(&self) -> f64 {\nself.average\n}\n\nfn update_average(&mut self) {\nlet total: i32 = self.list.iter().sum();\nself.average = total as f64 / self.list.len() as f64;\n\n}\n\nListing 17-2: Implementations of the public methods add, remove, and average on\nAveragedCollection\n\nThe public methods add, remove, and average are the only ways to access\nor modify data in an instance of AveragedCollection. When an item is added\nto list using the add method or removed using the remove method, the imple-\nmentations of each call the private update_average method that handles updat-\ning the average field as well.\n\nWe leave the list and average fields private so there is no way for external\ncode to add or remove items to the List field directly; otherwise, the average\nfield might become out of syne when the list changes. The average method\nreturns the value in the average field, allowing external code to read the\naverage but not modify it.\n\nBecause we've encapsulated the implementation details of the struct\nAveragedCollection, we can easily change aspects, such as the data structure, in\nthe future. For instance, we could use a HashSet<i32> instead of a Vec<i32> for the\nlist field. As long as the signatures of the add, remove, and average public meth-\nods stay the same, code using AveragedCollection wouldn\u2019t need to change. If\nwe made list public instead, this wouldn't necessarily be the case: HashSet<i32>\nand Vec<i32> have different methods for adding and removing items, so the\nexternal code would likely have to change if it were modifying list directly.\n\nIf encapsulation is a required aspect for a language to be considered\nobject oriented, then Rust meets that requirement. The option to use pub\nor not for different parts of code enables encapsulation of implementation\ndetails.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 17.5,
                        "section_name": "Inheritance as a Type System and as Code Sharing",
                        "section_path": "./screenshots-images-2/chapter_17/section_5",
                        "images": [
                            "./screenshots-images-2/chapter_17/section_5/5f862dee-79d7-44f7-bba6-5c3c7f7568af.png",
                            "./screenshots-images-2/chapter_17/section_5/a673438d-43f4-4bda-a1a2-6a8e77a62e88.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Inheritance as a Type System and as Code Sharing\n\nInheritance is a mechanism whereby an object can inherit from another\nobject\u2019s definition, thus gaining the parent object\u2019s data and behavior\nwithout you having to define them again.\n\nIf a language must have inheritance to be an object-oriented language,\nthen Rust is not one. There is no way to define a struct that inherits the\nparent struct\u2019s fields and method implementations. However, if you're\nused to having inheritance in your programming toolbox, you can use\nother solutions in Rust, depending on your reason for reaching for inheri-\ntance in the first place.\n\nYou choose inheritance for two main reasons. One is for reuse of code:\nyou can implement a particular behavior for one type, and inheritance\nenables you to reuse that implementation for a different type. You can share\nRust code using default trait method implementations instead, which you\nsaw in Listing 10-14 when we added a default implementation of the summarize\nmethod on the Summary trait. Any type implementing the Summary trait would\nhave the summarize method available on it without any further code. This\nis similar to a parent class having an implementation of a method and an\ninheriting child class also having the implementation of the method. We\ncan also override the default implementation of the summarize method when\nwe implement the Summary trait, which is similar to a child class overriding\nthe implementation of a method inherited from a parent class.\n\nThe other reason to use inheritance relates to the type system: to\nenable a child type to be used in the same places as the parent type. This\nis also called polymorphism, which means that you can substitute multiple\nobjects for each other at runtime if they share certain characteristics.\n\nPOLYMORPHISM\n\nTo many people, polymorphism is synonymous with inheritance. But it\u2019s actually\na more general concept that refers to code that can work with data of multiple\n\ntypes. For inheritance, those types are generally subclasses.\n\nRust instead uses generics to abstract over different possible types and\ntrait bounds to impose constraints on what those types must provide. This is\nsometimes called bounded parametric polymorphism.\n\nInheritance has recently fallen out of favor as a programming design\nsolution in many programming languages because it\u2019s often at risk of\nsharing more code than necessary. Subclasses shouldn\u2019t always share all\ncharacteristics of their parent class but will do so with inheritance. This\n\ncan make a program\u2019s design less flexible. It also introduces the possibil-\nity of calling methods on subclasses that don\u2019t make sense or that cause\nerrors because the methods don\u2019t apply to the subclass. In addition, some\nlanguages will only allow a subclass to inherit from one class, further\nrestricting the flexibility of a program's design.\n\nFor these reasons, Rust takes a different approach, using trait objects\ninstead of inheritance. Let's look at how trait objects enable polymorphism\nin Rust.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 17.6,
                        "section_name": "Using Trait Objects That Allow for Values of Different Types",
                        "section_path": "./screenshots-images-2/chapter_17/section_6",
                        "images": [
                            "./screenshots-images-2/chapter_17/section_6/0f67b765-38bb-42bf-9e10-cbe8801bc87a.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Using Trait Objects That Allow for Values of Different Types\n\nIn Chapter 8, we mentioned that one limitation of vectors is that they can\nstore elements of only one type. We created a workaround in Listing 8-10\nwhere we defined a SpreadsheetCell enum that had variants to hold integers,\nfloats, and text. This meant we could store different types of data in each\ncell and still have a vector that represented a row of cells. This is a perfectly\ngood solution when our interchangeable items are a fixed set of types that\nwe know when our code is compiled.\n\nHowever, sometimes we want our library user to be able to extend the\nset of types that are valid in a particular situation. To show how we might\nachieve this, we'll create an example graphical user interface (GUI) tool that\niterates through a list of items, calling a draw method on each one to draw\nit to the screen\u2014a common technique for GUI tools. We'll create a library\ncrate called gui that contains the structure of a GUI library. This crate might\ninclude some types for people to use, such as Button or TextField. In addition,\ngui users will want to create their own types that can be drawn: for instance,\none programmer might add an Image and another might add a SelectBox.\n\nWe won't implement a fully fledged GUI library for this example but will\nshow how the pieces would fit together. At the time of writing the library, we\ncan\u2019t know and define all the types other programmers might want to create.\nBut we do know that gui needs to keep track of many values of different types,\nand it needs to call a draw method on each of these differently typed values. It\ndoesn\u2019t need to know exactly what will happen when we call the draw method,\njust that the value will have that method available for us to call.\n\nTo do this in a language with inheritance, we might define a class named\nComponent that has a method named draw on it. The other classes, such as\nButton, Image, and SelectBox, would inherit from Component and thus inherit\nthe draw method. They could each override the draw method to define their\ncustom behavior, but the framework could treat all of the types as if they\nwere Component instances and call draw on them. But because Rust doesn\u2019t have\ninheritance, we need another way to structure the gui library to allow users to\nextend it with new types.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 17.7,
                        "section_name": "Defining a Trait for Common Behavior",
                        "section_path": "./screenshots-images-2/chapter_17/section_7",
                        "images": [
                            "./screenshots-images-2/chapter_17/section_7/42f0698c-fb74-428f-8a61-7a8cdcad5aed.png",
                            "./screenshots-images-2/chapter_17/section_7/a0e70a35-4588-4f1d-9452-a258119e3800.png",
                            "./screenshots-images-2/chapter_17/section_7/1bc347bb-c89c-41a3-b3d9-495caf72509e.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Defining a Trait for Common Behavior\n\nTo implement the behavior we want gui to have, we'll define a trait named\nDraw that will have one method named draw. Then we can define a vector\nthat takes a trait object. A trait object points to both an instance of a type\n\nsrc/lib.rs\n\nsrc/lib.rs\n\nsrc/lib.rs\n\nimplementing our specified trait as well as a table used to look up trait\nmethods on that type at runtime. We create a trait object by specifying\nsome sort of pointer, such as a & reference or a Box<T> smart pointer, and\nthen the dyn keyword, and then specifying the relevant trait. (We'll talk\nabout the reason trait objects must use a pointer in \u201cDynamically Sized\nTypes and the Sized Trait\u201d on page 441.) We can use trait objects in place\nofa generic or concrete type. Wherever we use a trait object, Rust\u2019s type\nsystem will ensure at compile time that any value used in that context will\nimplement the trait object\u2019s trait. Consequently, we don\u2019t need to know all\nthe possible types at compile time.\n\nWe've mentioned that in Rust, we refrain from calling structs and enums\n\u201cobjects\u201d to distinguish them from other languages\u2019 objects. In a struct or\nenum, the data in the struct fields and the behavior in imp] blocks are sepa-\nrated, whereas in other languages, the data and behavior combined into one\nconcept is often labeled an object. However, trait objects are more like objects\nin other languages in the sense that they combine data and behavior. But\ntrait objects differ from traditional objects in that we can\u2019t add data to a trait\nobject. Trait objects aren\u2019t as generally useful as objects in other languages:\ntheir specific purpose is to allow abstraction across common behavior.\n\nListing 17-3 shows how to define a trait named Draw with one method\nnamed draw.\n\npub trait Draw {\nfn draw(&self);\n}\n\nListing 17-3: Definition of the Draw trait\n\nThis syntax should look familiar from our discussions on how to define\ntraits in Chapter 10. Next comes some new syntax: Listing 17-4 defines a\nstruct named Screen that holds a vector named components. This vector is of\ntype Box<dyn Draw\u00bb, which is a trait object; it\u2019s a stand-in for any type inside a\nBox that implements the Draw trait.\n\npub struct Screen {\npub components: Vec<Box<dyn Draw>>,\n\nListing 17-4: Definition of the Screen struct with a components field holding a vector of trait\nobjects that implement the Draw trait\n\nOn the Screen struct, we'll define a method named run that will call the\ndraw method on each of its components, as shown in Listing 17-5.\n\nimpl Screen {\npub fn run(&self) {\nfor component in self.components.iter() {\n\ncomponent .draw();\n}\n\nsrc/lib.rs\n\n}\n\nListing 17-5: A run method on Screen that calls the draw method on each component\n\nThis works differently than defining a struct that uses a generic type\nparameter with trait bounds. A generic type parameter can only be substi-\ntuted with one concrete type at a time, whereas trait objects allow for multiple\nconcrete types to fill in for the trait object at runtime. For example, we could\nhave defined the Screen struct using a generic type and a trait bound, as in\nListing 17-6.\n\npub struct Screen<T: Draw> {\npub components: Vec<T>,\n\nimpl<T> Screen<T>\nwhere T: Draw {\npub fn run(&self) {\nfor component in self.components.iter() {\ncomponent .draw() ;\n}\n\n}\n\nListing 17-6: An alternate implementation of the Screen struct and its run method using\ngenerics and trait bounds\n\nThis restricts us to a Screen instance that has a list of components all\nof type Button or all of type TextField. If you'll only ever have homogeneous\ncollections, using generics and trait bounds is preferable because the defini-\ntions will be monomorphized at compile time to use the concrete types.\n\nOn the other hand, with the method using trait objects, one Screen\ninstance can hold a Vec<T> that contains a Box<Button> as well as a Box<TextField>.\nLet\u2019s look at how this works, and then we'll talk about the runtime perfor-\nmance implications.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 17.8,
                        "section_name": "Implementing the Trait",
                        "section_path": "./screenshots-images-2/chapter_17/section_8",
                        "images": [
                            "./screenshots-images-2/chapter_17/section_8/1eba8581-5be7-4e97-8057-eec643d6525a.png",
                            "./screenshots-images-2/chapter_17/section_8/9649af65-4da5-46e0-8924-1ed2d24086e7.png",
                            "./screenshots-images-2/chapter_17/section_8/575bb793-d7c9-4d17-9973-3f5fa8db1ab2.png",
                            "./screenshots-images-2/chapter_17/section_8/351034ef-0a84-47c1-b9ce-e2132406c660.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/lib.rs\n\nImplementing the Trait\n\nNow we'll add some types that implement the Draw trait. We'll provide the\nButton type. Again, actually implementing a GUI library is beyond the scope\nof this book, so the draw method won't have any useful implementation in its\nbody. To imagine what the implementation might look like, a Button struct\nmight have fields for width, height, and label, as shown in Listing 17-7.\n\npub struct Button {\npub width: u32,\npub height: u32,\npub label: String,\n}\n\nimpl Draw for Button {\nfn draw(&self) {\n\nsrc/main.rs\n\nsrc/main.rs\n\n// code to actually draw a button\n\n}\n\nListing 17-7: A Button struct that implements the Draw trait\n\nThe width, height, and label fields on Button will differ from the fields on\nother components, such as a TextField type, that might have those fields plus\na placeholder field instead. Each of the types we want to draw on the screen\nwill implement the Draw trait but will use different code in the draw method\nto define how to draw that particular type, as Button has here (without the\nactual GUI code, which is beyond the scope of this chapter). The Button\ntype, for instance, might have an additional imp1 block containing methods\nrelated to what happens when a user clicks the button. These kinds of\nmethods won't apply to types like TextField.\n\nIf someone using our library decides to implement a SelectBox struct\nthat has width, height, and options fields, they implement the Draw trait on the\nSelectBox type as well, as shown in Listing 17-8.\n\nuse gui: :Draw;\n\nstruct SelectBox {\nwidth: u32,\nheight: u32,\noptions: Vec<String>,\n\n}\n\nimpl Draw for SelectBox {\nfn draw(&self) {\n// code to actually draw a select box\n}\n\n}\n\nListing 17-8: Another crate using gui and implementing the Draw trait on a SelectBox struct\n\nOur library\u2019s user can now write their main function to create a Screen\ninstance. To the Screen instance, they can add a SelectBox and a Button by\nputting each in a Box<T> to become a trait object. They can then call the run\nmethod on the Screen instance, which will call draw on each of the compo-\nnents. Listing 17-9 shows this implementation.\n\nuse gui::{Screen, Button};\n\nfn main() {\nlet screen = Screen {\ncomponents: vec! [\nBox: :new(SelectBox {\nwidth: 75,\nheight: 10,\noptions: vec![\nString::from(\"Yes\"),\nString: :from(\"Maybe\"),\nString: :from(\"No\")\n\nsrc/main.rs\n\n1,\n\n}),\n\nBox: :new(Button {\nwidth: 50,\nheight: 10,\nlabel: String::from(\"OK\"),\n\n}),\n\n1,\niH\n\nscreen.run();\n\n}\n\nlisting 17-9: Using trait objects to store values of different types that implement the same trait\n\nWhen we wrote the library, we didn\u2019t know that someone might add the\nSelectBox type, but our Screen implementation was able to operate on the new\ntype and draw it because SelectBox implements the Draw trait, which means it\nimplements the draw method.\n\nThis concept\u2014of being concerned only with the messages a value\nresponds to rather than the value\u2019s concrete type\u2014is similar to the con-\ncept duck typing in dynamically typed languages: if it walks like a duck and\nquacks like a duck, then it must be a duck! In the implementation of run on\nScreen in Listing 17-5, run doesn\u2019t need to know what the concrete type of\neach component is. It doesn\u2019t check whether a component is an instance of\na Button or a SelectBox; it just calls the draw method on the component. By\nspecifying Box<dyn Draw> as the type of the values in the components vector,\nwe've defined Screen to need values that we can call the draw method on.\n\nThe advantage of using trait objects and Rust\u2019s type system to write\ncode similar to code using duck typing is that we never have to check\nwhether a value implements a particular method at runtime or worry\nabout getting errors if a value doesn\u2019t implement a method but we call it\nanyway. Rust won't compile our code if the values don\u2019t implement the\ntraits that the trait objects need.\n\nFor example, Listing 17-10 shows what happens if we try to create a\nScreen with a String as a component.\n\nuse gui::Screen;\nfn main() {\nlet screen = Screen {\ncomponents: vec![\nBox: :new(String::from(\"Hi\")),\n1,\nhs\n\nscreen. run();\n\nListing 17-10: Attempting to use a type that doesn\u2019t implement the trait object's trait\n\nWe'll get this error because String doesn\u2019t implement the Draw trait:\n\nerror[E0277]: the trait bound \u201cstd::string::String: gui::Draw\u2019 is not\nsatisfied\n--> src/main.rs:7:13\n|\n7| Box: :new(String: :from(\"Hi\")),\n| ARARARBARARRARAARAARARAARARD the trait gui: :Draw is not\nimplemented for \u201cstd::string: :String~\n\nnote: required for the cast to the object type \u201cgui: :Draw\u2122\n\nThis error lets us know that either we're passing something to Screen we\ndidn\u2019t mean to pass and we should pass a different type or we should imple-\nment Draw on String so that Screen is able to call draw on it.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 17.9,
                        "section_name": "Trait Objects Perform Dynamic Dispatch",
                        "section_path": "./screenshots-images-2/chapter_17/section_9",
                        "images": [
                            "./screenshots-images-2/chapter_17/section_9/16399733-17ec-42c4-b8f8-f931dd2bfcc2.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Trait Objects Perform Dynamic Dispatch\n\nRecall in \u201cPerformance of Code Using Generics\u201d on page 181 our discussion\non the monomorphization process performed by the compiler when we use\ntrait bounds on generics: the compiler generates nongeneric implementa-\ntions of functions and methods for each concrete type that we use in place\n\nof a generic type parameter. The code that results from monomorphization\nis doing static dispatch, which is when the compiler knows what method you're\ncalling at compile time. This is opposed to dynamic dispatch, which is when the\ncompiler can\u2019t tell at compile time which method you're calling. In dynamic\ndispatch cases, the compiler emits code that at runtime will figure out which\nmethod to call.\n\nWhen we use trait objects, Rust must use dynamic dispatch. The compiler\ndoesn\u2019t know all the types that might be used with the code that is using trait\nobjects, so it doesn\u2019t know which method implemented on which type to call.\nInstead, at runtime, Rust uses the pointers inside the trait object to know\nwhich method to call. There is a runtime cost when this lookup happens\nthat doesn\u2019t occur with static dispatch. Dynamic dispatch also prevents the\ncompiler from choosing to inline a method\u2019s code, which in turn prevents\nsome optimizations. However, we did get extra flexibility in the code that\nwe wrote in Listing 17-5 and were able to support in Listing 17-9, so it\u2019s a\ntrade-off to consider.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 17.1,
                        "section_name": "Object Safety Is Required for Trait Objects",
                        "section_path": "./screenshots-images-2/chapter_17/section_10",
                        "images": [
                            "./screenshots-images-2/chapter_17/section_10/3ee40914-cbf0-4960-a547-814fcd604dab.png",
                            "./screenshots-images-2/chapter_17/section_10/d7b88271-164f-43cf-8f8c-e2ea25b02ee2.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Object Safety Is Required for Trait Objects\n\nYou can only make object-safe traits into trait objects. Some complex rules\ngovern all the properties that make a trait object safe, but in practice, only\ntwo rules are relevant. A trait is object safe if all the methods defined in the\ntrait have the following properties:\n\ne The return type isn\u2019t Self.\ne There are no generic type parameters.\n\nThe Self keyword is an alias for the type we're implementing the traits\nor methods on. Trait objects must be object safe because once you've used\na trait object, Rust no longer knows the concrete type that\u2019s implementing\nthat trait. Ifa trait method returns the concrete Self type, but a trait object\nforgets the exact type that Self is, there is no way the method can use the\noriginal concrete type. The same is true of generic type parameters that are\nfilled in with concrete type parameters when the trait is used: the concrete\ntypes become part of the type that implements the trait. When the type is\nforgotten through the use of a trait object, there is no way to know what\ntypes to fill in the generic type parameters with.\n\nAn example of a trait whose methods are not object safe is the standard\nlibrary's Clone trait. The signature for the clone method in the Clone trait looks\nlike this:\n\npub trait Clone {\nfn clone(&self) -> Self;\n}\n\nThe String type implements the Clone trait, and when we call the clone\nmethod on an instance of String, we get back an instance of String. Similarly,\nif we call clone on an instance of Vec<T>, we get back an instance of Vec<T>.\nThe signature of clone needs to know what type will stand in for Self, because\nthat\u2019s the return type.\n\nThe compiler will indicate when you're trying to do something that\nviolates the rules of object safety in regard to trait objects. For example,\nlet\u2019s say we tried to implement the Screen struct in Listing 17-4 to hold\ntypes that implement the Clone trait instead of the Draw trait, like this:\n\npub struct Screen {\npub components: Vec<Box<dyn Clone>>,\n}\n\nWe would get this error:\n\nerror[E\u00a30038]: the trait ~std::clone::Clone\u2019 cannot be made into an object\n--> src/lib.rs:2:5\n\n|\n2] pub components: Vec<Box<dyn Clone>>,\n\n| AARAARAARAR BARBARA AARAARARBARBARAAR the trait ~std::clone::Clone\u201d\ncannot be made into an object\n\n|\n\n= note: the trait cannot require that \u201cSelf : Sized\u201d\n\nThis error means you can\u2019t use this trait as a trait object in this way.\nIf you're interested in more details on object safety, see Rust RFC 255 at\nhitps://github.com/rust-lang/rfcs/blob/master/text/0255-object-safety.md/.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 17.11,
                        "section_name": "Implementing an Object-Oriented Design Pattern",
                        "section_path": "./screenshots-images-2/chapter_17/section_11",
                        "images": [
                            "./screenshots-images-2/chapter_17/section_11/0a2b668c-42a2-4fdc-846d-96324da852bf.png",
                            "./screenshots-images-2/chapter_17/section_11/08b88e60-53c3-42bd-8ca0-7cf43f07f7f7.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Implementing an Object-Oriented Design Pattern\n\nsre/main.rs\n\nThe state pattern is an object-oriented design pattern. The crux of the pattern\nis that a value has some internal state, which is represented by a set of state\nobjects, and the value\u2019s behavior changes based on the internal state. The\nstate objects share functionality: in Rust, of course, we use structs and traits\nrather than objects and inheritance. Each state object is responsible for its\nown behavior and for governing when it should change into another state.\nThe value that holds a state object knows nothing about the different behav-\nior of the states or when to transition between states.\n\nUsing the state pattern means when the business requirements of the\nprogram change, we won't need to change the code of the value holding\nthe state or the code that uses the value. We'll only need to update the code\ninside one of the state objects to change its rules or perhaps add more state\nobjects. Let's look at an example of the state design pattern and how to use\nit in Rust.\n\nWe'll implement a blog post workflow in an incremental way. The blog's\nfinal functionality will look like this:\n\n1. A blog post starts as an empty draft.\n\n2. When the draft is done, a review of the post is requested.\n\n3. When the post is approved, it gets published.\n\n4. Only published blog posts return content to print, so unapproved posts\n\ncan\u2019t accidentally be published.\n\nAny other changes attempted on a post should have no effect. For\nexample, if we try to approve a draft blog post before we've requested a\nreview, the post should remain an unpublished draft.\n\nListing 17-11 shows this workflow in code form: this is an example usage\nof the API we'll implement in a library crate named blog. This won't compile\nyet because we haven't implemented the blog crate yet.\n\nuse blog: :Post;\n\nfn main() {\n@ let mut post = Post: :new();\n\n\u00a9 post.add_text(\"I ate a salad for lunch today\");\n\u00a9 assert_eq!(\"\", post.content());\n\n\u00a9 post.request_review();\n\u00a9 assert_eq!(\"\", post.content());\n\n\u00a9 post.approve();\n@ assert_eq!(\"I ate a salad for lunch today\", post.content());\n}\n\nListing 17-11: Code that demonstrates the desired behavior we want our blog crate to have\n\nWe want to allow the user to create a new draft blog post with Post: :new \u00ae.\nThen we want to allow text to be added to the blog post while it\u2019s in the draft\nstate @. If we try to get the post\u2019s content immediately, before approval, noth-\ning should happen because the post is still a draft. We've added assert_eq! in\nthe code for demonstration purposes \u00a9. An excellent unit test for this would\nbe to assert that a draft blog post returns an empty string from the content\nmethod, but we're not going to write tests for this example.\n\nNext, we want to enable a request for a review of the post @, and we want\ncontent to return an empty string while waiting for the review \u00ae. When the\npost receives approval @, it should get published, meaning the text of the post\nwill be returned when content is called @.\n\nNotice that the only type we're interacting with from the crate is the Post\ntype. This type will use the state pattern and will hold a value that will be one\nof three state objects representing the various states a post can be in\u2014draft,\nwaiting for review, or published. Changing from one state to another will be\nmanaged internally within the Post type. The states change in response to the\nmethods called by our library's users on the Post instance, but they don\u2019t have\nto manage the state changes directly. Also, users can\u2019t make a mistake with\nthe states, like publishing a post before it\u2019s reviewed.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 17.12,
                        "section_name": "Defining Post and Creating a New Instance in the Draft State",
                        "section_path": "./screenshots-images-2/chapter_17/section_12",
                        "images": [
                            "./screenshots-images-2/chapter_17/section_12/2d3f31d8-5d4f-4fc2-83df-110d01f57600.png",
                            "./screenshots-images-2/chapter_17/section_12/893d4476-ff99-4821-badf-df22e04fd489.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/lib.rs\n\nDefining Post and Creating a New Instance in the Draft State\n\nLet's get started on the implementation of the library! We know we need a\npublic Post struct that holds some content, so we'll start with the definition\nof the struct and an associated public new function to create an instance of\nPost, as shown in Listing 17-12. We'll also make a private State trait. Then Post\nwill hold a trait object of Box<dyn State> inside an Option<T> in a private field\nnamed state. You'll see why the Option<T> is necessary in a bit.\n\npub struct Post {\nstate: Option<Box<dyn State>>,\ncontent: String,\n\n}\nimpl Post {\npub fn new() -> Post {\nPost {\n\u00a9 state: Some(Box::new(Draft {})),\n\u00a9 content: String: :new(),\n}\n}\n}\n\ntrait State {}\nstruct Draft {}\n\nimpl State for Draft {}\n\nlisting 17-12: Definition of a Post struct and a new function that creates a new Post\ninstance, a State trait, and a Draft struct\n\nThe State trait defines the behavior shared by different post states, and\nthe Draft, PendingReview, and Published states will all implement the State trait.\nFor now, the trait doesn\u2019t have any methods, and we'll start by defining just\nthe Draft state because that is the state we want a post to start in.\n\nWhen we create a new Post, we set its state field to a Some value that\nholds a Box \u00ae. This 80x points to a new instance of the Draft struct. This\nensures whenever we create a new instance of Post, it will start out as a draft.\nBecause the state field of Post is private, there is no way to create a Post in\nany other state! In the Post: :new function, we set the content field to a new,\nempty String @.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 17.13,
                        "section_name": "Storing the Text of the Post Content",
                        "section_path": "./screenshots-images-2/chapter_17/section_13",
                        "images": [
                            "./screenshots-images-2/chapter_17/section_13/e269a1e9-11d9-483f-88bf-b3815d70de7c.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/lib.rs\n\nStoring the Text of the Post Content\n\nListing 17-11 showed that we want to be able to call a method named add_text\nand pass it a &str that is then added to the text content of the blog post. We\nimplement this as a method rather than exposing the content field as pub. This\nmeans we can implement a method later that will control how the content\nfield\u2019s data is read. The add_text method is pretty straightforward, so let\u2019s\nadd the implementation in Listing 17-13 to the imp] Post block.\n\nimp] Post {\n\npub fn add_text(&mut self, text: &str) {\nself.content.push_str(text);\n}\n\nListing 17-13: Implementing the add_text method to add text to a post's content\n\nThe add_text method takes a mutable reference to self, because we're\nchanging the Post instance that we're calling add_text on. We then call\npush_str on the String in content and pass the text argument to add to the\nsaved content. This behavior doesn\u2019t depend on the state the post is in, so it\u2019s\nnot part of the state pattern. The add_text method doesn\u2019t interact with the\nstate field at all, but it is part of the behavior we want to support.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 17.14,
                        "section_name": "Ensuring the Content of a Draft Post Is Empty",
                        "section_path": "./screenshots-images-2/chapter_17/section_14",
                        "images": [
                            "./screenshots-images-2/chapter_17/section_14/f6e0062f-ab03-4523-904e-0b84979ff53c.png",
                            "./screenshots-images-2/chapter_17/section_14/9b403296-d4da-44f3-9032-6149176e0de7.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/lib.rs\n\nEnsuring the Content of a Draft Post Is Empty\n\nEven after we've called add_text and added some content to our post, we still\nwant the content method to return an empty string slice because the post is\nstill in the draft state, as shown at \u00a9 in Listing 17-11. For now, let\u2019s implement\nthe content method with the simplest thing that will fulfill this requirement:\nalways returning an empty string slice. We'll change this later once we imple-\nment the ability to change a post's state so it can be published. So far, posts\ncan only be in the draft state, so the post content should always be empty.\nListing 17-14 shows this placeholder implementation.\n\nimpl Post {\n\npub fn content(&self) -> str {\n\n}\n\nListing 17-14: Adding a placeholder implementation for the content method on Post that\nalways returns an empty string slice\n\nWith this added content method, everything in Listing 17-11 up to the\nline at \u00a9 works as intended.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 17.15,
                        "section_name": "Requesting a Review of the Post Changes Its State",
                        "section_path": "./screenshots-images-2/chapter_17/section_15",
                        "images": [
                            "./screenshots-images-2/chapter_17/section_15/34cfbd8e-90ad-4d4d-9a88-eb46fd0cc53a.png",
                            "./screenshots-images-2/chapter_17/section_15/245d5a02-4c06-4259-a58a-167811c74373.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/lib.rs\n\nRequesting a Review of the Post Changes Its State\nNext, we need to add functionality to request a review of a post, which should\nchange its state from Draft to PendingReview. Listing 17-15 shows this code.\n\n@ pub fn request_review(8mut self) {\n\u00a9 if let Some(s) = self.state.take() {\n\u00a9 self.state = Some(s.request_review())\n\n}\n\ntrait State {\n\u00a9 fn request_review(self: Box<Self>) -> Box<dyn State>;\n}\n\nimpl State for Draft {\nfn request_review(self: Box<Self>) -> Box<dyn State> {\n\u00a9 Box: :new(PendingReview {})\n\n}\n}\n\nstruct PendingReview {}\n\nimpl State for PendingReview {\nfn request_review(self: Box<Self>) -> Box<dyn State> {\n@ self\n\n}\n}\n\nListing 17-15: Implementing request_review methods on Post and the State trait\n\nWe give Post a public method named request_review that will take a\nmutable reference to self \u00ae. Then we call an internal request_review method\non the current state of Post \u00ae, and this second request_review method con-\nsumes the current state and returns a new state.\n\nWe've added the request_review method to the State trait \u00ae; all types\nthat implement the trait will now need to implement the request_review\nmethod. Note that rather than having self, &self, or &mut self as the first\n\nparameter of the method, we have self: Box<Self>. This syntax means the\nmethod is valid only when called on a Box holding the type. This syntax\ntakes ownership of Box<Self>, invalidating the old state so the state value of\nthe Post can transform into a new state.\n\nTo consume the old state, the request_review method needs to take owner-\nship of the state value. This is where the Option in the state field of Post comes\nin: we call the take method to take the Some value out of the state field and\nleave a None in its place, because Rust doesn\u2019t let us have unpopulated fields in\nstructs @. This lets us move the state value out of Post rather than borrowing\nit. Then we'll set the post\u2019s state value to the result of this operation.\n\nWe need to set state to None temporarily rather than setting it directly\nwith code like self.state = self.state.request_review(); to get ownership of\nthe state value. This ensures Post can\u2019t use the old state value after we've\ntransformed it into a new state.\n\nThe request_review method on Draft needs to return a new, boxed\ninstance of a new PendingReview struct \u00a9, which represents the state when\na post is waiting for a review. The PendingReview struct also implements\nthe request_review method but doesn\u2019t do any transformations. Rather, it\nreturns itself @, because when we request a review on a post already in the\nPendingReview state, it should stay in the PendingReview state.\n\nNow we can start seeing the advantages of the state pattern: the\nrequest_review method on Post is the same no matter its state value. Each\nstate is responsible for its own rules.\n\nWe'll leave the content method on Post as is, returning an empty string\nslice. We can now have a Post in the PendingReview state as well as in the Draft\nstate, but we want the same behavior in the PendingReview state. Listing 17-11\nnow works up to the line at @!\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 17.16,
                        "section_name": "Adding the approve Method that Changes the Behavior of content",
                        "section_path": "./screenshots-images-2/chapter_17/section_16",
                        "images": [
                            "./screenshots-images-2/chapter_17/section_16/afef57d0-5f8d-41b7-b332-2c3ecbbc6ac5.png",
                            "./screenshots-images-2/chapter_17/section_16/23be4e92-778b-4ca6-94e2-46fe83ca0026.png",
                            "./screenshots-images-2/chapter_17/section_16/7fcffa11-d432-4e87-8db3-fd890d6bd824.png",
                            "./screenshots-images-2/chapter_17/section_16/9c15e3b9-59b5-412c-a6ff-e2575c9ca43e.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Adding the approve Method that Changes the Behavior of content\n\nThe approve method will be similar to the request_review method: it will set\nstate to the value that the current state says it should have when that state is\napproved, as shown in Listing 17-16.\n\nsrc/lib.rs\n\npub fn approve(&mut self) {\nif let Some(s) = self.state.take() {\nself.state = Some(s.approve())\n}\n\nfn approve(self: Box<Self>) -> Box<dyn State>;\n\nsrc/lib.rs\n\nnip-\n\nfn approve(self: Box<Self>) -> Box<dyn State> {\n\u00a9 self\n\n}\nstruct PendingReview {}\nimpl State for PendingReview {\nfn approve(self: Box<Self>) -> Box<dyn State> {\n\u00a9 Box: :new(Published {})\n}\nstruct Published {}\n\nimpl State for Published {\nfn request_review(self: Box<Self>) -> Box<dyn State> {\n\nself\n\n}\n\nfn approve(self: Box<Self>) -> Box<dyn State> {\nself\n\n}\n\n}\n\nListing 17-16: Implementing the approve method on Post and the State trait\n\nWe add the approve method to the State trait and add a new struct that\nimplements State, the Published state.\n\nSimilar to request_review, if we call the approve method on a Draft, it\nwill have no effect because it will return self \u00ae. When we call approve on\nPendingReview, it returns a new, boxed instance of the Published struct @. The\nPublished struct implements the State trait, and for both the request_review\nmethod and the approve method, it returns itself, because the post should\nstay in the Published state in those cases.\n\nNow we need to update the content method on Post: if the state is\nPublished, we want to return the value in the post\u2019s content field; otherwise,\nwe want to return an empty string slice, as shown in Listing 17-17.\n\npub fn ent(&self) -> &str {\nself.state.as_ref().unwrap().content(&self)\n\n}\n\nListing 17-17: Updating the content method on Post to delegate to a content method on\nState\n\nsrc/lib.rs\n\nBecause the goal is to keep all these rules inside the structs that imple-\nment State, we call a content method on the value in state and pass the post\ninstance (that is, self) as an argument. Then we return the value that is\nreturned from using the content method on the state value.\n\nWe call the as_ref method on the Option because we want a reference\nto the value inside the Option rather than ownership of the value. Because\nstate is an Option<Box<dyn State>>, when we call as_ref, an Option<&Box<dyn\nState>> is returned. If we didn\u2019t call as_ref, we would get an error because\nwe can\u2019t move state out of the borrowed &self of the function parameter.\n\nWe then call the unwrap method, which we know will never panic, because\nwe know the methods on Post ensure that state will always contain a Some\nvalue when those methods are done. This is one of the cases we talked about\nin \u201cCases in Which You Have More Information Than the Compiler\u201d on\npage 165 when we know that a None value is never possible, even though\nthe compiler isn\u2019t able to understand that.\n\nAt this point, when we call content on the &Box<dyn State>, deref coercion\nwill take effect on the & and the Box so the content method will ultimately be\ncalled on the type that implements the State trait. That means we need to\nadd content to the State trait definition, and that is where we'll put the logic\nfor what content to return depending on which state we have, as shown in\nListing 17-18.\n\nfn content<'a>(&self, post: &'a Post) -> &'a str {\neo\"\n\nstruct Published {}\nimpl State for Published\nsnip\n\nfn content<'a>(&self, post: &'a Post) -> &'a str {\n\u00a9 &post.content\n}\n\n}\n\nListing 17-18: Adding the content method to the State trait\n\nWe add a default implementation for the content method that returns an\nempty string slice \u00ae. That means we don\u2019t need to implement content on the\nDraft and PendingReview structs. The Published struct will override the content\nmethod and return the value in post.content @.\n\nNote that we need lifetime annotations on this method, as we discussed\nin Chapter 10. We're taking a reference to a post as an argument and return-\ning a reference to part of that post, so the lifetime of the returned reference is\nrelated to the lifetime of the post argument.\n\nAnd we're done\u2014all of Listing 17-11 now works! We've implemented the\nstate pattern with the rules of the blog post workflow. The logic related to the\nrules lives in the state objects rather than being scattered throughout Post.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 17.17,
                        "section_name": "Trade-offs of the State Pattern",
                        "section_path": "./screenshots-images-2/chapter_17/section_17",
                        "images": [
                            "./screenshots-images-2/chapter_17/section_17/96cd7ce3-30ee-4de6-9bd2-e68c39897744.png",
                            "./screenshots-images-2/chapter_17/section_17/9207a4d2-cab5-4c78-bfe2-921dc27600c9.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Trade-offs of the State Pattern\n\nWe've shown that Rust is capable of implementing the object-oriented state\npattern to encapsulate the different kinds of behavior a post should have in\neach state. The methods on Post know nothing about the various behaviors.\nThe way we organized the code, we have to look in only one place to know\nthe different ways a published post can behave: the implementation of the\nState trait on the Published struct.\n\nIf we were to create an alternative implementation that didn\u2019t use the\nstate pattern, we might instead use match expressions in the methods on\nPost or even in the main code that checks the state of the post and changes\nbehavior in those places. That would mean we would have to look in several\nplaces to understand all the implications of a post being in the published\nstate! This would only increase the more states we added: each of those\nmatch expressions would need another arm.\n\nWith the state pattern, the Post methods and the places we use Post don\u2019t\nneed match expressions, and to add a new state, we would only need to add a\nnew struct and implement the trait methods on that one struct.\n\nThe implementation using the state pattern is easy to extend to add\nmore functionality. To see the simplicity of maintaining code that uses the\nstate pattern, try a few of these suggestions:\n\ne Adda reject method that changes the post's state from PendingReview\nback to Draft.\n\ne Require two calls to approve before the state can be changed to Published.\n\ne Allow users to add text content only when a post is in the Draft state.\nHint: have the state object be responsible for what might change about\nthe content but not responsible for modifying the Post.\n\nOne downside of the state pattern is that, because the states implement\nthe transitions between states, some of the states are coupled to each other.\nIf we added another state between PendingReview and Published, such as\nScheduled, we would have to change the code in PendingReview to transition\nto Scheduled instead. It would be less work if PendingReview didn\u2019t need to\nchange with the addition of a new state, but that would mean switching to\nanother design pattern.\n\nAnother downside is that we've duplicated some logic. To eliminate some\nof the duplication, we might try to make default implementations for the\nrequest_review and approve methods on the State trait that return self; how-\never, this would violate object safety, because the trait doesn\u2019t know what\nthe concrete self will be exactly. We want to be able to use State as a trait\nobject, so we need its methods to be object safe.\n\nOther duplication includes the similar implementations of the\nrequest_review and approve methods on Post. Both methods delegate to\n\nthe implementation of the same method on the value in the state field of\nOption and set the new value of the state field to the result. If we had a lot\nof methods on Post that followed this pattern, we might consider defining a\nmacro to eliminate the repetition (see the \u201cMacros\u201d section in Chapter 19).\nBy implementing the state pattern exactly as it\u2019s defined for object-\n\noriented languages, we're not taking as full advantage of Rust\u2019s strengths as\nwe could. Let\u2019s look at some changes we can make to the blog crate that can\nmake invalid states and transitions into compile time errors.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 17.18,
                        "section_name": "Encoding States and Behavior as Types",
                        "section_path": "./screenshots-images-2/chapter_17/section_18",
                        "images": [
                            "./screenshots-images-2/chapter_17/section_18/344fcc6b-a287-4d94-9336-4dd52e8616ef.png",
                            "./screenshots-images-2/chapter_17/section_18/3652dd91-2f08-4ba8-8d61-cc72f7fe0609.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nsrc/lib.rs\n\nEncoding States and Behavior as Types\n\nWe'll show you how to rethink the state pattern to get a different set of trade-\noffs. Rather than encapsulating the states and transitions completely so out-\nside code has no knowledge of them, we'll encode the states into different\ntypes. Consequently, Rust\u2019s type-checking system will prevent attempts to\nuse draft posts where only published posts are allowed by issuing a compiler\nerror.\n\nLet\u2019s consider the first part of main in Listing 17-11:\n\nfn main() {\nlet mut post = Post::new();\n\npost.add_text(\"I ate a salad for lunch today\");\nassert_eq!(\"\", post.content());\n\nWe still enable the creation of new posts in the draft state using Post: :new\nand the ability to add text to the post's content. But instead of having a\ncontent method on a draft post that returns an empty string, we'll make it\nso draft posts don\u2019t have the content method at all. That way, if we try to\nget a draft post\u2019s content, we'll get a compiler error telling us the method\ndoesn\u2019t exist. As a result, it will be impossible for us to accidentally display\ndraft post content in production, because that code won't even compile.\nListing 17-19 shows the definition of a Post struct and a DraftPost struct, as\nwell as methods on each.\n\npub struct Post {\ncontent: String,\n}\n\npub struct DraftPost {\ncontent: String,\n}\n\nimpl Post {\n@ pub fn new() -> DraftPost {\nDraftPost {\ncontent: String: :new(),\n}\n\n\u00a9 pub fn content(&self) -> &str {\n&self.content\n}\n\n}\n\nimpl DraftPost {\n\u00a9 pub fn add_text(&mut self, text: &str) {\nself.content.push_str(text);\n}\n\n}\n\nListing 17-19: A Post with a content method and a DraftPost without a content method\n\nBoth the Post and DraftPost structs have a private content field that stores\nthe blog post text. The structs no longer have the state field because we're\nmoving the encoding of the state to the types of the structs. The Post struct\nwill represent a published post, and it has a content method that returns the\ncontent @.\n\nWe still have a Post: :new function, but instead of returning an instance\nof Post, it returns an instance of DraftPost \u00ae. Because content is private and\nthere aren't any functions that return Post, it\u2019s not possible to create an\ninstance of Post right now.\n\nThe DraftPost struct has an add_text method, so we can add text to content\nas before \u00ae, but note that DraftPost does not have a content method defined!\nSo now the program ensures all posts start as draft posts, and draft posts\ndon\u2019t have their content available for display. Any attempt to get around these\nconstraints will result in a compiler error.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 17.19,
                        "section_name": "Implementing Transitions as Transformations into Different Types",
                        "section_path": "./screenshots-images-2/chapter_17/section_19",
                        "images": [
                            "./screenshots-images-2/chapter_17/section_19/a424c47a-f5ad-4344-9204-a77a348f1812.png",
                            "./screenshots-images-2/chapter_17/section_19/d5bbbd22-5a97-44ee-a0c4-89ef19eb2f2e.png",
                            "./screenshots-images-2/chapter_17/section_19/b5e9c739-6b1b-4e9e-8751-8cddfc862344.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/lib.rs\n\nImplementing Transitions as Transformations into Different Types\n\nSo how do we get a published post? We want to enforce the rule that a draft\npost has to be reviewed and approved before it can be published. A post in\nthe pending review state should still not display any content. Let\u2019s implement\nthese constraints by adding another struct, PendingReviewPost, defining the\nrequest_review method on DraftPost to return a PendingReviewPost, and defin-\ning an approve method on PendingReviewPost to return a Post, as shown in\nListing 17-20.\n\npl Draft\n\nsnip\nf\n\npub fn request_review(self) -> PendingReviewPost {\nPendingReviewPost {\ncontent: self.content,\n}\n\npub struct PendingReviewPost {\ncontent: String,\n}\n\nsrc/main.rs\n\nimp] PendingReviewPost {\npub fn approve(self) -> Post {\nPost {\ncontent: self.content,\n}\n\n}\n\nListing 17-20: A PendingReviewPost that gets created by calling request_review on DraftPost\nand an approve method that turns a PendingReviewPost into a published Post\n\nThe request_review and approve methods take ownership of self, thus\nconsuming the DraftPost and PendingReviewPost instances and transforming\nthem into a PendingReviewPost and a published Post, respectively. This way,\nwe won't have any lingering DraftPost instances after we've called request\n_review on them, and so forth. The PendingReviewPost struct doesn\u2019t have a\ncontent method defined on it, so attempting to read its content results in a\ncompiler error, as with DraftPost. Because the only way to get a published\nPost instance that does have a content method defined is to call the approve\nmethod on a PendingReviewPost, and the only way to get a PendingReviewPost is\nto call the request_review method on a DraftPost, we've now encoded the blog\npost workflow into the type system.\n\nBut we also have to make some small changes to main. The request_review\nand approve methods return new instances rather than modifying the struct\nthey're called on, so we need to add more let post = shadowing assignments\nto save the returned instances. We also can\u2019t have the assertions about the\ndraft and pending review post\u2019s contents be empty strings, nor do we need\nthem: we can\u2019t compile code that tries to use the content of posts in those\nstates any longer. The updated code in main is shown in Listing 17-21.\n\nuse blog: :Post;\n\nfn main() {\nlet mut post = Post::new();\n\npost.add_text(\"I ate a salad for lunch today\");\nlet post = post.request_review();\nlet post = post.approve();\n\nassert_eq!(\"I ate a salad for lunch today\", post.content());\n}\n\nListing 17-21: Modifications to main to use the new implementation of the blog post workflow\n\nThe changes we needed to make to main to reassign post mean that this\nimplementation doesn\u2019t quite follow the object-oriented state pattern any-\nmore: the transformations between the states are no longer encapsulated\nentirely within the Post implementation. However, our gain is that invalid\nstates are now impossible because of the type system and the type checking\n\nthat happens at compile time! This ensures that certain bugs, such as display\nof the content of an unpublished post, will be discovered before they make it\nto production.\n\nTry the tasks suggested for additional requirements that we mentioned\nat the start of this section on the blog crate as it is after Listing 17-20 to see\nwhat you think about the design of this version of the code. Note that some\nof the tasks might be completed already in this design.\n\nWe've seen that even though Rust is capable of implementing object-\noriented design patterns, other patterns, such as encoding state into the\ntype system, are also available in Rust. These patterns have different trade-\noffs. Although you might be very familiar with object-oriented patterns,\nrethinking the problem to take advantage of Rust\u2019s features can provide\nbenefits, such as preventing some bugs at compile time. Object-oriented\npatterns won't always be the best solution in Rust due to certain features,\nlike ownership, that object-oriented languages don\u2019t have.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 17.2,
                        "section_name": "Summary",
                        "section_path": "./screenshots-images-2/chapter_17/section_20",
                        "images": [
                            "./screenshots-images-2/chapter_17/section_20/aef9bf73-b26e-4ae9-83e0-fa65d3b9a543.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Summary\n\nNo matter whether or not you think Rust is an object-oriented language\nafter reading this chapter, you now know that you can use trait objects to\nget some object-oriented features in Rust. Dynamic dispatch can give your\ncode some flexibility in exchange for a bit of runtime performance. You\ncan use this flexibility to implement object-oriented patterns that can help\nyour code\u2019s maintainability. Rust also has other features, like ownership,\nthat object-oriented languages don\u2019t have. An object-oriented pattern\nwon't always be the best way to take advantage of Rust\u2019s strengths, but it\nis an available option.\n\nNext, we'll look at patterns, which are another of Rust\u2019s features that\nenable lots of flexibility. We\u2019ve looked at them briefly throughout the book\nbut haven't seen their full capability yet. Let\u2019s go!\n",
                        "extracted-code": ""
                    }
                ]
            },
            {
                "chapter_id": 18,
                "chapter_name": "PATTERNS AND MATCHING",
                "chapter_path": "./screenshots-images-2/chapter_18",
                "sections": [
                    {
                        "section_id": 18.1,
                        "section_name": "PATTERNS AND MATCHING",
                        "section_path": "./screenshots-images-2/chapter_18/section_1",
                        "images": [
                            "./screenshots-images-2/chapter_18/section_1/cd6fb3ff-7e64-4e36-a313-abc7256beb84.png",
                            "./screenshots-images-2/chapter_18/section_1/86f31e9e-c66f-412f-b805-81f3f9aab488.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Patterns are a special syntax in Rust for\nmatching against the structure of types,\n\nboth complex and simple. Using patterns in\n\nconjunction with match expressions and other\nconstructs gives you more control over a program\u2019s\ncontrol flow. A pattern consists of some combination\nof the following:\n\ne = Literals\n\ne  Destructured arrays, enums, structs, or tuples\ne  =Variables\n\ne Wildcards\n\ne Placeholders\n\nThese components describe the shape of the data we're working with,\nwhich we then match against values to determine whether our program has\nthe correct data to continue running a particular piece of code.\n\nTo use a pattern, we compare it to some value. If the pattern matches\nthe value, we use the value parts in our code. Recall the match expressions\nin Chapter 6 that used patterns, such as the coin-sorting machine example.\nIf the value fits the shape of the pattern, we can use the named pieces. If it\ndoesn\u2019t, the code associated with the pattern won't run.\n\nThis chapter is a reference on all things related to patterns. We'll\ncover the valid places to use patterns, the difference between refutable\nand irrefutable patterns, and the different kinds of pattern syntax that\nyou might see. By the end of the chapter, you'll know how to use patterns\nto express many concepts in a clear way.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 18.2,
                        "section_name": "All the Places Patterns Can Be Used",
                        "section_path": "./screenshots-images-2/chapter_18/section_2",
                        "images": [
                            "./screenshots-images-2/chapter_18/section_2/bd47ef0c-7bbb-4252-9ee7-b3aaa7909b12.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "All the Places Patterns Can Be Used\n\nPatterns pop up in a number of places in Rust, and you've been using them\na lot without realizing it! This section discusses all the places where patterns\nare valid.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 18.3,
                        "section_name": "match Arms",
                        "section_path": "./screenshots-images-2/chapter_18/section_3",
                        "images": [
                            "./screenshots-images-2/chapter_18/section_3/367ee524-2193-4462-b787-cb2506ef7a0d.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "match Arms\n\nAs discussed in Chapter 6, we use patterns in the arms of match expressions.\nFormally, match expressions are defined as the keyword match, a value to match\non, and one or more match arms that consist of a pattern and an expression\nto run if the value matches that arm\u2019s pattern, like this:\n\nmatch VALUE {\nPATTERN => EXPRESSION,\nPATTERN => EXPRESSION,\nPATTERN => EXPRESSION,\n\nOne requirement for match expressions is that they need to be exhaustive\nin the sense that all possibilities for the value in the match expression must be\naccounted for. One way to ensure you've covered every possibility is to have a\ncatchall pattern for the last arm: for example, a variable name matching any\nvalue can never fail and thus covers every remaining case.\n\nA particular pattern _ will match anything, but it never binds to a vari-\nable, so it\u2019s often used in the last match arm. The _ pattern can be useful\nwhen you want to ignore any value not specified, for example. We'll cover\nthe _ pattern in more detail in \u201cIgnoring Values in a Pattern\u201d on page 409.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 18.4,
                        "section_name": "Conditional if let Expressions",
                        "section_path": "./screenshots-images-2/chapter_18/section_4",
                        "images": [
                            "./screenshots-images-2/chapter_18/section_4/2f0d9546-9427-4c0b-8445-d2181bcac367.png",
                            "./screenshots-images-2/chapter_18/section_4/e2b9dc3c-51ad-41f9-a420-268d3142462c.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Conditional if let Expressions\n\nIn Chapter 6, we discussed how to use if let expressions mainly as a shorter\nway to write the equivalent of a match that only matches one case. Optionally,\nif let can have a corresponding else containing code to run if the pattern in\nthe if let doesn\u2019t match.\n\nListing 18-1 shows that it\u2019s also possible to mix and match if let, else\nif, and else if let expressions. Doing so gives us more flexibility than a\n\nsrc/main.rs\n\nmatch expression, in which we can express only one value to compare with\nthe patterns. Also, the conditions in a series of if let, else if, and else if\nlet arms aren't required to relate to each other.\n\nThe code in Listing 18-1 shows a series of checks for several conditions\nthat decide what the background color should be. For this example, we've\ncreated variables with hardcoded values that a real program might receive\nfrom user input.\n\nfn main() {\nlet favorite_color: Option<&str> = None;\nlet is_tuesday = false;\nlet age: Result<u8, > = \"34\".parse();\n\n\u00a9 if let Some(color) = favorite_color {\n\n\u00a9 println!(\"Using your favorite color, {}, as the background\", color);\n\u00a9 } else if is_tuesday {\n\u00a9 println! (\"Tuesday is green day!\");\n@ } else if let Ok(age) = age {\n\u00ae if age > 30 {\n@ println! (\"Using purple as the background color\");\n} else {\n\u00a9 println! (\"Using orange as the background color\");\n\n}\n\u00a9 } else {\n@\u00ae println! (\"Using blue as the background color\");\n\n}\n\nlisting 18-1: Mixing if let, else if, else if let, and else\n\nIf the user specifies a favorite color @, that color is the background\ncolor @. If today is Tuesday \u00ae, the background color is green \u00ae. If the user\nspecifies their age as a string and we can parse it as a number successfully \u00ae,\nthe color is either purple @ or orange \u00a9 depending on the value of the num-\nber @. If none of these conditions apply \u00ae, the background color is blue \u00a9.\n\nThis conditional structure lets us support complex requirements. With\nthe hardcoded values we have here, this example will print Using purple as\nthe background color.\n\nYou can see that if let can also introduce shadowed variables in the\nsame way that match arms can: the line if let Ok(age) = age @ introduces\na new shadowed age variable that contains the value inside the 0k variant.\nThis means we need to place the if age > 30 condition \u00ae within that block:\nwe can\u2019t combine these two conditions into if let Ok(age) = age && age > 30.\nThe shadowed age we want to compare to 30 isn\u2019t valid until the new scope\nstarts with the curly bracket.\n\nThe downside of using if let expressions is that the compiler doesn\u2019t\ncheck exhaustiveness, whereas with match expressions it does. If we omitted\nthe last else block \u00a9 and therefore missed handling some cases, the com-\npiler would not alert us to the possible logic bug.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 18.5,
                        "section_name": "while let Conditional Loops",
                        "section_path": "./screenshots-images-2/chapter_18/section_5",
                        "images": [
                            "./screenshots-images-2/chapter_18/section_5/c3fa75d7-c514-486e-8cba-75f64a4d28a7.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "while let Conditional Loops\n\nSimilar in construction to if let, the while let conditional loop allows a\nwhile loop to run for as long as a pattern continues to match. The example in\nListing 18-2 shows a while let loop that uses a vector as a stack and prints the\nvalues in the vector in the opposite order in which they were pushed.\n\nlet mut stack = Vec::new();\n\nstack. push(1);\nstack.push(2);\nstack.push(3);\n\nwhile let Some(top) = stack.pop() {\nprintln!(\"{}\", top);\n\nListing 18-2: Using a while let loop to print values for as long as stack.pop() returns Some\n\nThis example prints 3, 2, and then 1. The pop method takes the last\nelement out of the vector and returns Some(value). If the vector is empty,\npop returns None. The while loop continues running the code in its block as\nlong as pop returns Some. When pop returns None, the loop stops. We can use\nwhile let to pop every element off our stack.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 18.6,
                        "section_name": "for Loops",
                        "section_path": "./screenshots-images-2/chapter_18/section_6",
                        "images": [
                            "./screenshots-images-2/chapter_18/section_6/5ce3a72f-347a-47df-8b3c-16d8a6ec6c9a.png",
                            "./screenshots-images-2/chapter_18/section_6/58db8964-8315-40ae-855b-9049f6dfef7b.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "for Loops\nIn Chapter 3, we mentioned that the for loop is the most common loop con-\nstruction in Rust code, but we haven't yet discussed the pattern that for takes.\nIn a for loop, the pattern is the value that directly follows the keyword for, so\nin for x in y the x is the pattern.\n\nListing 18-3 demonstrates how to use a pattern in a for loop to\ndestructure, or break apart, a tuple as part of the for loop.\n\nlet v = vecl['a', \u2018b', \u2018c'];\nfor (index, value) in v.iter().enumerate() {\nprintln!(\"{} is at index {}\", value, index);\n\nListing 18-3: Using a pattern in a for loop to destructure a tuple\n\nThe code in Listing 18-3 will print the following:\n\na is at index 0\nb is at index 1\nc is at index 2\n\nWe use the enumerate method to adapt an iterator to produce a value\nand that value\u2019s index in the iterator, placed into a tuple. The first call to\n\nenumerate produces the tuple (0, 'a'). When this value is matched to the\npattern (index, value), index will be 0 and value will be \u2018a', printing the\nfirst line of the output.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 18.7,
                        "section_name": "let Statements",
                        "section_path": "./screenshots-images-2/chapter_18/section_7",
                        "images": [
                            "./screenshots-images-2/chapter_18/section_7/a77ff079-4136-40d8-ba94-2f8c30cd9959.png",
                            "./screenshots-images-2/chapter_18/section_7/2acce6aa-56cd-4cba-97ab-542ac2f46786.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "let Statements\n\nPrior to this chapter, we had only explicitly discussed using patterns with\nmatch and if let, but in fact, we've used patterns in other places as well,\nincluding in let statements. For example, consider this straightforward\nvariable assignment with let:\n\nlet x = 5;\n\nThroughout this book, we've used let like this hundreds of times, and\nalthough you might not have realized it, you were using patterns! More for-\nmally, a let statement looks like this:\n\nlet PATTERN = EXPRESSION;\n\nIn statements like let x = 5; with a variable name in the PATTERN slot, the\nvariable name is just a particularly simple form of a pattern. Rust compares\nthe expression against the pattern and assigns any names it finds. So in the\nlet x = 5; example, x is a pattern that means \u201cbind what matches here to the\nvariable x.\u201d Because the name x is the whole pattern, this pattern effectively\nmeans \u201cbind everything to the variable x, whatever the value is.\u201d\n\nTo see the pattern-matching aspect of let more clearly, consider\nListing 18-4, which uses a pattern with let to destructure a tuple.\n\nlet (x, y, z) = (1, 2, 3);\n\nListing 18-4: Using a pattern to destructure a tuple and create three variables at once\n\nHere, we match a tuple against a pattern. Rust compares the value\n(1, 2, 3) to the pattern (x, y, z) and sees that the value matches the pattern,\nso Rust binds 1 to x, 2 to y, and 3 to z. You can think of this tuple pattern as\nnesting three individual variable patterns inside it.\n\nIf the number of elements in the pattern doesn\u2019t match the number of\nelements in the tuple, the overall type won't match and we\u2019ll get a compiler\nerror. For example, Listing 18-5 shows an attempt to destructure a tuple\nwith three elements into two variables, which won't work.\n\nlet (x, y) = (1, 2, 3)3\n\nListing 18-5: Incorrectly constructing a pattern whose variables don\u2019t match the number of\nelements in the tuple\n\nAttempting to compile this code results in this type error:\n\nerror[E0308]: mismatched types\n--> src/main.rs:2:9\n\n2 let (x, y) = (1, 2, 3);\n\n|\n|\n| AaAe\u00ae expected a tuple with 3 elements, found one with 2 elements\n|\n\nnote: expected type \u201c({integer}, {integer}, {integer})\u00b0\nfound type \u201c(_, _)\u00b0\n\nIf we wanted to ignore one or more of the values in the tuple, we could\nuse _ or .., as you'll see in \u201cIgnoring Values in a Pattern\u201d on page 409. If\nthe problem is that we have too many variables in the pattern, the solution\nis to make the types match by removing variables so the number of variables\nequals the number of elements in the tuple.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 18.8,
                        "section_name": "Function Parameters",
                        "section_path": "./screenshots-images-2/chapter_18/section_8",
                        "images": [
                            "./screenshots-images-2/chapter_18/section_8/52bec95a-a164-455a-920e-cbdeb0df1c74.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nFunction Parameters\n\nFunction parameters can also be patterns. The code in Listing 18-6, which\ndeclares a function named foo that takes one parameter named x of type\n132, should by now look familiar.\n\nfn foo(x: 132) {\n// code goes here\n}\n\nListing 18-6: A function signature uses patterns in the parameters\n\nThe x part is a pattern! As we did with let, we could match a tuple in a\nfunction\u2019s arguments to the pattern. Listing 18-7 splits the values in a tuple\nas we pass it to a function.\n\nfn print_coordinates(&(x, y): &(132, i32)) {\nprintln!(\"Current location: ({}, {})\", x, y);\n\nfn main() {\nlet point = (3, 5);\nprint_coordinates(&point) ;\n}\n\nListing 18-7: A function with parameters that destructure a tuple\n\nThis code prints Current location: (3, 5). The values &(3, 5) match the\npattern &(x, y), so x is the value 3 and y is the value 5.\n\nWe can also use patterns in closure parameter lists in the same way as\nin function parameter lists, because closures are similar to functions, as\ndiscussed in Chapter 13.\n\nAt this point, you've seen several ways of using patterns, but patterns\ndon\u2019t work the same in every place we can use them. In some places, the\npatterns must be irrefutable; in other circumstances, they can be refutable.\nWe'll discuss these two concepts next.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 18.9,
                        "section_name": "Refutability: Whether a Pattern Might Fail to Match",
                        "section_path": "./screenshots-images-2/chapter_18/section_9",
                        "images": [
                            "./screenshots-images-2/chapter_18/section_9/15d13977-bc87-4c94-8a03-52e3118c74fe.png",
                            "./screenshots-images-2/chapter_18/section_9/92b7b146-6d3b-41c1-857e-635072577401.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Refutability: Whether a Pattern Might Fail to Match\n\nPatterns come in two forms: refutable and irrefutable. Patterns that will\nmatch for any possible value passed are irrefutable. An example would be x in\nthe statement let x = 5; because x matches anything and therefore cannot\nfail to match. Patterns that can fail to match for some possible value are refut-\nable, An example would be Some(x) in the expression if let Some(x) = a_value\nbecause if the value in the a_value variable is None rather than Some, the\nSome(x) pattern will not match.\n\nFunction parameters, let statements, and for loops can only accept\nirrefutable patterns, because the program cannot do anything meaningful\nwhen values don\u2019t match. The if let and while let expressions only accept\nrefutable patterns, because by definition they're intended to handle pos-\nsible failure: the functionality of a conditional is in its ability to perform\ndifferently depending on success or failure.\n\nIn general, you shouldn't have to worry about the distinction between\nrefutable and irrefutable patterns; however, you do need to be familiar\nwith the concept of refutability so you can respond when you see it in an\nerror message. In those cases, you'll need to change either the pattern or\nthe construct you're using the pattern with, depending on the intended\nbehavior of the code.\n\nLet\u2019s look at an example of what happens when we try to use a refutable\npattern where Rust requires an irrefutable pattern and vice versa. Listing 18-8\nshows a let statement, but for the pattern we've specified Some(x), a refutable\npattern. As you might expect, this code will not compile.\n\nlet Some(x) = some_option_value;\n\nListing 18-8: Attempting to use a refutable pattern with let\n\nIf some_option_value were a None value, it would fail to match the pattern\nSome(x), meaning the pattern is refutable. However, the let statement can\nonly accept an irrefutable pattern because there is nothing valid the code\ncan do with a None value. At compile time, Rust will complain that we've\ntried to use a refutable pattern where an irrefutable pattern is required:\n\nerror[E0005]: refutable pattern in local binding: \u201cNone\u201d not covered\n-->\n\n|\n3 | let Some(x) = some_option_value;\n| AAAAOAN Hattern \u201cNone not covered\n\nBecause we didn\u2019t cover (and couldn't cover!) every valid value with the\npattern Some(x), Rust rightfully produces a compiler error.\n\nTo fix the problem where we have a refutable pattern when an irre-\nfutable pattern is needed, we can change the code that uses the pattern:\ninstead of using let, we can use if let. Then if the pattern doesn\u2019t match,\nthe code will just skip the code in the curly brackets, giving it a way to con-\ntinue validly. Listing 18-9 shows how to fix the code in Listing 18-8.\n\nif let Some(x) = some_option value {\nprintln!(\"{}\", x);\n\nListing 18-9: Using if let and a block with refutable patterns instead of let\n\nWe've given the code an out! This code is perfectly valid, although it\nmeans we cannot use an irrefutable pattern without receiving an error.\nIf we give if let a pattern that will always match, such as x, as shown in\nListing 18-10, it will not compile.\n\nif let x= 5 {\nprintln!(\"{}\", x);\n\n5\nListing 18-10: Attempting to use an irrefutable pattern with if let\n\nRust complains that it doesn\u2019t make sense to use if let with an irrefut-\nable pattern:\n\nerror[E0162]: irrefutable if-let pattern\n--> <anon>:2:8\n\n|\n2| if letx=5{\n| * irrefutable pattern\n\nFor this reason, match arms must use refutable patterns, except for\nthe last arm, which should match any remaining values with an irrefutable\npattern. Rust allows us to use an irrefutable pattern in a match with only\none arm, but this syntax isn\u2019t particularly useful and could be replaced\nwith a simpler let statement.\n\nNow that you know where to use patterns and the difference between\nrefutable and irrefutable patterns, let\u2019s cover all the syntax we can use to\ncreate patterns.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 18.1,
                        "section_name": "Pattern Syntax",
                        "section_path": "./screenshots-images-2/chapter_18/section_10",
                        "images": [
                            "./screenshots-images-2/chapter_18/section_10/60bebd8c-f4ad-46cf-b256-eef93a814a45.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Pattern Syntax\n\nThroughout the book, you\u2019ve seen examples of many kinds of patterns. In\nthis section, we gather all the syntax valid in patterns and discuss why you\nmight want to use each one.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 18.11,
                        "section_name": "Matching Literals",
                        "section_path": "./screenshots-images-2/chapter_18/section_11",
                        "images": [
                            "./screenshots-images-2/chapter_18/section_11/3cfe5866-a929-4b61-a8ee-4de5c17bbfce.png",
                            "./screenshots-images-2/chapter_18/section_11/b59df2db-8cb6-427c-b8a1-ba4dcadce54d.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Matching Literals\n\nAs you saw in Chapter 6, you can match patterns against literals directly.\nThe following code gives some examples:\n\nlet x = 1;\nmatch x {\n\n1 => println!(\"one\"),\n2 => println! (\"two\"),\n\n3 => println!(\"three\"),\n_ => println! (\"anything\"),\n}\n\nThis code prints one because the value in x is 1. This syntax is useful when\nyou want your code to take an action if it gets a particular concrete value.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 18.12,
                        "section_name": "Matching Named Variables",
                        "section_path": "./screenshots-images-2/chapter_18/section_12",
                        "images": [
                            "./screenshots-images-2/chapter_18/section_12/886e2792-31bf-4065-a019-358029b4b136.png",
                            "./screenshots-images-2/chapter_18/section_12/264df60d-65d1-4208-8b45-d0b76a486542.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nMatching Named Variables\n\nNamed variables are irrefutable patterns that match any value, and we've\nused them many times in the book. However, there is a complication when\nyou use named variables in match expressions. Because match starts a new\nscope, variables declared as part of a pattern inside the match expression\nwill shadow those with the same name outside the match construct, as is\n\nthe case with all variables. In Listing 18-11, we declare a variable named x\nwith the value Some(5) and a variable y with the value 10. We then create a\nmatch expression on the value x. Look at the patterns in the match arms and\nprintln! at the end and try to figure out what the code will print before run-\nning this code or reading further.\n\n@ let x = Some(5);\n= 10;\n\nmatch x {\n\u00a9 Some(50) => println!(\"Got 50\"),\n\u00a9 Some(y) => println!(\"Matched, y = {:?}\", y),\n\u00a9 => println!(\"Default case, x = {:?}\", x),\n}\n\n@ println!(\"at the end: x = {:?}, y = {:?}\", x, y);\n}\n\nListing 18-11: A match expression with an arm that introduces a shadowed variable y\n\nLet's walk through what happens when the match expression runs. The\npattern in the first match arm \u00ae doesn\u2019t match the defined value of x @, so\nthe code continues.\n\nThe pattern in the second match arm \u00ae introduces a new variable\nnamed y that will match any value inside a Some value. Because we're in a\nnew scope inside the match expression, this is a new y variable, not the y\nwe declared at the beginning with the value 10 @. This new y binding will\nmatch any value inside a Some, which is what we have in x. Therefore, this\nnew y binds to the inner value of the Some in x. That value is 5, so the expres-\nsion for that arm executes and prints Matched, y = 5.\n\nIfx had been a None value instead of Some(5), the patterns in the first two\narms wouldn't have matched, so the value would have matched to the under-\nscore \u00ae. We didn\u2019t introduce the x variable in the pattern of the underscore\narm, so the x in the expression is still the outer x that hasn't been shadowed.\nIn this hypothetical case, the match would print Default case, x = None.\n\nWhen the match expression is done, its scope ends, and so does the scope\nof the inner y. The last println! \u00a9 produces at the end: x = Some(5), y = 10.\n\nTo create a match expression that compares the values of the outer x\nand y, rather than introducing a shadowed variable, we would need to use\na match guard conditional instead. We'll talk about match guards later in\n\u201cExtra Conditionals with Match Guards\u201d on page 413.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 18.13,
                        "section_name": "Multiple Patterns",
                        "section_path": "./screenshots-images-2/chapter_18/section_13",
                        "images": [
                            "./screenshots-images-2/chapter_18/section_13/6bbacbda-45a9-45e3-ba13-94a65ab72deb.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Multiple Patterns\n\nIn match expressions, you can match multiple patterns using the | syntax,\nwhich means or. For example, the following code matches the value of x\nagainst the match arms, the first of which has an or option, meaning if the\nvalue of x matches either of the values in that arm, that arm\u2019s code will run:\n\nlet x = 1;\n\nmate! {\n\n2 => println! (\"one or two\"),\n> println! (\"three\"),\n\n> println! (\"anything\"),\n\nh\n1\n3\n\nuu\u2014*x\n\nThis code prints one or two.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 18.14,
                        "section_name": "Matching Ranges of Values with the ... Syntax",
                        "section_path": "./screenshots-images-2/chapter_18/section_14",
                        "images": [
                            "./screenshots-images-2/chapter_18/section_14/3970eaf6-3c4c-4306-aad5-cdd059513c81.png",
                            "./screenshots-images-2/chapter_18/section_14/584bffda-eee9-43d6-902b-c5533934c926.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Matching Ranges of Values with the ... Syntax\n\nThe ... syntax allows us to match to an inclusive range of values. In the\nfollowing code, when a pattern matches any of the values within the range,\nthat arm will execute:\n\nlet x = 5;\n\nmatch x {\n1... 5 => println!(\"one through five\"),\n_ => println! (\"something else\"),\n\nIfx is 1, 2, 3, 4, or 5, the first arm will match. This syntax is more conve-\nnient than using the | operator to express the same idea; instead of 1 ... 5,\nwe would have to specify 1 | 2 | 3 | 4 | 5 ifwe used |. Specifying a range\nis much shorter, especially if we want to match, say, any number between 1\nand 1,000!\n\nRanges are only allowed with numeric values or char values, because\nthe compiler checks that the range isn\u2019t empty at compile time. The only\ntypes for which Rust can tell whether a range is empty or not are char and\nnumeric values.\n\nHere is an example using ranges of char values:\n\nlet x = \u2018c';\n\nmatch x {\n\n\u2018a\u2019 ... \u2018'j' => println! (\u201cearly ASCII letter\"),\n\"k' ... 'z' => println! (\"late ASCII letter\"),\n_ => println! (\"something else\"),\n\nRust can tell that c is within the first pattern\u2019s range and prints early\nASCII letter.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 18.15,
                        "section_name": "Destructuring to Break Apart Values",
                        "section_path": "./screenshots-images-2/chapter_18/section_15",
                        "images": [
                            "./screenshots-images-2/chapter_18/section_15/ad84a189-13e5-4020-8653-3bea738e5418.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Destructuring to Break Apart Values\n\nWe can also use patterns to destructure structs, enums, tuples, and refer-\nences to use different parts of these values. Let\u2019s walk through each value.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 18.16,
                        "section_name": "Destructuring Structs",
                        "section_path": "./screenshots-images-2/chapter_18/section_16",
                        "images": [
                            "./screenshots-images-2/chapter_18/section_16/ebadc353-f633-4b07-b3b0-25bd9338749d.png",
                            "./screenshots-images-2/chapter_18/section_16/e251e8a8-5b2a-4a20-aa2d-57447d40a723.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nsr\u00a2/main.rs\n\nDestructuring Structs\n\nListing 18-12 shows a Point struct with two fields, x and y, that we can break\napart using a pattern with a let statement.\n\nstruct Point {\n\nx: 132,\ny: 132,\n\n}\n\nfn main() {\nlet p = Point { x: 0, y: 7 };\nlet Point { x: a, y: b } = p;\nassert_eq!(0, a);\nassert_eq!(7, b);\n\n}\n\nListing 18-12: Destructuring a struct\u2019s fields into separate variables\n\nThis code creates the variables a and b that match the values of the x and\ny fields of the p struct. This example shows that the names of the variables in\nthe pattern don\u2019t have to match the field names of the struct. But it\u2019s com-\nmon to want the variable names to match the field names to make it easier\nto remember which variables came from which fields.\n\nBecause having variable names match the fields is common and because\nwriting let Point { x: x, y: y } = p; contains a lot of duplication, there is a\nshorthand for patterns that match struct fields: you only need to list the name\nof the struct field, and the variables created from the pattern will have the\nsame names. Listing 18-13 shows code that behaves in the same way as the\ncode in Listing 18-12, but the variables created in the let pattern are x and y\ninstead of a and b.\n\nstruct Point {\nx: 132,\ny: i32,\n\nsrc/main.rs\n\nfn main() {\nlet p = Point { x: 0, y: 7 };\n\nlet Point { x, y } = p;\nassert_eq!(0, x);\nassert_eq!(7, y);\n\n}\n\nListing 18-13: Destructuring struct fields using struct field shorthand\n\nThis code creates the variables x and y that match the x and y fields of\nthe p variable. The outcome is that the variables x and y contain the values\nfrom the p struct.\n\nWe can also destructure with literal values as part of the struct pattern\nrather than creating variables for all the fields. Doing so allows us to test\nsome of the fields for particular values while creating variables to destruc-\nture the other fields.\n\nListing 18-14 shows a match expression that separates Point values into\nthree cases: points that lie directly on the x axis (which is true when y = 0),\non the y axis (x = 0), or neither.\n\nfn main() {\nlet p = Point { x: 0, y: 7 };\n\nmatch p {\nPoint { x, y: 0 } => println!(\"On the x axis at {}\", x),\nPoint { x: 0, y } => println!(\"On the y axis at {}\", y),\nPoint { x, y } => println!(\"On neither axis: ({}, {})\", x, y),\n\n}\nFe\n\nListing 18-14: Destructuring and matching literal values in one pattern\n\nThe first arm will match any point that lies on the x axis by specifying\nthat the y field matches if its value matches the literal 0. The pattern still\ncreates an x variable that we can use in the code for this arm.\n\nSimilarly, the second arm matches any point on the y axis by specifying\nthat the x field matches if its value is 0 and creates a variable y for the value\nof the y field. The third arm doesn\u2019t specify any literals, so it matches any\nother Point and creates variables for both the x and y fields.\n\nIn this example, the value p matches the second arm by virtue of x con-\ntaining a 0, so this code will print On the y axis at 7.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 18.17,
                        "section_name": "Destructuring Enums",
                        "section_path": "./screenshots-images-2/chapter_18/section_17",
                        "images": [
                            "./screenshots-images-2/chapter_18/section_17/d37f8760-5ed2-473b-a54e-71bdbf99acde.png",
                            "./screenshots-images-2/chapter_18/section_17/64b9bd33-56b1-4e43-a7d3-d990a8b4aaf7.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Destructuring Enums\n\nWe've destructured enums earlier in this book, for example, when we\ndestructured Option<i32> in Listing 6-5 on page 107. One detail we haven't\nmentioned explicitly is that the pattern to destructure an enum should corre-\nspond to the way the data stored within the enum is defined. As an example,\nin Listing 18-15 we use the Message enum from Listing 6-2 on page 100 and\nwrite a match with patterns that will destructure each inner value.\n\nsrc/main.rs\n\nenum Message {\n\nQuit,\nMove { x: i32, y: i32 },\nWrite(String),\nChangeColor(i32, 132, 132),\n}\nfn main() {\n\n@ let msg = Message: :ChangeColor(0, 160, 255);\n\nmatch msg {\n\u00a9 Message: :Quit => {\nprintln!(\"The Quit variant has no data to destructure.\")\n},\n\n\u00a9 Message::Move { x, y } => {\nprintln!(\n\"Move in the x direction {} and in the y direction {}\",\nx\ny\n)3\n}\n\n\u00a9 Message: :Write(text) => println!(\"Text message: {}\", text),\n\u00a9 Message: :ChangeColor(r, g, b) => {\n\nprintln!(\n\"Change the color to red {}, green {}, and blue {}\",\nr,\n8\u00bb\nb\n)\n\n}\n\nListing 18-15: Destructuring enum variants that hold different kinds of values\n\nThis code will print Change the color to red 0, green 160, and blue 255.\nTry changing the value of msg @ to see the code from the other arms run.\n\nFor enum variants without any data, like Message: :Quit @, we can\u2019t\ndestructure the value any further. We can only match on the literal\nMessage: :Quit value, and no variables are in that pattern.\n\nFor struct-like enum variants, such as Message: :Move @, we can use a\npattern similar to the pattern we specify to match structs. After the variant\nname, we place curly brackets and then list the fields with variables so we\nbreak apart the pieces to use in the code for this arm. Here we use the short-\nhand form as we did in Listing 18-13.\n\nFor tuple-like enum variants, like Message: :Write that holds a tuple with\none element \u00a9 and Message: :ChangeColor that holds a tuple with three ele-\nments \u00a9, the pattern is similar to the pattern we specify to match tuples.\nThe number of variables in the pattern must match the number of elements\nin the variant we're matching.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 18.18,
                        "section_name": "Destructuring Nested Structs and Enums",
                        "section_path": "./screenshots-images-2/chapter_18/section_18",
                        "images": [
                            "./screenshots-images-2/chapter_18/section_18/7eb18d6a-51c6-462a-9eea-6a0c0b756811.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Destructuring Nested Structs and Enums\n\nUntil now, all our examples have been matching structs or enums that were\none level deep. Matching can work on nested items too!\n\nFor example, we can refactor the code in Listing 18-15 to support RGB\nand HSV colors in the ChangeColor message, as shown in Listing 18-16.\n\nenum Color {\nRgb(i32, i32, i132),\nHsv(i32, i32, i32)\n}\n\nenum Message {\nQuit,\nMove { x: 132, y: 132 },\nWrite(String),\nChangeColor(Color),\n\n}\n\nfn main() {\nlet msg = Message: :ChangeColor(Color::Hsv(0, 160, 255));\n\nmatch msg {\nMessage: :ChangeColor(Color::Rgb(r, g, b)) => {\nprintln!(\n\u201cChange the color to red {}, green {}, and blue {}\",\nqT,\n\n8\nb\n\n)\n},\nMessage: :ChangeColor(Color::Hsv(h, s, v)) => {\nprintln!(\n\u201cChange the color to hue {}, saturation {}, and value {}\",\nh,\ns,\nv\n)\n}\n-? 0\n}\n\nListing 18-16: Matching on nested enums\n\nThe pattern of the first arm in the match expression matches a\nMessage: :ChangeColor enum variant that contains a Color: :Rgb variant; then\nthe pattern binds to the three inner i32 values. The pattern of the second\narm also matches a Message: :ChangeColor enum variant, but the inner enum\nmatches the Color: :Hsv variant instead. We can specify these complex condi-\ntions in one match expression, even though two enums are involved.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 18.19,
                        "section_name": "Destructuring Structs and Tuples",
                        "section_path": "./screenshots-images-2/chapter_18/section_19",
                        "images": [
                            "./screenshots-images-2/chapter_18/section_19/d295bc10-0c14-4c4e-a395-567f736384d4.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Destructuring Structs and Tuples\n\nWe can mix, match, and nest destructuring patterns in even more complex\nways. The following example shows a complicated destructure where we nest\nstructs and tuples inside a tuple and destructure all the primitive values out:\n\nlet ((feet, inches), Point {x, y}) = ((3, 10), Point { x: 3, y: -10 });\n\nThis code lets us break complex types into their component parts so we\ncan use the values we're interested in separately.\n\nDestructuring with patterns is a convenient way to use pieces of values,\nsuch as the value from each field in a struct, separately from each other.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 18.2,
                        "section_name": "Ignoring Values in a Pattern",
                        "section_path": "./screenshots-images-2/chapter_18/section_20",
                        "images": [
                            "./screenshots-images-2/chapter_18/section_20/fdffa18d-0c91-4bcc-bc69-619d65ab3527.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Ignoring Valves in a Pattern\n\nYou've seen that it\u2019s sometimes useful to ignore values in a pattern, such as\nin the last arm of a match, to get a catchall that doesn\u2019t actually do anything\nbut does account for all remaining possible values. There are a few ways\n\nto ignore entire values or parts of values in a pattern: using the _ pattern\n(which you've seen), using the _ pattern within another pattern, using a\nname that starts with an underscore, or using .. to ignore remaining parts\nof a value. Let\u2019s explore how and why to use each of these patterns.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 18.21,
                        "section_name": "Ignoring an Entire Value with _\n\nWAT? on Dd eho ne dD. eS oe |",
                        "section_path": "./screenshots-images-2/chapter_18/section_21",
                        "images": [
                            "./screenshots-images-2/chapter_18/section_21/1bd0f0fb-01fd-4811-bed0-5ab9bfb8f011.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nIgnoring an Entire Value with _\n\nWe've used the underscore (_) as a wildcard pattern that will match any\nvalue but not bind to the value. Although the _ pattern is especially useful\nas the last arm in a match expression, we can use it in any pattern, including\nfunction parameters, as shown in Listing 18-17.\n\nfn foo(_: i32, y: i32) {\nprintln!(\"This code only uses the y parameter: {}\", y);\n\nfn main() {\nfoo(3, 4);\n}\n\nListing 18-17: Using _ in a function signature\n\nThis code will completely ignore the value passed as the first argument, 3,\nand will print This code only uses the y parameter: 4.\n\nIn most cases when you no longer need a particular function parameter,\nyou would change the signature so it doesn\u2019t include the unused parameter.\nIgnoring a function parameter can be especially useful in some cases, for\nexample, when implementing a trait when you need a certain type signa-\nture but the function body in your implementation doesn\u2019t need one of the\nparameters. The compiler will then not warn about unused function param-\neters, as it would if you used a name instead.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 18.22,
                        "section_name": "Ignoring Parts of a Value with a Nested _",
                        "section_path": "./screenshots-images-2/chapter_18/section_22",
                        "images": [
                            "./screenshots-images-2/chapter_18/section_22/93ed1588-599c-432a-9f01-aa86e2c04b7b.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Ignoring Parts of a Value with a Nested _\n\nWe can also use _ inside another pattern to ignore just part of a value, for\nexample, when we want to test for only part of a value but have no use for the\nother parts in the corresponding code we want to run. Listing 18-18 shows\ncode responsible for managing a setting\u2019s value. The business requirements\nare that the user should not be allowed to overwrite an existing customiza-\ntion of a setting but can unset the setting and can give the setting a value if it\nis currently unset.\n\nlet mut setting_value = Some(5);\nlet new_setting_value = Some(10);\n\nmatch (setting value, new_setting value) {\n\n(Some(_), Some(_)) => {\nprintln!(\"Can't overwrite an existing customized value\");\n}\n\nof\nsetting value = new_setting_value;\n}\n\n}\nprintln!(\"setting is {:?}\", setting value);\n\nListing 18-18: Using an underscore within patterns that match Some variants when we don't\nneed to use the value inside the Some\n\nThis code will print Can't overwrite an existing customized value and\nthen setting is Some(5). In the first match arm, we don\u2019t need to match\non or use the values inside either Some variant, but we do need to test for\nthe case when setting_value and new_setting value are the Some variant. In\nthat case, we print why we're not changing setting_value, and it doesn\u2019t get\nchanged.\n\nIn all other cases (if either setting_value or new_setting_value are None)\nexpressed by the _ pattern in the second arm, we want to allow new_setting\n_value to become setting_value.\n\nWe can also use underscores in multiple places within one pattern to\nignore particular values. Listing 18-19 shows an example of ignoring the\nsecond and fourth values in a tuple of five items.\n\nlet numbers = (2, 4, 8, 16, 32);\n\nmatch numbers {\n(first, _, third, _, fifth) => {\nprintln!(\"Some numbers: {}, {}, {}\", first, third, fifth)\n\n2\n\n}\n\nListing 18-19: Ignoring multiple parts of a tuple\n\nThis code will print Some numbers: 2, 8, 32, and the values 4 and 16 will\nbe ignored.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 18.23,
                        "section_name": "Ignoring an Unused Variable by Starting Its Name with _",
                        "section_path": "./screenshots-images-2/chapter_18/section_23",
                        "images": [
                            "./screenshots-images-2/chapter_18/section_23/2963f788-6c4f-4090-b3bc-694e914a18bb.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nIgnoring an Unused Variable by Starting Its Name with _\n\nIf you create a variable but don\u2019t use it anywhere, Rust will usually issue a\nwarning because that could be a bug. But sometimes it\u2019s useful to create\n\na variable you won't use yet, such as when you're prototyping or just start-\ning a project. In this situation, you can tell Rust not to warn you about the\nunused variable by starting the name of the variable with an underscore. In\nListing 18-20, we create two unused variables, but when we run this code,\nwe should get a warning about only one of them.\n\nfn main() {\nlet _x = 5;\nlet y = 10;\n}\n\nlisting 18-20: Starting a variable name with an underscore to avoid getting unused variable\nwarnings\n\nHere we get a warning about not using the variable y, but we don\u2019t get a\nwarning about not using the variable preceded by the underscore.\n\nNote that there is a subtle difference between using only _ and using a\nname that starts with an underscore. The syntax _x still binds the value to\nthe variable, whereas _ doesn\u2019t bind at all. To show a case where this distinc-\ntion matters, Listing 18-21 will provide us with an error.\n\nlet s = Some(String::from(\"Hello!\"));\n\nif let Some(_s) = s {\nprintln!(\"found a string\");\n}\n\nprintln!(\"{:?}\", s);\n\nListing 18-21: An unused variable starting with an underscore still binds the value, which\nmight take ownership of the value\n\nWe'll receive an error because the s value will still be moved into _s,\nwhich prevents us from using s again. However, using the underscore by\nitself doesn\u2019t ever bind to the value. Listing 18-22 will compile without any\nerrors because s doesn\u2019t get moved into _.\n\nlet s = Some(String::from(\"Hello!\"));\nif let Some(_) = s {\nprintln!(\"found a string\");\n}\nprintln!(\"{:?}\", s);\n\nListing 18-22: Using an underscore does not bind the value\n\nThis code works just fine because we never bind s to anything; it isn\u2019t\nmoved.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 18.24,
                        "section_name": "Ignoring Remaining Parts of a Value with ..",
                        "section_path": "./screenshots-images-2/chapter_18/section_24",
                        "images": [
                            "./screenshots-images-2/chapter_18/section_24/00a138f6-e69b-45e9-84f8-2ff6e97fcde7.png",
                            "./screenshots-images-2/chapter_18/section_24/4d69e998-7264-4cbe-94ba-2ffe66f86cc5.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nsrc/main.rs\n\nIgnoring Remaining Parts of a Value with ..\n\nWith values that have many parts, we can use the .. syntax to use only a\nfew parts and ignore the rest, avoiding the need to list underscores for\neach ignored value. The .. pattern ignores any parts of a value that we\nhaven't explicitly matched in the rest of the pattern. In Listing 18-23, we\nhave a Point struct that holds a coordinate in three-dimensional space.\nIn the match expression, we want to operate only on the x coordinate and\nignore the values in the y and z fields.\n\nstruct Point {\nx: 132,\ny: i32,\nz: 132,\n\n}\n\nlet origin = Point { x: 0, y: 0, z: 0 };\n\nmatch origin {\nPoint { x, .. } => println!(\"x is {}\", x),\n}\n\nListing 18-23: Ignoring all fields of a Point except for x by using ..\n\nWe list the x value and then just include the .. pattern. This is quicker\nthan having to list y: _ and z: _, particularly when we're working with structs\nthat have lots of fields in situations where only one or two fields are relevant.\n\nThe syntax .. will expand to as many values as it needs to. Listing 18-24\nshows how to use .. with a tuple.\n\nfn main() {\nlet numbers = (2, 4, 8, 16, 32);\n\nmatch numbers {\n(first, .., last) => {\nprintln!(\"Some numbers: {}, {}\", first, last);\n\n2\n\n}\n\nListing 18-24: Matching only the first and last values in a tuple and ignoring all other values\n\nIn this code, the first and last value are matched with first and last.\nThe .. will match and ignore everything in the middle.\n\nHowever, using .. must be unambiguous. If it is unclear which values\nare intended for matching and which should be ignored, Rust will give us\nan error. Listing 18-25 shows an example of using .. ambiguously, so it will\nnot compile.\n\nfn main() {\nlet numbers = (2, 4, 8, 16, 32);\n\nmatch numbers {\n\n(.., second, ..) => {\nprintln!(\"Some numbers: {}\", second)\n}s\n\n}\n\nListing 18-25: An attempt to use .. in an ambiguous way\n\nWhen we compile this example, we get this error:\n\nerror: \u00a9... can only be used once per tuple or tuple struct pattern\n--> src/main.rs:5:22\n\n|\n5 | (.., second, ..) => {\n| AA\n\nIt\u2019s impossible for Rust to determine how many values in the tuple to\nignore before matching a value with second and then how many further values\nto ignore thereafter. This code could mean that we want to ignore 2, bind\nsecond to 4, and then ignore 8, 16, and 32; or that we want to ignore 2 and 4,\nbind second to 8, and then ignore 16 and 32; and so forth. The variable name\nsecond doesn\u2019t mean anything special to Rust, so we get a compiler error\nbecause using .. in two places like this is ambiguous.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 18.25,
                        "section_name": "Extra Conditionals with Match Guards",
                        "section_path": "./screenshots-images-2/chapter_18/section_25",
                        "images": [
                            "./screenshots-images-2/chapter_18/section_25/1df5619c-60fa-452d-85cf-4a4fbbabe07e.png",
                            "./screenshots-images-2/chapter_18/section_25/de285784-80be-41ff-ab28-fa17c23c43e9.png",
                            "./screenshots-images-2/chapter_18/section_25/7aa30459-5a18-4587-8af4-dabcd0f6505b.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Extra Conditionals with Match Guards\n\nA match guard is an additional if condition specified after the pattern in a\nmatch arm that must also match, along with the pattern matching, for that\narm to be chosen. Match guards are useful for expressing more complex\nideas than a pattern alone allows.\n\nThe condition can use variables created in the pattern. Listing 18-26\nshows a match where the first arm has the pattern Some(x) and also has a\nmatch guard of if x < 5.\n\nlet num = Some(4);\n\nmatch num {\nSome(x) if x < 5 => println!(\"less than five: {}\", x),\nSome(x) => println!(\"{}\", x),\nNone => (),\n\nListing 18-26: Adding a match guard to a pattern\n\nThis example will print less than five: 4. When num is compared to the\npattern in the first arm, it matches, because Some(4) matches Some(x). Then\nthe match guard checks whether the value in x is less than 5, and because it\nis, the first arm is selected.\n\nIf num had been Some(10) instead, the match guard in the first arm would\nhave been false because 10 is not less than 5. Rust would then go to the\nsecond arm, which would match because the second arm doesn\u2019t have a\nmatch guard and therefore matches any Some variant.\n\nsrc/main.rs\n\nThere is no way to express the if x < 5 condition within a pattern, so\nthe match guard gives us the ability to express this logic.\n\nIn the discussion of Listing 18-11, we mentioned that we could use\nmatch guards to solve our pattern-shadowing problem. Recall that a new\nvariable was created inside the pattern in the match expression instead of\nusing the variable outside the match. That new variable meant we couldn't\ntest against the value of the outer variable. Listing 18-27 shows how we can\nuse a match guard to fix this problem.\n\nlet x\nlet y\n\nfn main() {\n= sone(s)s\n\nmatch x {\nSome(50) => println!(\"Got 50\"),\nSome(n) if n == y => println!(\"Matched, n = {:?}\", n),\n_ => println! (\"Default case, x = {:?}\", x),\n\n}\n\nprintln!(\"at the end: x = {:?}, y = {:?}\", x, y);\n}\n\nListing 18-27: Using a match guard to test for equality with an outer variable\n\nThis code will now print Default case, x = Some(5). The pattern in the\nsecond match arm doesn\u2019t introduce a new variable y that would shadow\nthe outer y, meaning we can use the outer y in the match guard. Instead\nof specifying the pattern as Some(y), which would have shadowed the outer\ny, we specify Some(n). This creates a new variable n that doesn\u2019t shadow any-\nthing because there is no n variable outside the match.\n\nThe match guard if n == y is nota pattern and therefore doesn\u2019t intro-\nduce new variables. This y is the outer y rather than a new shadowed y, and\nwe can look for a value that has the same value as the outer y by comparing\nntoy.\n\nYou can also use the or operator | in a match guard to specify mul-\ntiple patterns; the match guard condition will apply to all the patterns.\nListing 18-28 shows the precedence of combining a match guard with a\npattern that uses |. The important part of this example is that the if y\nmatch guard applies to 4, 5, and 6, even though it might look like if y\nonly applies to 6.\n\nlet x = 4;\nlet y = false;\n\nmatch x {\n4|5 | 6 if y => println!(\"yes\"),\n_ => println! (\"no\"),\n\n}\n\nListing 18-28: Combining multiple patterns with a match guard\n\nThe match condition states that the arm matches only if the value of x\nis equal to 4, 5, or 6 and ify is true. When this code runs, the pattern of the\nfirst arm matches because x is 4, but the match guard if y is false, so the first\narm is not chosen. The code moves on to the second arm, which does match,\nand this program prints no. The reason is that the if condition applies to the\nwhole pattern 4 | 5 | 6, not only to the last value 6. In other words, the prece-\ndence of a match guard in relation to a pattern behaves like this:\n\n(4|5|6)ify=...\n\nrather than this:\n4|5| (6if y) =>...\n\nAfter running the code, the precedence behavior is evident: if the match\nguard were applied only to the final value in the list of values specified using\nthe | operator, the arm would have matched and the program would have\nprinted yes.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 18.26,
                        "section_name": "@ Bindings",
                        "section_path": "./screenshots-images-2/chapter_18/section_26",
                        "images": [
                            "./screenshots-images-2/chapter_18/section_26/925ac75f-b600-4cee-8a40-f525d87b7f2b.png",
                            "./screenshots-images-2/chapter_18/section_26/57b62bd6-6713-40ca-8558-7b0b151d2fc4.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "@ Bindings\n\nThe at operator (@) lets us create a variable that holds a value at the same\ntime we're testing that value to see whether it matches a pattern. Listing 18-29\nshows an example where we want to test whether a Message: :Hello id field is\nwithin the range 3...7. But we also want to bind the value to the variable\nid_variable so we can use it in the code associated with the arm. We could\nname this variable id, the same as the field, but for this example, we'll use a\ndifferent name.\n\nenum Message {\nHello { id: i32 },\n}\n\nlet msg = Message::Hello { id: 5 };\n\nmatch msg {\nMessage: :Hello { id: id_ variable @ 3...7 } => {\nprintln!(\"Found an id in range: {}\", id_variable)\nhs\nMessage::Hello { id: 10...12 } => {\nprintln!(\"Found an id in another range\")\nhs\n\nMessage: :Hello { id } => {\nprintln!(\"Found some other id: {}\", id)\n\n\u2019\n\n}\n\nListing 18-29: Using @ to bind to a value in a pattern while also testing it\n\nThis example will print Found an id in range: 5. By specifying id_variable\n@ before the range 3...7, we\u2019re capturing whatever value matched the range\nwhile also testing that the value matched the range pattern.\n\nIn the second arm, where we only have a range specified in the pattern,\nthe code associated with the arm doesn\u2019t have a variable that contains the\nactual value of the id field. The id field\u2019s value could have been 10, 11, or\n12, but the code that goes with that pattern doesn\u2019t know which it is. The\npattern code isn\u2019t able to use the value from the id field, because we haven't\nsaved the id value in a variable.\n\nIn the last arm, where we've specified a variable without a range, we\ndo have the value available to use in the arm\u2019s code in a variable named\nid. The reason is that we've used the struct field shorthand syntax. But we\nhaven't applied any test to the value in the id field in this arm, as we did\nwith the first two arms: any value would match this pattern.\n\nUsing @ lets us test a value and save it in a variable within one pattern.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 18.27,
                        "section_name": "Summary",
                        "section_path": "./screenshots-images-2/chapter_18/section_27",
                        "images": [
                            "./screenshots-images-2/chapter_18/section_27/a4f19e9a-13cf-4fb2-abce-54d780053e8c.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Summary\n\nRust\u2019s patterns are very useful in that they help distinguish between different\nkinds of data. When used in match expressions, Rust ensures your patterns\ncover every possible value, or your program won't compile. Patterns in let\nstatements and function parameters make those constructs more useful,\nenabling the destructuring of values into smaller parts at the same time as\nassigning to variables. We can create simple or complex patterns to suit our\nneeds.\n\nNext, for the penultimate chapter of the book, we'll look at some\nadvanced aspects of a variety of Rust\u2019s features.\n",
                        "extracted-code": ""
                    }
                ]
            },
            {
                "chapter_id": 19,
                "chapter_name": "ADVANCED FEATURES",
                "chapter_path": "./screenshots-images-2/chapter_19",
                "sections": [
                    {
                        "section_id": 19.1,
                        "section_name": "ADVANCED FEATURES",
                        "section_path": "./screenshots-images-2/chapter_19/section_1",
                        "images": [
                            "./screenshots-images-2/chapter_19/section_1/f5402119-2e5c-4c8b-8522-02b0055e2286.png",
                            "./screenshots-images-2/chapter_19/section_1/a6cad9e2-25a3-4597-8d72-2ddf245ae428.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "By now, you\u2019ve learned the most commonly\nused parts of the Rust programming lan-\nguage. Before we do one more project in\nChapter 20, we\u2019ll look at a few aspects of the\nlanguage you might run into every once in a while.\nYou can use this chapter as a reference for when you\n\nencounter any unknowns when using Rust. The features you'll learn to\nuse in this chapter are useful in very specific situations. Although you\nmight not reach for them often, we want to make sure you have a grasp\nof all the features Rust has to offer.\n\nIn this chapter, we'll cover:\n\nUnsafe Rust How to opt out of some of Rust\u2019s guarantees and take\nresponsibility for manually upholding those guarantees\n\nAdvanced traits Associated types, default type parameters, fully quali-\nfied syntax, supertraits, and the newtype pattern in relation to traits\nAdvanced types More about the newtype pattern, type aliases, the\nnever type, and dynamically sized types\n\nAdvanced functions and closures Function pointers and returning\nclosures\n\nMacros Ways to define code that defines more code at compile time\n\nIt\u2019s a panoply of Rust features with something for everyone! Let\u2019s dive in!\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 19.2,
                        "section_name": "Unsafe Rust",
                        "section_path": "./screenshots-images-2/chapter_19/section_2",
                        "images": [
                            "./screenshots-images-2/chapter_19/section_2/011c15f0-236f-4498-a13c-f8de4008486e.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Unsafe Rust\n\nAll the code we've discussed so far has had Rust\u2019s memory safety guarantees\nenforced at compile time. However, Rust has a second language hidden\ninside it that doesn\u2019t enforce these memory safety guarantees: it\u2019s called\nunsafe Rust and works just like regular Rust, but gives us extra superpowers.\n\nUnsafe Rust exists because, by nature, static analysis is conservative.\nWhen the compiler tries to determine whether or not code upholds the\nguarantees, it\u2019s better for it to reject some valid programs rather than\naccept some invalid programs. Although the code might be okay, as far as\nRust is able to tell, it\u2019s not! In these cases, you can use unsafe code to tell\nthe compiler, \u201cTrust me, I know what I\u2019m doing.\u201d The downside is that you\nuse it at your own risk: if you use unsafe code incorrectly, problems due to\nmemory unsafety, such as null pointer dereferencing, can occur.\n\nAnother reason Rust has an unsafe alter ego is that the underlying com-\nputer hardware is inherently unsafe. If Rust didn\u2019t let you do unsafe opera-\ntions, you couldn't do certain tasks. Rust needs to allow you to do low-level\nsystems programming, such as directly interacting with the operating system\nor even writing your own operating system. Indeed, working with low-level\nsystems programming is one of the goals of the language. Let's explore what\nwe can do with unsafe Rust and how to do it.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 19.3,
                        "section_name": "Unsafe Superpowers",
                        "section_path": "./screenshots-images-2/chapter_19/section_3",
                        "images": [
                            "./screenshots-images-2/chapter_19/section_3/6ca9dc1f-b1bf-4146-bc72-36ee83359768.png",
                            "./screenshots-images-2/chapter_19/section_3/d9a6991d-aadd-4eb4-b810-604f1e59c332.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Unsafe Superpowers\n\nTo switch to unsafe Rust, use the unsafe keyword and then start a new block\nthat holds the unsafe code. You can take four actions in unsafe Rust, called\nunsafe superpowers, that you can\u2019t in safe Rust. Those superpowers include\nthe ability to:\n\nDereference a raw pointer\n\nCall an unsafe function or method\nAccess or modify a mutable static variable\nImplement an unsafe trait\n\nIt\u2019s important to understand that unsafe doesn\u2019t turn off the borrow\n\nchecker or disable any other of Rust\u2019s safety checks: if you use a reference\nin unsafe code, it will still be checked. The unsafe keyword only gives you\naccess to these four features that are then not checked by the compiler for\nmemory safety. You'll still get some degree of safety inside of an unsafe block.\n\nIn addition, unsafe does not mean the code inside the block is necessarily\ndangerous or that it will definitely have memory safety problems: the intent\nis that as the programmer, you'll ensure the code inside an unsafe block will\naccess memory in a valid way.\n\nPeople are fallible, and mistakes will happen, but by requiring these\nfour unsafe operations to be inside blocks annotated with unsafe you'll\nknow that any errors related to memory safety must be within an unsafe\nblock. Keep unsafe blocks small; you'll be thankful later when you investi-\ngate memory bugs.\n\nTo isolate unsafe code as much as possible, it\u2019s best to enclose unsafe\ncode within a safe abstraction and provide a safe API, which we'll discuss\nlater in the chapter when we examine unsafe functions and methods. Parts\nof the standard library are implemented as safe abstractions over unsafe\ncode that has been audited. Wrapping unsafe code in a safe abstraction\nprevents uses of unsafe from leaking out into all the places that you or your\nusers might want to use the functionality implemented with unsafe code,\nbecause using a safe abstraction is safe.\n\nLet's look at each of the four unsafe superpowers in turn. We'll also\nlook at some abstractions that provide a safe interface to unsafe code.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 19.4,
                        "section_name": "Dereferencing a Raw Pointer",
                        "section_path": "./screenshots-images-2/chapter_19/section_4",
                        "images": [
                            "./screenshots-images-2/chapter_19/section_4/fd5c382b-13ab-4308-82e8-03b9e08544ab.png",
                            "./screenshots-images-2/chapter_19/section_4/5f848c98-3669-404d-b887-203e9906c8a0.png",
                            "./screenshots-images-2/chapter_19/section_4/00136511-2e34-4f66-b6bc-b069f2fd22a4.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Dereferencing a Raw Pointer\n\nIn \u201cDangling References\u201d on page 74, we mentioned that the compiler\nensures references are always valid. Unsafe Rust has two new types called\nraw pointers that are similar to references. As with references, raw pointers\ncan be immutable or mutable and are written as *const T and *mut T, respec-\ntively. The asterisk isn\u2019t the dereference operator; it\u2019s part of the type name.\nIn the context of raw pointers, immutable means that the pointer can\u2019t be\ndirectly assigned to after being dereferenced.\n\nDifferent from references and smart pointers, raw pointers:\n\ne Are allowed to ignore the borrowing rules by having both immutable\nand mutable pointers or multiple mutable pointers to the same location\n\ne Aren't guaranteed to point to valid memory\n\ne Are allowed to be null\n\n\u00a2 Don't implement any automatic cleanup\n\nBy opting out of having Rust enforce these guarantees, you can give up\nguaranteed safety in exchange for greater performance or the ability to inter-\nface with another language or hardware where Rust\u2019s guarantees don\u2019t apply.\n\nListing 19-1 shows how to create an immutable and a mutable raw\npointer from references.\n\nlet mut num = 5;\n\nlet ri = &num as *const i132;\nlet r2 = &mut num as *mut 132;\n\nListing 19-1: Creating raw pointers from references\n\nNotice that we don\u2019t include the unsafe keyword in this code. We can\ncreate raw pointers in safe code; we just can\u2019t dereference raw pointers\noutside an unsafe block, as you'll see in a bit.\n\nWe've created raw pointers by using as to cast an immutable and a\nmutable reference into their corresponding raw pointer types. Because\nwe created them directly from references guaranteed to be valid, we know\nthese particular raw pointers are valid, but we can\u2019t make that assumption\nabout just any raw pointer.\n\nNext, we'll create a raw pointer whose validity we can\u2019t be so certain\nof. Listing 19-2 shows how to create a raw pointer to an arbitrary location\nin memory. Trying to use arbitrary memory is undefined: there might be\ndata at that address or there might not, the compiler might optimize the\ncode so there is no memory access, or the program might error with a seg-\nmentation fault. Usually, there is no good reason to write code like this,\nbut it is possible.\n\nlet address = 0x012345usize;\nlet r = address as *const i132;\n\nListing 19-2: Creating a raw pointer to an arbitrary memory address\n\nRecall that we can create raw pointers in safe code, but we can\u2019t dereference\nraw pointers and read the data being pointed to. In Listing 19-3, we use the\ndereference operator * on a raw pointer that requires an unsafe block.\n\nlet mut num = 5;\n\nlet r1 = &num as *const i32;\nlet r2 = &mut num as *mut i132;\nunsafe {\n\nprintln!(\"r1 is: {}\", *r1);\nprintln!(\"r2 is: {}\", *1r2);\n}\n\nListing 19-3: Dereferencing raw pointers within an unsafe block\n\nCreating a pointer does no harm; it\u2019s only when we try to access the\nvalue that it points at that we might end up dealing with an invalid value.\n\nNote also that in Listings 19-1 and 19-3, we created *const i32 and *mut\ni32 raw pointers that both pointed to the same memory location, where num\nis stored. If we instead tried to create an immutable and a mutable refer-\nence to num, the code would not have compiled because Rust\u2019s ownership\nrules don\u2019t allow a mutable reference at the same time as any immutable\nreferences. With raw pointers, we can create a mutable pointer and an immu-\ntable pointer to the same location and change data through the mutable\npointer, potentially creating a data race. Be careful!\n\nWith all of these dangers, why would you ever use raw pointers? One\nmajor use case is when interfacing with C code, as you'll see in the next\n\nsection. Another case is when building up safe abstractions that the borrow\nchecker doesn\u2019t understand. We\u2019ll introduce unsafe functions and then\nlook at an example of a safe abstraction that uses unsafe code.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 19.5,
                        "section_name": "a\n\nCalling an Unsafe Function or Method",
                        "section_path": "./screenshots-images-2/chapter_19/section_5",
                        "images": [
                            "./screenshots-images-2/chapter_19/section_5/8514e771-70a2-436d-bb7d-28473e340d72.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Calling an Unsafe Function or Method\n\nThe second type of operation that requires an unsafe block is calls to\nunsafe functions. Unsafe functions and methods look exactly like regular\nfunctions and methods, but they have an extra unsafe before the rest of\nthe definition. The unsafe keyword in this context indicates the function\nhas requirements we need to uphold when we call this function, because\nRust can\u2019t guarantee we've met these requirements. By calling an unsafe\nfunction within an unsafe block, we\u2019re saying that we've read this func-\ntion\u2019s documentation and take responsibility for upholding the function's\ncontracts.\n\nHere is an unsafe function named dangerous that doesn\u2019t do anything in\nits body:\n\nunsafe fn dangerous() {}\n\nunsafe {\ndangerous ();\n\nWe must call the dangerous function within a separate unsafe block. If we\ntry to call dangerous without the unsafe block, we'll get an error:\n\nerror[E\u00a30133]: call to unsafe function requires unsafe function or block\n-->\n\n|\n4| dangerous();\n| AAAAAAAAAAON Call to unsafe function\n\nBy inserting the unsafe block around our call to dangerous, we're assert-\ning to Rust that we've read the function's documentation, we understand\nhow to use it properly, and we've verified that we\u2019re fulfilling the contract\nof the function.\n\nBodies of unsafe functions are effectively unsafe blocks, so to perform\nother unsafe operations within an unsafe function, we don\u2019t need to add\nanother unsafe block.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 19.6,
                        "section_name": "Creating a Safe Abstraction over Unsafe Code",
                        "section_path": "./screenshots-images-2/chapter_19/section_6",
                        "images": [
                            "./screenshots-images-2/chapter_19/section_6/f091e69e-d371-4508-b88a-ff6fc2a3c75f.png",
                            "./screenshots-images-2/chapter_19/section_6/d06ebb2c-657e-4c49-a30c-2ccfa1c56142.png",
                            "./screenshots-images-2/chapter_19/section_6/6f3c4c66-c348-4426-97c7-dd0c34458b5e.png",
                            "./screenshots-images-2/chapter_19/section_6/fd0e6d02-e10f-4549-9b38-964c7bacae3b.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Creating a Safe Abstraction over Unsafe Code\n\nJust because a function contains unsafe code doesn\u2019t mean we need to mark\nthe entire function as unsafe. In fact, wrapping unsafe code in a safe func-\ntion is a common abstraction. As an example, let\u2019s study a function from the\nstandard library, split_at_mut, that requires some unsafe code and explore\nhow we might implement it. This safe method is defined on mutable slices:\nit takes one slice and makes it two by splitting the slice at the index given as\nan argument. Listing 19-4 shows how to use split_at_mut.\n\nlet mut v = vec![1, 2, 3, 4, 5, 6];\nlet r = &mut v[..]J;\nlet (a, b) = r.split_at_mut(3);\n\nassert_eq!(a, &mut [1, 2, 3]);\nassert_eq!(b, &mut [4, 5, 6]);\n\nListing 19-4: Using the safe split_at_mut function\n\nWe can\u2019t implement this function using only safe Rust. An attempt might\nlook something like Listing 19-5, which won't compile. For simplicity, we'll\nimplement split_at_mut as a function rather than a method and only for slices\nof i32 values rather than for a generic type T.\n\nfn split_at_mut(slice: Smut [132], mid: usize) -> (&mut [i32], Smut [i32]) {\nlet len = slice.len();\n\nassert! (mid <= len);\n\n(&mut slice[..mid],\n&mut slice[mid..])\n}\n\nListing 19-5: An attempted implementation of split_at_mut using only safe Rust\n\nThis function first gets the total length of the slice. Then it asserts that\nthe index given as a parameter is within the slice by checking whether it\u2019s\nless than or equal to the length. The assertion means that if we pass an\nindex that is greater than the index to split the slice at, the function will\npanic before it attempts to use that index.\n\nThen we return two mutable slices in a tuple: one from the start of the\noriginal slice to the mid index and another from mid to the end of the slice.\n\nWhen we try to compile the code in Listing 19-5, we'll get an error:\n\nerror[E0499]: cannot borrow ~*slice\u2019 as mutable more than once at a time\n\n| (&mut slice[..mid],\n\nf wee ee first mutable borrow occurs here\n7) &mut slice[mid..])\n\n| a*e4* second mutable borrow occurs here\n\n|}\n\n| -\n\nfirst borrow ends here\n\nRust\u2019s borrow checker can't understand that we\u2019re borrowing different\nparts of the slice; it only knows that we're borrowing from the same slice\ntwice. Borrowing different parts of a slice is fundamentally okay because the\n\ntwo slices aren't overlapping, but Rust isn\u2019t smart enough to know this. When\n\nwe know code is okay, but Rust doesn\u2019t, it\u2019s time to reach for unsafe code.\nListing 19-6 shows how to use an unsafe block, a raw pointer, and some\n\ncalls to unsafe functions to make the implementation of split_at_mut work.\n\nuse std::slice;\n\nfn split_at_mut(slice: &mut [i32], mid: usize) -> (&mut [i32], &mut [i32]) {\n@ let len = slice. len();\n@ let ptr = slice.as_mut_ptr();\n\n\u00a9 assert! (mid <= len);\n\n\u00a9 unsafe {\n\u00a9 (slice::from_raw_parts_mut(ptr, mid),\n\u00ae slice::from_raw_parts_mut(ptr.offset(mid as isize), len - mid))\n}\n\n}\n\nListing 19-6: Using unsafe code in the implementation of the split_at_mut function\n\nRecall from \u201cThe Slice Type\u201d on page 75 that slices are a pointer to\nsome data and the length of the slice. We use the len method to get the\nlength of a slice \u00ae@ and the as_mut_ptr method to access the raw pointer of a\nslice \u00a9. In this case, because we have a mutable slice to i32 values, as_mut_ptr\nreturns a raw pointer with the type *mut 132, which we've stored in the vari-\nable ptr.\n\nWe keep the assertion that the mid index is within the slice \u00a9. Then we\nget to the unsafe code @: the slice::from_raw_parts_mut function takes a raw\npointer and a length, and it creates a slice. We use this function to create\na slice that starts from ptr and is mid items long @. Then we call the offset\nmethod on ptr with mid as an argument to get a raw pointer that starts at\nmid, and we create a slice using that pointer and the remaining number of\nitems after mid as the length \u00a9.\n\nThe function slice::from_raw_parts_mut is unsafe because it takes a raw\npointer and must trust that this pointer is valid. The offset method on raw\npointers is also unsafe, because it must trust that the offset location is also\na valid pointer. Therefore, we had to put an unsafe block around our calls\nto slice: :from_raw_parts_mut and offset so we could call them. By looking at\nthe code and by adding the assertion that mid must be less than or equal to\nlen, we can tell that all the raw pointers used within the unsafe block will be\nvalid pointers to data within the slice. This is an acceptable and appropriate\nuse of unsafe.\n\nNote that we don\u2019t need to mark the resulting split_at_mut function as\nunsafe, and we can call this function from safe Rust. We've created a safe\nabstraction to the unsafe code with an implementation of the function that\nuses unsafe code in a safe way, because it creates only valid pointers from the\ndata this function has access to.\n\nIn contrast, the use of slice: :from_raw_parts_mut in Listing 19-7 would\nlikely crash when the slice is used. This code takes an arbitrary memory\nlocation and creates a slice 10,000 items long.\n\nuse std::slice;\n\nlet address = 0x012345usize;\nlet r = address as *mut i32;\n\nlet slice: &[132] = unsafe {\nslice::from_raw_parts_mut(r, 10000)\nhs\n\nListing 19-7: Creating a slice from an arbitrary memory location\n\nWe don\u2019t own the memory at this arbitrary location, and there is\nno guarantee that the slice this code creates contains valid i32 values.\nAttempting to use slice as though it\u2019s a valid slice results in undefined\nbehavior.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 19.7,
                        "section_name": "Using extern Functions to Call External Code",
                        "section_path": "./screenshots-images-2/chapter_19/section_7",
                        "images": [
                            "./screenshots-images-2/chapter_19/section_7/a877239d-ae10-4192-b75d-a5c3e27652d2.png",
                            "./screenshots-images-2/chapter_19/section_7/cd12cda5-4e19-4643-a72e-b0469d2f8296.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nUsing extern Functions to Call External Code\n\nSometimes, your Rust code might need to interact with code written in\nanother language. For this, Rust has a keyword, extern, that facilitates the\ncreation and use of a Foreign Function Interface (FFI). An FF1 is a way for a\nprogramming language to define functions and enable a different (for-\neign) programming language to call those functions.\n\nListing 19-8 demonstrates how to set up an integration with the abs\nfunction from the C standard library. Functions declared within extern\nblocks are always unsafe to call from Rust code. The reason is that other\nlanguages don\u2019t enforce Rust\u2019s rules and guarantees, and Rust can\u2019t check\nthem, so responsibility falls on the programmer to ensure safety.\n\nextern \"C\" {\nfn abs(input: 132) -> 132;\n\n}\nfn main() {\nunsafe {\nprintln! (\"Absolute value of -3 according to C: {}\", abs(-3));\n}\n}\n\nListing 19-8: Declaring and calling an extern function defined in another language\n\nWithin the extern \"C\" block, we list the names and signatures of exter-\nnal functions from another language we want to call. The \"C\" part defines\nwhich application binary interface (ABI) the external function uses: the ABI\ndefines how to call the function at the assembly level. The \"C\" ABI is the\nmost common and follows the C programming language's ABI.\n\nCALLING RUST FUNCTIONS FROM OTHER LANGUAGES\n\nWe can also use extern to create an interface that allows other languages\n\nto call Rust functions. Instead of an extern block, we add the extern keyword\nand specify the ABI to use just before the fn keyword. We also need to add a\n#[no_mangle] annotation to tell the Rust compiler not to mangle the name of this\nfunction. Mangling is when a compiler changes the name we've given a func-\ntion to a different name that contains more information for other parts of the\ncompilation process to consume but is less human readable. Every program-\nming language compiler mangles names slightly differently, so for a Rust func-\n\ntion to be nameable by other languages, we must disable the Rust compiler\u2019s\nname mangling.\n\nIn the following example, we make the call_from_c function accessible\nfrom C code, after it's compiled to a shared library and linked from C:\n\n#[no_mangle]}\npub extern \"C\" fn call_from_c() {\n\nprintln!(\u201cJust called a Rust function from C!\");\n}\n\nThis usage of extern does not require unsafe.\n\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 19.8,
                        "section_name": "Accessing or Modifying a Mutable Static Variable",
                        "section_path": "./screenshots-images-2/chapter_19/section_8",
                        "images": [
                            "./screenshots-images-2/chapter_19/section_8/a134c902-476e-4083-8a65-09de2fc39f34.png",
                            "./screenshots-images-2/chapter_19/section_8/51f8f370-cba1-4b38-ab1c-8ebbe3e85fb6.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nAccessing or Modifying a Mutable Static Variable\n\nUntil now, we've not talked about global variables, which Rust does support\nbut can be problematic with Rust\u2019s ownership rules. If two threads are\naccessing the same mutable global variable, a data race can result.\n\nIn Rust, global variables are called static variables. Listing 19-9 shows an\nexample declaration and use of a static variable with a string slice as a value.\n\nstatic HELLO WORLD: &str = \u201cHello, world!\";\n\nfn main() {\nprintln!(\"name is: {}\", HELLO WORLD);\n}\n\nListing 19-9: Defining and using an immutable static variable\n\nStatic variables are similar to constants, which we discussed in \u201cDifferences\nBetween Variables and Constants\u201d on page 34. The names of static variables\nare in SCREAMING SNAKE CASE by convention, and we must annotate the variable\u2019s\ntype, which is &'static str in this example. Static variables can only store ref-\nerences with the \u2018static lifetime, which means the Rust compiler can figure\nout the lifetime; we don\u2019t need to annotate it explicitly. Accessing an immu-\ntable static variable is safe.\n\nConstants and immutable static variables might seem similar, but a\nsubtle difference is that values in a static variable have a fixed address\n\nsrc/main.rs\n\nin memory. Using the value will always access the same data. Constants,\non the other hand, are allowed to duplicate their data whenever they\nare used.\n\nAnother difference between constants and static variables is that static\nvariables can be mutable. Accessing and modifying mutable static variables\nis unsafe. Listing 19-10 shows how to declare, access, and modify a mutable\nstatic variable named COUNTER.\n\nstatic mut COUNTER: u32 = 0;\n\nfn add_to_count(inc: u32) {\nunsafe {\nCOUNTER += inc;\n\n}\n}\nfn main() {\nadd_to_count(3);\nunsafe {\nprintln!(\"COUNTER: {}\", COUNTER);\n}\n}\n\nListing 19-10: Reading from or writing to a mutable static variable is unsafe.\n\nAs with regular variables, we specify mutability using the mut keyword. Any\ncode that reads or writes from COUNTER must be within an unsafe block. This code\ncompiles and prints COUNTER: 3 as we would expect because it\u2019s single threaded.\nHaving multiple threads access COUNTER would likely result in data races.\n\nWith mutable data that is globally accessible, it\u2019s difficult to ensure there\nare no data races, which is why Rust considers mutable static variables to be\nunsafe. Where possible, it\u2019s preferable to use the concurrency techniques\nand thread-safe smart pointers we discussed in Chapter 16 so the compiler\nchecks that data accessed from different threads is done safely.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 19.9,
                        "section_name": "Implementing an Unsafe Trait",
                        "section_path": "./screenshots-images-2/chapter_19/section_9",
                        "images": [
                            "./screenshots-images-2/chapter_19/section_9/b80013a0-2ba8-4a5a-9b8f-66d4a053586a.png",
                            "./screenshots-images-2/chapter_19/section_9/d5ba5cb0-a6d3-405c-bf33-839a725b174b.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Implementing an Unsafe Trait\n\nThe final action that works only with unsafe is implementing an unsafe trait.\nA trait is unsafe when at least one of its methods has some invariant that the\ncompiler can\u2019t verify. We can declare that a trait is unsafe by adding the unsafe\nkeyword before trait and marking the implementation of the trait as unsafe\ntoo, as shown in Listing 19-11.\n\nunsafe trait Foo {\n// methods go here\n}\n\nunsafe impl Foo for i32 {\n// method implementations go here\n}\n\nListing 19-11: Defining and implementing an unsafe trait\n\nBy using unsafe impl, we're promising that we'll uphold the invariants\nthat the compiler can\u2019t verify.\n\nAs an example, recall the Sync and Send marker traits we discussed in\n\u201cExtensible Concurrency with the Sync and Send Traits\u201d on page 368: the\ncompiler implements these traits automatically if our types are composed\nentirely of Send and Sync types. If we implement a type that contains a type\nthat is not Send or Sync, such as raw pointers, and we want to mark that type\nas Send or Sync, we must use unsafe. Rust can\u2019t verify that our type upholds\nthe guarantees that it can be safely sent across threads or accessed from\nmultiple threads; therefore, we need to do those checks manually and indi-\ncate as such with unsafe.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 19.1,
                        "section_name": "When to Use Unsafe Code",
                        "section_path": "./screenshots-images-2/chapter_19/section_10",
                        "images": [
                            "./screenshots-images-2/chapter_19/section_10/c29b4334-b1d6-4d70-bdc9-84ec6f9e0283.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "When to Use Unsafe Code\n\nUsing unsafe to take one of the four actions (superpowers) just discussed\nisn\u2019t wrong or even frowned upon. But it is trickier to get unsafe code\ncorrect because the compiler can\u2019t help uphold memory safety. When you\nhave a reason to use unsafe code, you can do so, and having the explicit\nunsafe annotation makes it easier to track down the source of problems if\nthey occur.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 19.11,
                        "section_name": "Advanced Traits",
                        "section_path": "./screenshots-images-2/chapter_19/section_11",
                        "images": [
                            "./screenshots-images-2/chapter_19/section_11/39730687-5d37-459c-acd2-8a23867965f7.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Advanced Traits\n\nWe first covered traits in \u201cTraits: Defining Shared Behavior\u201d on page 182,\nbut as with lifetimes, we didn\u2019t discuss the more advanced details. Now that\nyou know more about Rust, we can get into the nitty-gritty.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 19.12,
                        "section_name": "Specifying Placeholder Types in Trait Definitions with Associated Types",
                        "section_path": "./screenshots-images-2/chapter_19/section_12",
                        "images": [
                            "./screenshots-images-2/chapter_19/section_12/ede080bf-24b3-4436-bb3e-8a83999fe40a.png",
                            "./screenshots-images-2/chapter_19/section_12/17e1dd18-d2ab-4a2c-9cb7-38e2d58c2323.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Specifying Placeholder Types in Trait Definitions with Associated Types\nAssociated types connect a type placeholder with a trait such that the trait\nmethod definitions can use these placeholder types in their signatures. The\nimplementor of a trait will specify the concrete type to be used in this type\u2019s\nplace for the particular implementation. That way, we can define a trait that\nuses some types without needing to know exactly what those types are until\nthe trait is implemented.\n\nWe've described most of the advanced features in this chapter as\nbeing rarely needed. Associated types are somewhere in the middle:\nthey\u2019re used more rarely than features explained in the rest of the book\nbut more commonly than many of the other features discussed in this\nchapter.\n\nOne example of a trait with an associated type is the Iterator trait that\nthe standard library provides. The associated type is named Item and stands\nin for the type of the values the type implementing the Iterator trait is\niterating over. In \u201cThe Iterator Trait and the next Method\u201d on page 277,\nwe mentioned that the definition of the Iterator trait is as shown in\nListing 19-12.\n\nsrc/lib.rs\n\npub trait Iterator {\ntype Item;\n\nfn next(&mut self) -> Option<Self::Item>;\n}\n\nListing 19-12: The definition of the Iterator trait that has an associated type Item\n\nThe type Item is a placeholder type, and the next method\u2019s definition\nshows that it will return values of type Option<Self::Item>. Implementors of\nthe Iterator trait will specify the concrete type for Item, and the next method\nwill return an Option containing a value of that concrete type.\n\nAssociated types might seem similar to generics, in that the latter allow\nus to define a function without specifying what types it can handle. So why\nuse associated types?\n\nLet's examine the difference between the two concepts with an example\nfrom Chapter 13 that implements the Iterator trait on the Counter struct. In\nListing 13-21 on page 282, we specified that the Item type was u32:\n\nimpl Iterator for Counter {\ntype Item = u32;\n\nfn next(&mut self) -> Option<Self::Item> {\n// --snip--\n\nThis syntax seems comparable to that of generics. So why not just\ndefine the Iterator trait with generics, as shown in Listing 19-13?\n\npub trait Iterator<T> {\nfn next (&mut self) -> Option<T>;\n}\n\nListing 19-13: A hypothetical definition of the Iterator trait using generics\n\nThe difference is that when using generics, as in Listing 19-13, we must\nannotate the types in each implementation; because we can also implement\nIterator<String> for Counter or any other type, we could have multiple imple-\nmentations of Iterator for Counter. In other words, when a trait has a generic\nparameter, it can be implemented for a type multiple times, changing the\nconcrete types of the generic type parameters each time. When we use the\nnext method on Counter, we would have to provide type annotations to indi-\ncate which implementation of Iterator we want to use.\n\nWith associated types, we don\u2019t need to annotate types because we can\u2019t\nimplement a trait on a type multiple times. In Listing 19-12 with the defini-\ntion that uses associated types, we can only choose what the type of Item will\nbe once, because there can only be one imp] Iterator for Counter. We don\u2019t\nhave to specify that we want an iterator of u32 values everywhere that we call\nnext on Counter.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 19.13,
                        "section_name": "Default Generic Type Parameters and Operator Overloading",
                        "section_path": "./screenshots-images-2/chapter_19/section_13",
                        "images": [
                            "./screenshots-images-2/chapter_19/section_13/c8786544-209b-4faa-85be-650e682296e7.png",
                            "./screenshots-images-2/chapter_19/section_13/7bb45835-7918-4a85-8f77-c4d385d47f27.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nDefault Generic Type Parameters and Operator Overloading\n\nWhen we use generic type parameters, we can specify a default concrete\ntype for the generic type. This eliminates the need for implementors of\nthe trait to specify a concrete type if the default type works. The syntax for\nspecifying a default type for a generic type is <PlaceholderType=ConcreteType>\nwhen declaring the generic type.\n\nA great example of a situation where this technique is useful is with\noperator overloading. Operator overloading is customizing the behavior of\nan operator (such as +) in particular situations.\n\nRust doesn\u2019t allow you to create your own operators or overload arbitrary\noperators. But you can overload the operations and corresponding traits\nlisted in std::ops by implementing the traits associated with the operator.\nFor example, in Listing 19-14 we overload the + operator to add two Point\ninstances together. We do this by implementing the Add trait on a Point struct.\n\nuse std::ops: :Add;\n\n#[derive(Debug, PartialEq)]\nstruct Point {\n\nx: 132,\n\ny: i32,\n\nimpl Add for Point {\ntype Output = Point;\n\nfn add(self, other: Point) -> Point {\nPoint {\nx: self.x + other.x,\ny: self.y + other.y,\n\n}\n}\n}\nfn main() {\nassert_eq!(Point { x: 1, y: 0 } + Point { x: 2, y: 3 },\nPoint { x: 3, y: 3 });\n}\n\nListing 19-14: Implementing the Add trait to overload the + operator for Point instances\n\nThe add method adds the x values of two Point instances and the y values\nof two Point instances to create a new Point. The Add trait has an associated\ntype named Output that determines the type returned from the add method.\n\nThe default generic type in this code is within the Add trait. Here is its\ndefinition:\n\ntrait Add<RHS=Self> {\ntype Output;\n\nfn add(self, rhs: RHS) -> Self: :Output;\n\nsre/lib.rs\n\nThis code should look generally familiar: a trait with one method and\nan associated type. The new part is RHS=Self: this syntax is called default type\nparameters. The RHS generic type parameter (short for \u201cright-hand side\u201d)\ndefines the type of the rhs parameter in the add method. If we don\u2019t specify\na concrete type for RHS when we implement the Add trait, the type of RHS will\ndefault to Self, which will be the type we're implementing Add on.\n\nWhen we implemented Add for Point, we used the default for RHS because\nwe wanted to add two Point instances. Let\u2019s look at an example of implement-\ning the Add trait where we want to customize the RHS type rather than using\nthe default.\n\nWe have two structs, Millimeters and Meters, holding values in different\nunits. We want to add values in millimeters to values in meters and have the\nimplementation of Add do the conversion correctly. We can implement Add\nfor Millimeters with Meters as the RHS, as shown in Listing 19-15.\n\nuse std::ops::Add;\n\nstruct Millimeters(u32);\nstruct Meters (u32);\n\nimp] Add<Meters> for Millimeters {\ntype Output = Millimeters;\n\nfn add(self, other: Meters) -> Millimeters {\nMillimeters(self.o + (other.o * 1000))\n}\n\n}\n\nListing 19-15: Implementing the Add trait on Millimeters to add Millimeters to Meters\n\nTo add Millimeters and Meters, we specify imp] Add<Meters> to set the\nvalue of the RHS type parameter instead of using the default of Self.\nYou'll use default type parameters in two main ways:\n\ne To extend a type without breaking existing code\ne To allow customization in specific cases most users won't need\n\nThe standard library\u2019s Add trait is an example of the second purpose:\nusually, you'll add two like types, but the Add trait provides the ability to\ncustomize beyond that. Using a default type parameter in the Add trait\ndefinition means you don\u2019t have to specify the extra parameter most of\nthe time. In other words, a bit of implementation boilerplate isn\u2019t needed,\nmaking it easier to use the trait.\n\nThe first purpose is similar to the second but in reverse: if you want to\nadd a type parameter to an existing trait, you can give it a default to allow\nextension of the functionality of the trait without breaking the existing\nimplementation code.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 19.14,
                        "section_name": "Fully Qualified Syntax for Disambiguation:\nCalling Methods with the Same Name",
                        "section_path": "./screenshots-images-2/chapter_19/section_14",
                        "images": [
                            "./screenshots-images-2/chapter_19/section_14/b77e0c05-f8a7-495a-8e67-c6c4e54a2b17.png",
                            "./screenshots-images-2/chapter_19/section_14/40bd4e7a-4246-446d-b596-aabc72a50212.png",
                            "./screenshots-images-2/chapter_19/section_14/14bfee46-2c5a-41d5-84f9-83a396893343.png",
                            "./screenshots-images-2/chapter_19/section_14/f647ade4-74d3-4a70-bf81-9ca00dd08b3a.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nFully Qualified Syntax for Disambiguation:\nCalling Methods with the Same Name\n\nNothing in Rust prevents a trait from having a method with the same name\nas another trait\u2019s method, nor does Rust prevent you from implementing both\ntraits on one type. It\u2019s also possible to implement a method directly on the\ntype with the same name as a method from a trait.\n\nWhen calling methods with the same name, you'll need to tell Rust\nwhich one you want to use. Consider the code in Listing 19-16 where we've\ndefined two traits, Pilot and Wizard, that both have a method called fly.\nWe then implement both traits on a type Human that already has a method\nnamed fly implemented on it. Each fly method does something different.\n\ntrait Pilot {\nfn fly(&self);\n}\n\ntrait Wizard {\nfn fly(&self) ;\n}\n\nstruct Human;\n\nimpl Pilot for Human {\nfn fly(&self) {\nprintln!(\"This is your captain speaking.\");\n}\n\n}\n\nimpl Wizard for Human {\nfn fly(&self) {\nprintln!(\"Up!\");\n\n}\n}\nimpl Human {\nfn fly(&self) {\nprintln!(\"*waving arms furiously*\");\n}\n}\n\nListing 19-16: Two traits are defined to have a fly method and are implemented on the\nHuman type, and a fly method is implemented on Human directly.\n\nWhen we call fly on an instance of Human, the compiler defaults to\ncalling the method that is directly implemented on the type, as shown in\nListing 19-17.\n\nsrc/main.rs\n\nsrc/main.rs\n\nsrc/main.rs\n\nfn main() {\nlet person = Human;\nperson. fly();\n\n}\n\nListing 19-17: Calling fly on an instance of Human\n\nRunning this code will print *waving arms furiously*, showing that Rust\ncalled the fly method implemented on Human directly.\n\nTo call the fly methods from either the Pilot trait or the Wizard trait,\nwe need to use more explicit syntax to specify which fly method we mean.\nListing 19-18 demonstrates this syntax.\n\nfn main() {\nlet person = Human;\nPilot: :fly(&person) ;\nWizard: :fly(&person) ;\n\nperson. fly();\n}\n\nListing 19-18: Specifying which trait\u2019s fly method we want to call\n\nSpecifying the trait name before the method name clarifies to Rust which\nimplementation of fly we want to call. We could also write Human: :fly(&person),\nwhich is equivalent to the person. fly() that we used in Listing 19-18, but this\nis a bit longer to write if we don\u2019t need to disambiguate.\n\nRunning this code prints the following:\n\nThis is your captain speaking.\nUp!\n*waving arms furiously*\n\nBecause the fly method takes a self parameter, if we had two types that\nboth implemented one trait, Rust could figure out which implementation of\na trait to use based on the type of self.\n\nHowever, associated functions that are part of traits don\u2019t have a self\nparameter. When two types in the same scope implement that trait, Rust\ncan\u2019t figure out which type you mean unless you use fully qualified syntax,\nwhich is the most specific we can be when calling a function. For example,\nthe Animal trait in Listing 19-19 has the associated function baby_name, the\nimplementation of Animal for the struct Dog, and the associated function\nbaby_name defined on Dog directly.\n\ntrait Animal {\n\nfn baby _name() -> String;\n}\nstruct Dog;\n\nimpl Dog {\nfn baby _name() -> String {\n\nsrc/main.rs\n\nString: :from(\"Spot\")\n}\n\nimpl Animal for Dog {\nfn baby_name() -> String {\nString: : from(\"puppy\")\n\n}\nfn main() {\n\nprintln!(\"A baby dog is called a {}\", Dog::baby_name());\n}\n\nListing 19-19: A trait with an associated function and a type with an associated function of\nthe same name that also implements the trait\n\nThis code is for an animal shelter that wants to name all puppies Spot,\nwhich is implemented in the baby_name associated function that is defined\non Dog. The Dog type also implements the trait Animal, which describes char-\nacteristics that all animals have. Baby dogs are called puppies, and that is\nexpressed in the implementation of the Animal trait on Dog in the baby_name\nfunction associated with the Animal trait.\n\nIn main, we call the Dog: :baby_name function, which calls the associated\nfunction defined on Dog directly. This code prints the following:\n\nA baby dog is called a Spot\n\nThis output isn\u2019t what we wanted. We want to call the baby_name function\nthat is part of the Animal trait that we implemented on Dog so the code prints\nA baby dog is called a puppy. The technique of specifying the trait name that\nwe used in Listing 19-18 doesn\u2019t help here; if we change main to the code in\nListing 19-20, we'll get a compilation error.\n\nfn main() {\nprintln!(\"A baby dog is called a {}\", Animal: :baby name());\n}\n\nListing 19-20: Attempting to call the baby_name function from the Animal trait, but Rust\ndoesn\u2019t know which implementation to use\n\nBecause Animal: :baby_name is an associated function rather than a method,\nand thus doesn\u2019t have a self parameter, Rust can\u2019t figure out which imple-\nmentation of Animal: :baby_name we want. We'll get this compiler error:\n\nerror[E\u00a30283]: type annotations required: cannot resolve ~_: Animal\u201d\n--> src/main.rs:20:43\n\n|\n20 | println!(\"A baby dog is called a {}\", Animal::baby_name());\n\n| ARARAAAAARAAAAAAA\n|\n\nnote: required by \u201cAnimal: :baby _name~\n\nsrc/main.rs\n\nTo disambiguate and tell Rust that we want to use the implementation\nof Animal for Dog, we need to use fully qualified syntax. Listing 19-21 demon-\nstrates how to use fully qualified syntax.\n\nfn main() {\nprintln!(\"A baby dog is called a {}\", <Dog as Animal>::baby_name());\n}\n\nListing 19-21: Using fully qualified syntax to specify that we want to call the baby_name\nfunction from the Animal trait as implemented on Dog\n\nWe're providing Rust with a type annotation within the angle brackets,\nwhich indicates we want to call the baby_name method from the Animal trait as\nimplemented on Dog by saying that we want to treat the Dog type as an Animal\nfor this function call. This code will now print what we want:\n\nA baby dog is called a puppy\nIn general, fully qualified syntax is defined as follows:\n<Type as Trait>::function(receiver_if_method, next_arg, ...);\n\nFor associated functions, there would not be a receiver: there would only\nbe the list of other arguments. You could use fully qualified syntax every-\nwhere that you call functions or methods. However, you're allowed to omit\nany part of this syntax that Rust can figure out from other information in\nthe program. You need to use this more verbose syntax only when there are\nmultiple implementations that use the same name and Rust needs help to\nidentify which implementation you want to call.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 19.15,
                        "section_name": "Using Supertraits to Require One Trait\u2019s Functionality Within Another Trait",
                        "section_path": "./screenshots-images-2/chapter_19/section_15",
                        "images": [
                            "./screenshots-images-2/chapter_19/section_15/e5aadff4-33ea-47f7-8a5b-5b03a72a4cda.png",
                            "./screenshots-images-2/chapter_19/section_15/fa31a06c-63bb-451e-8fd0-d0c2c57d4bf1.png",
                            "./screenshots-images-2/chapter_19/section_15/5c675863-52af-4fb9-83dd-d75791787d80.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Using Supertraits to Require One Trait\u2019s Functionality Within Another Trait\nSometimes, you might need one trait to use another trait\u2019s functionality. In\nthis case, you need to rely on the dependent trait also being implemented.\nThe trait you rely on is a supertrait of the trait you're implementing.\n\nFor example, let\u2019s say we want to make an OutlinePrint trait with an\noutline_print method that will print a value framed in asterisks. That is,\ngiven a Point struct that implements Display to result in (x, y), when we\ncall outline_print on a Point instance that has 1 for x and 3 for y, it should\nprint the following:\n\nEEE\n* *\n\n* (1, 3) *\n* *\n\nERE\n\nIn the implementation of outline_print, we want to use the Display\ntrait\u2019s functionality. Therefore, we need to specify that the OutlinePrint\n\nsrc/main.rs\n\nsrc/main.rs\n\ntrait will work only for types that also implement Display and provide the\nfunctionality that OutlinePrint needs. We can do that in the trait definition\nby specifying OutlinePrint: Display. This technique is similar to adding\n\na trait bound to the trait. Listing 19-22 shows an implementation of the\nOutlinePrint trait.\n\nuse std::fmt;\n\ntrait OutlinePrint: fmt::Display {\nfn outline_print(a&self) {\n\nlet output = self.to_string();\nlet len = output.len();\nprintln!(\"{}\", \"*\".repeat(len + 4));\nprintln!(\"*{}*\", \" \".repeat(len + 2));\nprintln!(\"* {} *\", output);\nprintln!(\"*{}*\", \" \".repeat(len + 2));\nprintln!(\"{}\", \"*\".repeat(len + 4));\n\n}\n\nListing 19-22: Implementing the OutlinePrint trait that requires the functionality from Display\n\nBecause we've specified that OutlinePrint requires the Display trait, we\ncan use the to_string function that is automatically implemented for any\ntype that implements Display. If we tried to use to_string without adding a\ncolon and specifying the Display trait after the trait name, we'd get an error\nsaying that no method named to_string was found for the type &Self in the\ncurrent scope.\n\nLet's see what happens when we try to implement OutlinePrint on a type\nthat doesn\u2019t implement Display, such as the Point struct:\n\nstruct Point {\nx: 132,\ny: i32,\n\n}\n\nimpl OutlinePrint for Point {}\nWe get an error saying that Display is required but not implemented:\n\nerror[{E0277]: the trait bound \u201cPoint: std::fmt::Display\u201d is not satisfied\n--> src/main.rs:20:6\n\n|\n20 | impl OutlinePrint for Point {}\n\n| AAAAAAAAAAAN ~Doint\u201d cannot be formatted with the default formatter;\ntry using ~:?\u00b0> instead if you are using a format string\n\n= help: the trait \u201cstd::fmt::Display\u201d is not implemented for ~Point~\n\nsrc/main.rs\n\nTo fix this, we implement Display on Point and satisfy the constraint that\nOutlinePrint requires, like so:\n\nuse std:: fmt;\n\nimpl fmt::Display for Point {\nfn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\nwrite!(f, \"({}, {})\", self.x, self.y)\n\nThen implementing the OutlinePrint trait on Point will compile success-\nfully, and we can call outline_print on a Point instance to display it within an\noutline of asterisks.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 19.16,
                        "section_name": "Using the Newtype Pattern to Implement External Traits on External Types",
                        "section_path": "./screenshots-images-2/chapter_19/section_16",
                        "images": [
                            "./screenshots-images-2/chapter_19/section_16/2fa0a193-be6b-43f0-80e0-386e16efbd8e.png",
                            "./screenshots-images-2/chapter_19/section_16/a551d348-56c4-437a-a76b-69062699330d.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nUsing the Newtype Pattern to Implement External Traits on External Types\n\nIn \u201cImplementing a Trait on a Type\u201d on page 183, we mentioned the\norphan rule that states we\u2019re allowed to implement a trait on a type as\nlong as either the trait or the type are local to our crate. It\u2019s possible to get\naround this restriction using the newtype pattern, which involves creating\na new type in a tuple struct. (We covered tuple structs in \u201cUsing Tuple\nStructs Without Named Fields to Create Different Types\u201d on page 86.)\nThe tuple struct will have one field and be a thin wrapper around the\ntype we want to implement a trait for. Then the wrapper type is local to\nour crate, and we can implement the trait on the wrapper. Newtype is a\nterm that originates from the Haskell programming language. There is\nno runtime performance penalty for using this pattern, and the wrapper\ntype is elided at compile time.\n\nAs an example, let\u2019s say we want to implement Display on Vec<T>, which\nthe orphan rule prevents us from doing directly because the Display trait\nand the Vec<T> type are defined outside our crate. We can make a Wrapper\nstruct that holds an instance of Vec<T>; then we can implement Display on\nWrapper and use the Vec<T> value, as shown in Listing 19-23.\n\nuse std:: fmt;\nstruct Wrapper(Vec<String>) ;\nimpl fmt::Display for Wrapper {\n\nfn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\nwrite!(f, \"[{}]\", self.o.join(\", \"))\n\n}\n\n}\n\nfn main() {\nlet w = Wrapper(vec![String::from(\"hello\"), String: :from(\"world\")]);\nprintln!(\"w = {}\", w);\n\n}\n\nListing 19-23: Creating a Wrapper type around Vec<String> to implement Display\n\nThe implementation of Display uses self.0 to access the inner Vec<T>,\nbecause Wrapper is a tuple struct and Vec<T> is the item at index 0 in the\ntuple. Then we can use the functionality of the Display type on Wrapper.\n\nThe downside of using this technique is that Wrapper is a new type, so it\ndoesn\u2019t have the methods of the value it\u2019s holding. We would have to imple-\nment all the methods of Vec<T> directly on Wrapper such that the methods del-\negate to self.0, which would allow us to treat Wrapper exactly like a Vec<T>. If we\nwanted the new type to have every method the inner type has, implementing\nthe Deref trait (discussed in \u201cTreating Smart Pointers Like Regular References\nwith the Deref Trait\u201d on page 317) on the Wrapper to return the inner type\nwould be a solution. If we don\u2019t want the Wrapper type to have all the methods\nof the inner type\u2014for example, to restrict the Wrapper type\u2019s behavior\u2014we\nwould have to implement just the methods we do want manually.\n\nNow you know how the newtype pattern is used in relation to traits; it\u2019s\nalso a useful pattern even when traits are not involved. Let\u2019s switch focus\nand look at some advanced ways to interact with Rust\u2019s type system.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 19.17,
                        "section_name": "Advanced Types",
                        "section_path": "./screenshots-images-2/chapter_19/section_17",
                        "images": [
                            "./screenshots-images-2/chapter_19/section_17/295a331f-48b8-4648-bcd7-5a7ba56e9172.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Advanced Types\n\nThe Rust type system has some features that we've mentioned in this book\nbut haven't yet discussed. We'll start by discussing newtypes in general as\nwe examine why newtypes are useful as types. Then we'll move on to type\naliases, a feature similar to newtypes but with slightly different semantics.\nWe'll also discuss the | type and dynamically sized types.\n\nThe next section assumes you've read \u201cUsing the Newtype Pattern to Implement\nExternal Traits on External Types\u201d on page 436.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 19.18,
                        "section_name": "Using the Newtype Pattern for Type Safety and Abstraction",
                        "section_path": "./screenshots-images-2/chapter_19/section_18",
                        "images": [
                            "./screenshots-images-2/chapter_19/section_18/139c07f6-a696-4738-a72a-56f9648eeaa0.png",
                            "./screenshots-images-2/chapter_19/section_18/f0dc3661-8b57-47d0-bba4-71ae1ad09b35.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Using the Newtype Pattern for Type Safety and Abstraction\n\nThe newtype pattern is useful for tasks beyond those we've discussed so far,\nincluding statically enforcing that values are never confused and indicat-\ning the units of a value. You saw an example of using newtypes to indicate\nunits in Listing 19-15: recall that the Millimeters and Meters structs wrapped\nu32 values in a newtype. If we wrote a function with a parameter of type\nMillimeters, we couldn\u2019t compile a program that accidentally tried to call\nthat function with a value of type Meters or a plain u32.\n\nAnother use of the newtype pattern is in abstracting away some imple-\nmentation details of a type: the new type can expose a public API that is\ndifferent from the API of the private inner type if we used the new type\ndirectly to restrict the available functionality, for example.\n\nNewtypes can also hide internal implementation. For example, we could\nprovide a People type to wrap a HashMap<i32, String> that stores a person\u2019s ID\nassociated with their name. Code using People would only interact with the\npublic API we provide, such as a method to add a name string to the People\ncollection; that code wouldn't need to know that we assign an i32 ID to names\ninternally. The newtype pattern is a lightweight way to achieve encapsulation\n\nto hide implementation details, which we discussed in \u201cEncapsulation That\nHides Implementation Details\u201d on page 372.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 19.19,
                        "section_name": "Geating Type Synonyms with Type Aliases",
                        "section_path": "./screenshots-images-2/chapter_19/section_19",
                        "images": [
                            "./screenshots-images-2/chapter_19/section_19/78bf05ef-d2c9-4068-8028-b6282f3fea16.png",
                            "./screenshots-images-2/chapter_19/section_19/49219186-10e1-41e8-a625-13adf103cc7e.png",
                            "./screenshots-images-2/chapter_19/section_19/1bbde262-5b67-4e0f-b0a2-36ee2a1e2044.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Geating Type Synonyms with Type Aliases\n\nAlong with the newtype pattern, Rust provides the ability to declare a type\nalias to give an existing type another name. For this we use the type keyword.\nFor example, we can create the alias Kilometers to i32 like so:\n\ntype Kilometers = 132;\n\nNow, the alias Kilometers is a synonym for i32; unlike the Millimeters and\nMeters types we created in Listing 19-15, Kilometers is not a separate, new\ntype. Values that have the type Kilometers will be treated the same as values\nof type i32:\n\ntype Kilometers = 132;\n\nlet x: 132 = 5;\nlet y: Kilometers = 5;\n\nprintln!(\"x + y = {}\", x + y);\n\nBecause Kilometers and i32 are the same type, we can add values of both\ntypes and we can pass Kilometers values to functions that take i32 parameters.\nHowever, using this method, we don\u2019t get the type-checking benefits that we\nget from the newtype pattern discussed earlier.\n\nThe main use case for type synonyms is to reduce repetition. For\nexample, we might have a lengthy type like this:\n\nBox<dyn Fn() + Send + 'static>\n\nWriting this lengthy type in function signatures and as type annotations\nall over the code can be tiresome and error prone. Imagine having a project\nfull of code like that in Listing 19-24.\n\nlet f: Box<dyn Fn() + Send + \u2018static> = Box::new(|| println!(\"hi\"));\n\nfn takes_long type(f: Box<dyn Fn() + Send + 'static>) {\n\n// --snip--\n\n}\n\nfn returns_long type() -> Box<dyn Fn() + Send + \u2018static> {\n// --snip--\n\n}\n\nListing 19-24: Using a long type in many places\n\nA type alias makes this code more manageable by reducing the repeti-\ntion. In Listing 19-25, we've introduced an alias named Thunk for the verbose\ntype and can replace all uses of the type with the shorter alias Thunk.\n\ntype Thunk = Box<dyn Fn() + Send + \u2018static>;\nlet f: Thunk = Box::new(|| println!(\"hi\"));\n\nfn takes_long_ type(f: Thunk) {\n\n// --snip--\n\n}\n\nfn returns_long type() -> Thunk {\n// --snip--\n\n}\n\nListing 19-25: Introducing a type alias Thunk to reduce repetition\n\nThis code is much easier to read and write! Choosing a meaningful\nname for a type alias can help communicate your intent as well (thunk is a\nword for code to be evaluated at a later time, so it\u2019s an appropriate name for\na closure that gets stored).\n\nType aliases are also commonly used with the Result<T, E> type for reduc-\ning repetition. Consider the std::io module in the standard library. I/O oper-\nations often return a Result<T, \u00a3> to handle situations when operations fail to\nwork, This library has a std: :io::Error struct that represents all possible I/O\nerrors. Many of the functions in std: :io will be returning Result<T, E> where\nthe E is std: :io::Error, such as these functions in the Write trait:\n\nuse std::io::Error;\nuse std:: fmt;\n\npub trait Write {\nfn write(&mut self, buf: &[u8]) -> Result<usize, Error>;\nfn flush(&mut self) -> Result<(), Error>;\n\nfn write_all(&mut self, buf: &[u8]) -> Result<(), Error>;\nfn write_fmt(&mut self, fmt: fmt::Arguments) -> Result<(), Error>;\n\nThe Result<..., Error> is repeated a lot. As such, std::io has this type of\nalias declaration:\n\ntype Result<T> = Result<T, std::io::Error>;\n\nBecause this declaration is in the std::io module, we can use the fully\nqualified alias std: :io: :Result<T>\u2014 that is, a Result<T, E> with the E filled in as\nstd::io::Error. The Write trait function signatures end up looking like this:\n\npub trait Write {\nfn write(&mut self, buf: &[u8]) -> Result<usize>;\nfn flush(&mut self) -> Result<()>;\n\nfn write_all(&mut self, buf: &[u8]) -> Result<()>;\nfn write_fmt(&mut self, fmt: Arguments) -> Result<()>;\n\nThe type alias helps in two ways: it makes code easier to write and it\ngives us a consistent interface across all of std::io. Because it\u2019s an alias, it\u2019s\njust another Result<T, E>, which means we can use any methods that work\non Result<T, E> with it, as well as special syntax like the ? operator.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 19.2,
                        "section_name": "The Never Type That Never Returns",
                        "section_path": "./screenshots-images-2/chapter_19/section_20",
                        "images": [
                            "./screenshots-images-2/chapter_19/section_20/83710351-6f2c-48a0-a7b0-fd345f0c0b02.png",
                            "./screenshots-images-2/chapter_19/section_20/c2e90f56-e0ac-49cb-bfca-633f2436b540.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "The Never Type That Never Returns\n\nRust has a special type named ! that\u2019s known in type theory lingo as the\nempty type because it has no values. We prefer to call it the never type because\nit stands in the place of the return type when a function will never return.\nHere is an example:\n\nfn bar() -> | {\n// --snip--\n}\n\nThis code is read as \u201cthe function bar returns never.\u201d Functions that\nreturn never are called diverging functions. We can\u2019t create values of the\ntype ! so bar can never possibly return.\n\nBut what use is a type you can never create values for? Recall the\ncode from Listing 2-5 on page 28; we\u2019ve reproduced part of it here in\nListing 19-26.\n\nlet guess: u32 = match guess.trim().parse() {\nOk(num) => num,\nErr(_) => continue,\n\nA\n\nListing 19-26: A match with an arm that ends in continue\n\nAt the time, we skipped over some details in this code. In \u201cThe match\nControl Flow Operator\u201d on page 104, we discussed that match arms must all\nreturn the same type. So, for example, the following code doesn\u2019t work:\n\nlet guess = match guess.trim().parse() {\nOk(_) => 5,\nErr(_) => \"hello\",\n\nThe type of guess in this code would have to be an integer anda string,\nand Rust requires that guess have only one type. So what does continue return?\nHow were we allowed to return a u32 from one arm and have another arm\nthat ends with continue in Listing 19-26?\n\nAs you might have guessed, continue has a ! value. That is, when Rust\ncomputes the type of guess, it looks at both match arms, the former with a\nvalue of u32 and the latter with a ! value. Because ! can never have a value,\nRust decides that the type of guess is u32.\n\nThe formal way of describing this behavior is that expressions of type !\ncan be coerced into any other type. We're allowed to end this match arm\n\nwith continue because continue doesn\u2019t return a value; instead, it moves\ncontrol back to the top of the loop, so in the Err case, we never assign a\nvalue to guess.\n\nThe never type is useful with the panic! macro as well. Remember the\nunwrap function that we call on Option<T> values to produce a value or panic?\nHere is its definition:\n\nimpl<T> Option<T> {\npub fn unwrap(self) -> T {\nmatch self {\nSome(val) => val,\nNone => panic!(\"called \u201cOption::unwrap()\u201d on a \u201cNone\u201d value\"),\n\nIn this code, the same thing happens as in the match in Listing 19-26:\nRust sees that val has the type T and panic! has the type !, so the result of the\noverall match expression is T. This code works because panic! doesn\u2019t produce\na value; it ends the program. In the None case, we won't be returning a value\nfrom unwrap, so this code is valid.\n\nOne final expression that has the type ! is a loop:\n\nprint!(\"forever \");\n\nloop {\nprint! (\"and ever \");\n\nHere, the loop never ends, so ! is the value of the expression. However,\nthis wouldn't be true if we included a break, because the loop would termi-\nnate when it got to the break.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 19.21,
                        "section_name": "Dynamically Sized Types and the Sized Trait",
                        "section_path": "./screenshots-images-2/chapter_19/section_21",
                        "images": [
                            "./screenshots-images-2/chapter_19/section_21/daf81246-acd7-4568-a50e-0e79ac28f52d.png",
                            "./screenshots-images-2/chapter_19/section_21/0516885b-a154-45ec-a5a7-ad497330caa4.png",
                            "./screenshots-images-2/chapter_19/section_21/307f58af-50e3-453a-9231-8e04bad3367a.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Dynamically Sized Types and the Sized Trait\n\nDue to Rust\u2019s need to know certain details, such as how much space to allo-\ncate for a value of a particular type, there is a corner of its type system that\ncan be confusing: the concept of dynamically sized types. Sometimes referred\nto as DSTs or unsized types, these types let us write code using values whose\nsize we can know only at runtime.\n\nLet\u2019s dig into the details of a dynamically sized type called str, which\nwe've been using throughout the book. That's right, not &str, but str on its\nown is a DST. We can\u2019t know how long the string is until runtime, meaning\nwe can\u2019t create a variable of type str, nor can we take an argument of type\nstr. Consider the following code, which does not work:\n\nlet si: str = \"Hello there!\";\nlet s2: str = \"How's it going?\";\n\n\nRust needs to know how much memory to allocate for any value of a par-\nticular type, and all values of a type must use the same amount of memory. If\nRust allowed us to write this code, these two str values would need to take up\nthe same amount of space. But they have different lengths: s1 needs 12 bytes\nof storage and s2 needs 15. This is why it\u2019s not possible to create a variable\nholding a dynamically sized type.\n\nSo what do we do? In this case, you already know the answer: we make\nthe types of s1 and s2 a &str rather than a str. Recall that in \u201cString Slices\u201d\non page 77, we said the slice data structure stores the starting position\nand the length of the slice.\n\nSo although a &T is a single value that stores the memory address of\nwhere the T is located, a &str is two values: the address of the str and its\nlength. As such, we can know the size of a &str value at compile time: it\u2019s\ntwice the length of a usize. That is, we always know the size of a &str, no\nmatter how long the string it refers to is. In general, this is the way in which\ndynamically sized types are used in Rust: they have an extra bit of metadata\nthat stores the size of the dynamic information. The golden rule of dynami-\ncally sized types is that we must always put values of dynamically sized types\nbehind a pointer of some kind.\n\nWe can combine str with all kinds of pointers: for example, Box<str>\nor Re<str>. In fact, you've seen this before but with a different dynamically\nsized type: traits. Every trait is a dynamically sized type we can refer to by\nusing the name of the trait. In \u201cUsing Trait Objects That Allow for Values\nof Different Types\u201d on page 375, we mentioned that to use traits as trait\nobjects, we must put them behind a pointer, such as &dyn Trait or Box<dyn\nTrait> (Rc<dyn Trait> would work too).\n\nTo work with DSTs, Rust has a particular trait called the Sized trait to\ndetermine whether or not a type\u2019s size is known at compile time. This trait\nis automatically implemented for everything whose size is known at compile\ntime. In addition, Rust implicitly adds a bound on Sized to every generic\nfunction. That is, a generic function definition like this.\n\nfn generic<T>(t: T) {\n// --snip--\n}\n\nis actually treated as though we had written this:\n\nfn generic<T: Sized>(t: T) {\n// --snip--\n}\n\nBy default, generic functions will work only on types that have a known\nsize at compile time. However, you can use the following special syntax to\nrelax this restriction:\n\nfn generic<T: ?Sized>(t: &T) {\n// --snip--\n}\n\nA trait bound on ?Sized is the opposite of a trait bound on Sized: we\nwould read this as \u201cT may or may not be Sized.\u201d This syntax is only available\nfor Sized, not any other traits.\n\nAlso note that we switched the type of the t parameter from T to aT.\nBecause the type might not be Sized, we need to use it behind some kind of\npointer. In this case, we've chosen a reference.\n\nNext, we'll talk about functions and closures!\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 19.22,
                        "section_name": "Advanced Functions and Closures",
                        "section_path": "./screenshots-images-2/chapter_19/section_22",
                        "images": [
                            "./screenshots-images-2/chapter_19/section_22/1ba6af89-0ee3-4ab8-b072-e5c0d5cf5a0b.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Advanced Functions and Closures\n\nFinally, we'll explore some advanced features related to functions and clo-\nsures, which include function pointers and returning closures.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 19.23,
                        "section_name": "Function Pointers",
                        "section_path": "./screenshots-images-2/chapter_19/section_23",
                        "images": [
                            "./screenshots-images-2/chapter_19/section_23/63e711a1-5c0d-43e8-8502-8733bf3b35f9.png",
                            "./screenshots-images-2/chapter_19/section_23/7d118f78-1092-41f8-8fb4-c0b8bbb7e4a5.png",
                            "./screenshots-images-2/chapter_19/section_23/655f5e0b-2afb-4a00-b777-78ddabe746e3.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nFunction Pointers\n\nWe've talked about how to pass closures to functions; you can also pass reg-\nular functions to functions! This technique is useful when you want to pass\na function you've already defined rather than defining a new closure. Doing\nthis with function pointers will allow you to use functions as arguments to\nother functions. Functions coerce to the type fn (with a lowercase /), not to\nbe confused with the Fn closure trait. The fn type is called a function pointer.\nThe syntax for specifying that a parameter is a function pointer is similar to\nthat of closures, as shown in Listing 19-27.\n\nfn add_one(x: i32) -> i32 {\nx+1\n}\n\nfn do_twice(f: fn(i32) -> i132, arg: 132) -> i32 {\nf(arg) + f(arg)\n\n}\nfn main() {\nlet answer = do_twice(add_one, 5);\nprintln!(\"The answer is: {}\", answer);\n}\n\nListing 19-27: Using the fn type to accept a function pointer as an argument\n\nThis code prints The answer is: 12. We specify that the parameter f in\ndo_twice is an fn that takes one parameter of type i32 and returns an i32.\nWe can then call f in the body of do_twice. In main, we can pass the function\nname add_one as the first argument to do_twice.\n\nUnlike closures, fn is a type rather than a trait, so we specify fn as the\nparameter type directly rather than declaring a generic type parameter\nwith one of the Fn traits as a trait bound.\n\nFunction pointers implement all three of the closure traits (Fn, FnMut,\nand Fn0nce), so you can always pass a function pointer as an argument for a\n\nfunction that expects a closure. It\u2019s best to write functions using a generic\ntype and one of the closure traits so your functions can accept either func-\ntions or closures.\n\nAn example of where you would want to only accept fn and not closures\nis when interfacing with external code that doesn\u2019t have closures: C functions\ncan accept functions as arguments, but C doesn\u2019t have closures.\n\nAs an example of where you could use either a closure defined inline or\na named function, let\u2019s look at a use of map. To use the map function to turn a\nvector of numbers into a vector of strings, we could use a closure, like this:\n\nlet list_of_numbers = vec![1, 2, 3];\n\nlet list_of_strings: Vec<String> = list_of_numbers\n-iter()\n-map(|i| i.to_string())\n-collect();\n\nOr we could name a function as the argument to map instead of the\nclosure, like this:\n\nlet list_of_numbers = vec![1, 2, 3];\n\nlet list_of_strings: Vec<String> = list_of_numbers\n-iter()\n-map(ToString: :to_string)\n-collect();\n\nNote that we must use the fully qualified syntax that we talked about\nin \u201cAdvanced Traits\u201d on page 427 because there are multiple functions\navailable named to_string. Here, we're using the to_string function defined\nin the ToString trait, which the standard library has implemented for any type\nthat implements Display.\n\nSome people prefer this style, and some people prefer to use closures. They\nend up compiling to the same code, so use whichever style is clearer to you.\n\nWe have another useful pattern that exploits an implementation detail\nof tuple structs and tuple-struct enum variants. These types use () as initial-\nizer syntax, which looks like a function call. The initializers are actually\nimplemented as functions returning an instance that\u2019s constructed from\ntheir arguments. We can use these initializer functions as function pointers\nthat implement the closure traits, which means we can specify the initializer\nfunctions as arguments for methods that take closures, like so:\n\nenum Status {\n\nValue(u32),\nStop,\n\n}\n\nlet list_of_statuses: Vec<Status> =\n(0u32..20)\n\n-map(Status: : Value)\n-collect();\n\nHere we create Status: :Value instances using each u32 value in the range\nthat map is called on by using the initializer function of Status: :Value. Some\npeople prefer this style, and some people prefer to use closures. They com-\npile to the same code, so use whichever style is clearer to you.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 19.24,
                        "section_name": "Returning Closures",
                        "section_path": "./screenshots-images-2/chapter_19/section_24",
                        "images": [
                            "./screenshots-images-2/chapter_19/section_24/c7693bb0-92fa-4888-975b-c9a1baa1d274.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Returning Closures\nClosures are represented by traits, which means you can\u2019t return closures\ndirectly. In most cases where you might want to return a trait, you can\ninstead use the concrete type that implements the trait as the return value\nof the function. But you can\u2019t do that with closures because they don\u2019t have\na concrete type that is returnable; you're not allowed to use the function\npointer fn as a return type, for example.\n\nThe following code tries to return a closure directly, but it won't\ncompile:\n\nfn returns _closure() -> Fn(i32) -> i32 {\n|x} x+1\n}\n\nThe compiler error is as follows:\n\nerror[{E0277]: the trait bound ~std::ops::Fn(i32) -> i132 + \u2018static:\nstd::marker::Sized\u201d is not satisfied\n\n-->\n\n|\n1 | fn returns_closure() -> Fn(i32) -> i32 {\n\n| AMAAMAAAAHAMAK ~ std: zops::Fn(i32) -> 132 +\n\u2018static\u2019 does not have a constant size known at compile-time\n\n|\n\n= help: the trait \u201cstd::marker::Sized\u201d is not implemented for\n\u201cstd: :ops::Fn(i32) -> 132 + \u2018static\n\n= note: the return type of a function must have a statically known size\n\nThe error references the Sized trait again! Rust doesn\u2019t know how much\nspace it will need to store the closure. We saw a solution to this problem ear-\nlier. We can use a trait object:\n\nfn returns_closure() -> Box<dyn Fn(i32) -> i32> {\nBox: :new(|x| x + 1)\n}\n\nThis code will compile just fine. For more about trait objects, refer\nto \u201cUsing Trait Objects That Allow for Values of Different Types\u201d on\npage 375.\n\nNext, let\u2019s look at macros!\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 19.25,
                        "section_name": "Macros",
                        "section_path": "./screenshots-images-2/chapter_19/section_25",
                        "images": [
                            "./screenshots-images-2/chapter_19/section_25/ce4ab0ae-7cd4-445d-80de-747fe803aeb0.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Macros\n\nWe've used macros like println! throughout this book, but we haven't fully\nexplored what a macro is and how it works. The term macro refers to a\nfamily of features in Rust: declarative macros with macro_rules! and three\nkinds of procedural macros:\n\ne Custom #[derive] macros that specify code added with the derive attri-\nbute used on structs and enums.\n\ne  Attribute-like macros that define custom attributes usable on any item\n\ne  Function-like macros that look like function calls but operate on the\ntokens specified as their argument\n\nWe'll talk about each of these in turn, but first, let\u2019s look at why we even\nneed macros when we already have functions.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 19.26,
                        "section_name": "The Difference Between Macros and Functions",
                        "section_path": "./screenshots-images-2/chapter_19/section_26",
                        "images": [
                            "./screenshots-images-2/chapter_19/section_26/69e32175-da57-4931-a27d-266228777977.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "The Difference Between Macros and Functions\n\nFundamentally, macros are a way of writing code that writes other code,\nwhich is known as metaprogramming. In Appendix C, we discuss the derive\nattribute, which generates an implementation of various traits for you.\nWe've also used the println! and vec! macros throughout the book. All of\nthese macros expand to produce more code than the code you've written\nmanually.\n\nMetaprogramming is useful for reducing the amount of code you have\nto write and maintain, which is also one of the roles of functions. However,\nmacros have some additional powers that functions don\u2019t.\n\nA function signature must declare the number and type of param-\neters the function has. Macros, on the other hand, can take a variable\nnumber of parameters: we can call println! (\"hello\") with one argument or\nprintln!(\"hello {}\", name) with two arguments. Also, macros are expanded\nbefore the compiler interprets the meaning of the code, so a macro can, for\nexample, implement a trait on a given type. A function can\u2019t, because it gets\ncalled at runtime and a trait needs to be implemented at compile time.\n\nThe downside to implementing a macro instead of a function is that\nmacro definitions are more complex than function definitions because\nyou're writing Rust code that writes Rust code. Due to this indirection,\nmacro definitions are generally more difficult to read, understand, and\nmaintain than function definitions.\n\nAnother important difference between macros and functions is that\nyou must define macros or bring them into scope before you call them in a\nfile, as opposed to functions you can define anywhere and call anywhere.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 19.27,
                        "section_name": "Declarative Macros with macro_rules! for General Metaprogramming",
                        "section_path": "./screenshots-images-2/chapter_19/section_27",
                        "images": [
                            "./screenshots-images-2/chapter_19/section_27/ae57f5a7-bb22-452c-b022-13487db2bf15.png",
                            "./screenshots-images-2/chapter_19/section_27/79fab911-91a6-4fed-826b-68c729de856c.png",
                            "./screenshots-images-2/chapter_19/section_27/49c4f569-c08f-496d-be6f-411e8a8ae02b.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Declarative Macros with macro_rules! for General Metaprogramming\n\nThe most widely used form of macros in Rust is declarative macros. These are\nalso sometimes referred to as \u201cmacros by example,\u201d \u201cmacro_rules! macros,\u201d\nor just plain \u201cmacros.\u201d At their core, declarative macros allow you to write\nsomething similar to a Rust match expression. As discussed in Chapter 6,\n\nsrc/lib.rs\n\nmatch expressions are control structures that take an expression, compare\nthe resulting value of the expression to patterns, and then run the code\nassociated with the matching pattern. Macros also compare a value to\npatterns that are associated with particular code: in this situation, the\nvalue is the literal Rust source code passed to the macro; the patterns are\ncompared with the structure of that source code; and the code associated\nwith each pattern, when matched, replaces the code passed to the macro.\nThis all happens during compilation.\n\nTo define a macro, you use the macro_rules! construct. Let\u2019s explore how\nto use macro_rules! by looking at how the vec! macro is defined. Chapter 8\ncovered how we can use the vec! macro to create a new vector with particular\nvalues. For example, the following macro creates a new vector containing\nthree integers:\n\nlet v: Vec<u32> = vec![1, 2, 3];\n\nWe could also use the vec! macro to make a vector of two integers or a\nvector of five string slices. We wouldn't be able to use a function to do the\nsame because we wouldn't know the number or type of values up front.\n\nListing 19-28 shows a slightly simplified definition of the vec! macro.\n\n#[macro_export]\nmacro_rules! vec {\n\u00a9 ( $( $x:expr ),* ) => {\n{\n\nlet mut temp_vec = Vec::new();\n\n@ $(\n\u00a9 temp_vec.push($x\u00ae) ;\n)*\n\n@ temp_vec\n\n}\n\nhs\n}\n\nListing 19-28: A simplified version of the vec! macro definition\n\nThe actual definition of the vec! macro in the standard library includes code to preal-\nlocate the correct amount of memory up front. That code is an optimization that we\ndon\u2019t include here to make the example simpler.\n\nThe #{macro_export] annotation @ indicates that this macro should be\nmade available whenever the crate in which the macro is defined is brought\ninto scope. Without this annotation, the macro can\u2019t be brought into scope.\n\nWe then start the macro definition with macro_rules! and the name of\nthe macro we're defining without the exclamation mark \u00ae. The name, in\nthis case vec, is followed by curly brackets denoting the body of the macro\ndefinition.\n\nThe structure in the vec! body is similar to the structure of a match\nexpression. Here we have one arm with the pattern ( $( $x:expr ),* ),\nfollowed by => and the block of code associated with this pattern \u00a9. If the\n\npattern matches, the associated block of code will be emitted. Given that\nthis is the only pattern in this macro, there is only one valid way to match;\nany other pattern will result in an error. More complex macros will have\nmore than one arm.\n\nValid pattern syntax in macro definitions is different than the pattern\nsyntax covered in Chapter 18 because macro patterns are matched against\nRust code structure rather than values. Let\u2019s walk through what the pattern\npieces in Listing 19-28 mean; for the full macro pattern syntax, see the ref-\nerence at https://doc.rust-lang. org/stable/reference/macros.html.\n\nFirst, a set of parentheses encompasses the whole pattern. A dollar\nsign ($) is next, followed by a set of parentheses that captures values that\nmatch the pattern within the parentheses for use in the replacement code.\nWithin $() is $x:expr, which matches any Rust expression and gives the\nexpression the name $x.\n\nThe comma following $() indicates that a literal comma separator\ncharacter could optionally appear after the code that matches the code\nin $(). The * specifies that the pattern matches zero or more of whatever\nprecedes the *.\n\nWhen we call this macro with vec![1, 2, 3];, the $x pattern matches\nthree times with the three expressions 1, 2, and 3.\n\nNow let\u2019s look at the pattern in the body of the code associated with\nthis arm: temp_vec.push() \u00a9 within $()* @ @ is generated for each part that\nmatches $() in the pattern zero or more times depending on how many\ntimes the pattern matches. The $x @ is replaced with each expression\nmatched. When we call this macro with vec![1, 2, 3];, the code generated\nthat replaces this macro call will be the following:\n\nlet mut temp_vec = Vec::new();\ntemp_vec.push(1);\ntemp_vec.push(2);\ntemp_vec.push(3);\n\ntemp_vec\n\nWe've defined a macro that can take any number of arguments of any\ntype and can generate code to create a vector containing the specified\nelements.\n\nThere are some strange edge cases with macro_rules!. In the future,\nRust will have a second kind of declarative macro that will work in a similar\nfashion but fix some of these edge cases. After that update, macro_rules! will\nbe effectively deprecated. With this in mind, as well as the fact that most\nRust programmers will use macros more than write macros, we won't discuss\nmacro_rules! any further. To learn more about how to write macros, consult\nthe online documentation or other resources, such as The Little Book of Rust\nMacros at https://danielkeep.github.io/tlhorm/book/index.html.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 19.28,
                        "section_name": "Procedural Macros for Generating Code from Attributes",
                        "section_path": "./screenshots-images-2/chapter_19/section_28",
                        "images": [
                            "./screenshots-images-2/chapter_19/section_28/f82f1b58-20cf-40c6-9651-71dc6274d2a4.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/lib.rs\n\nProcedural Macros for Generating Code from Attributes\n\nThe second form of macros is procedural macros, which act more like func-\ntions (and are a type of procedure). Procedural macros accept some code\nas an input, operate on that code, and produce some code as an output\nrather than matching against patterns and replacing the code with other\ncode as declarative macros do.\n\nThe three kinds of procedural macros (custom derive, attribute-like,\nand function-like) all work in a similar fashion.\n\nWhen creating procedural macros, the definitions must reside in their\nown crate with a special crate type. This is for complex technical reasons\nthat we hope to eliminate in the future. Using procedural macros looks like\nthe code in Listing 19-29, where some_attribute is a placeholder for using a\nspecific macro.\n\nuse proc_macro;\n\n#[some_attribute]\npub fn some_name(input: TokenStream) -> TokenStream {\n\n}\n\nListing 19-29: An example of using a procedural macro\n\nThe function that defines a procedural macro takes a TokenStream as an\ninput and produces a TokenStream as an output. The TokenStream type is defined\nby the proc_macro crate that is included with Rust and represents a sequence of\ntokens. This is the core of the macro: the source code that the macro is oper-\nating on makes up the input TokenStream, and the code the macro produces is\nthe output TokenStream. The function also has an attribute attached to it that\nspecifies which kind of procedural macro we're creating. We can have mul-\ntiple kinds of procedural macros in the same crate.\n\nLet's look at the different kinds of procedural macros. We'll start with\na custom derive macro and then explain the small dissimilarities that make\nthe other forms different.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 19.29,
                        "section_name": "How to Write a Custom derive Macro",
                        "section_path": "./screenshots-images-2/chapter_19/section_29",
                        "images": [
                            "./screenshots-images-2/chapter_19/section_29/def90d58-9149-4eda-b380-2cbff9e89df2.png",
                            "./screenshots-images-2/chapter_19/section_29/c2bc4bb7-299a-4eb9-bbcf-ef967364807d.png",
                            "./screenshots-images-2/chapter_19/section_29/d0539eb3-19a4-4b7f-98f9-5ac4bcb6aaa5.png",
                            "./screenshots-images-2/chapter_19/section_29/bd549dbf-98f1-4301-b2ad-c48ec7a1c22e.png",
                            "./screenshots-images-2/chapter_19/section_29/91d32443-2ec4-4442-abc8-5d9822b318d4.png",
                            "./screenshots-images-2/chapter_19/section_29/fa7c6d7b-a4bd-4672-a2a6-1627b657c932.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "How fo Write a Custom derive Macro\n\nLet\u2019s create a crate named hello_macro that defines a trait named HelloMacro\nwith one associated function named hello_macro. Rather than making\n\nour crate users implement the HelloMacro trait for each of their types,\n\nwe'll provide a procedural macro so users can annotate their type with\n#[derive(HelloMacro)] to get a default implementation of the hello_macro\nfunction. The default implementation will print Hello, Macro! My name is\nTypeName! where TypeName is the name of the type on which this trait has been\ndefined. In other words, we'll write a crate that enables another program-\nmer to write code like Listing 19-30 using our crate.\n\nsrc/main.rs\n\nsrc/lib.rs\n\nuse hello macro: :HelloMacro;\nuse hello macro_derive: :HelloMacro;\n\n#[derive(HelloMacro) ]\nstruct Pancakes;\n\nfn main() {\nPancakes: :hello_macro();\n}\n\nListing 19-30: The code a user of our crate will be able to write when using our proce-\ndural macro\n\nThis code will print Hello, Macro! My name is Pancakes! when we're done.\nThe first step is to make a new library crate, like this:\n\n$ cargo new hello macro --lib\nNext, we'll define the HelloMacro trait and its associated function:\npub trait HelloMacro {\n\nfn hello_macro();\n}\n\nWe have a trait and its function. At this point, our crate user could\nimplement the trait to achieve the desired functionality, like so:\n\nuse hello macro: :HelloMacro;\nstruct Pancakes;\nimpl HelloMacro for Pancakes {\n\nfn hello _macro() {\nprintln!(\"Hello, Macro! My name is Pancakes!\");\n\n}\nfn main() {\n\nPancakes: :hello_macro();\n}\n\nHowever, they would need to write the implementation block for each\ntype they wanted to use with hello_macro; we want to spare them from hav-\ning to do this work.\n\nAdditionally, we can\u2019t yet provide the hello_macro function with default\nimplementation that will print the name of the type the trait is implemented\non: Rust doesn\u2019t have reflection capabilities, so it can\u2019t look up the type\u2019s\nname at runtime. We need a macro to generate code at compile time.\n\nThe next step is to define the procedural macro. At the time of this\nwriting, procedural macros need to be in their own crate. Eventually, this\nrestriction might be lifted. The convention for structuring crates and macro\n\nhello_macro_derive\n/Cargo.tom!\n\nhello_macro_derive\n\n/src/lib.rs\n\ncrates is as follows: for a crate named foo, a custom derive procedural macro\ncrate is called foo_derive. Let\u2019s start a new crate called hello_macro_derive\ninside our hello_macro project:\n\n$ cargo new hello macro_ derive --lib\n\nOur two crates are tightly related, so we create the procedural macro\ncrate within the directory of our hello_macro crate. If we change the trait\ndefinition in hello_macro, we'll have to change the implementation of the\nprocedural macro in hello_macro_derive as well. The two crates will need to\nbe published separately, and programmers using these crates will need\nto add both as dependencies and bring them both into scope. We could\ninstead have the hello_macro crate use hello_macro_derive as a dependency\nand re-export the procedural macro code. However, the way we've struc-\ntured the project makes it possible for programmers to use hello_macro\neven if they don\u2019t want the derive functionality.\n\nWe need to declare the hello_macro_derive crate as a procedural macro\ncrate. We'll also need functionality from the syn and quote crates, as you'll\nsee in a moment, so we need to add them as dependencies. Add the follow-\ning to the Cargo.toml file for hello_macro_derive:\n\n[lib]\nproc-macro = true\n\n[dependencies]\nsyn = \"0.14.4\"\nquote = \"0.6.3\"\n\nTo start defining the procedural macro, place the code in Listing 19-31\ninto your sr\u00a2/lib.rs file for the hello_macro_derive crate. Note that this code\nwon't compile until we add a definition for the imp]1_hello_macro function.\n\nextern crate proc_macro;\n\nuse crate: :proc_macro::TokenStream;\nuse quote: :quote;\nuse syn;\n\n#[proc_macro_derive(HelloMacro) ]\n\npub fn hello_macro_derive(input: TokenStream) -> TokenStream {\n// Construct a representation of Rust code as a syntax tree\n// that we can manipulate\nlet ast = syn::parse(input).unwrap();\n\n// Build the trait implementation\nimpl_hello_macro(&ast)\n}\n\nListing 19-31: Code that most procedural macro crates will require in order to process\nRust code\n\nNotice that we've split the code into the hello_macro_derive function,\nwhich is responsible for parsing the TokenStream, and the imp]_hello_macro\nfunction, which is responsible for transforming the syntax tree: this makes\nwriting a procedural macro more convenient. The code in the outer func-\ntion (hello_macro_derive in this case) will be the same for almost every proce-\ndural macro crate you see or create. The code you specify in the body of the\ninner function (impl_hello_macro in this case) will be different depending on\nyour procedural macro\u2019s purpose.\n\nWe've introduced three new crates: proc_macro, syn (available from\nAttps://crates.io/crates/syn), and quote (available from https://crates.io/crates/\nquote). The proc_macro crate comes with Rust, so we didn\u2019t need to add that\nto the dependencies in Cargo.toml. The proc_macro crate is the compiler\u2019s API\nthat allows us to read and manipulate Rust code from our code.\n\nThe syn crate parses Rust code from a string into a data structure that\nwe can perform operations on. The quote crate turns syn data structures\nback into Rust code. These crates make it much simpler to parse any sort of\nRust code we might want to handle: writing a full parser for Rust code is no\nsimple task.\n\nThe hello_macro_derive function will be called when a user of our library\nspecifies #[derive(HelloMacro)] on a type. This is possible because we've\nannotated the hello_macro_derive function here with proc_macro_derive and\nspecified the name, HelloMacro, which matches our trait name; this is the\nconvention most procedural macros follow.\n\nThe hello_macro_derive function first converts the input from a TokenStream\nto a data structure that we can then interpret and perform operations\non. This is where syn comes into play. The parse function in syn takes a\nTokenStream and returns a DeriveInput struct representing the parsed Rust\ncode. Listing 19-32 shows the relevant parts of the DeriveInput struct we get\nfrom parsing the struct Pancakes; string:\n\nDeriveInput {\n// --snip--\n\nident: Ident {\nident: \"Pancakes\",\nspan: #0 bytes(95..103)\n},\ndata: Struct(\n\nDataStruct {\nstruct_token: Struct,\nfields: Unit,\nsemi_token: Some(\n\nSemi\n)\n\n}\n\nListing 19-32: The DeriveInput instance we get when parsing the code that has the\nmacro\u2019s attribute in Listing 19-30\n\nhello_macro_derive\n/src/lib.rs\n\nThe fields of this struct show that the Rust code we've parsed is a unit\nstruct with the ident (identifier, meaning the name) of Pancakes. There\nare more fields on this struct for describing all sorts of Rust code; check\nthe syn documentation for DeriveInput at Attps://docs.rs/syn/0.14.4/syn/struct\n-DeriveInput.html for more information.\n\nSoon we'll define the imp]_hello_macro function, which is where we'll build\nthe new Rust code we want to include. But before we do, note that the output\nfor our derive macro is also a TokenStream. The returned TokenStream is added\nto the code that our crate users write, so when they compile their crate,\nthey'll get the extra functionality that we provide in the modified TokenStream.\n\nYou might have noticed that we\u2019re calling unwrap to cause the hello\n_macro_derive function to panic if the call to the syn: :parse function fails\nhere. It\u2019s necessary for our procedural macro to panic on errors because\nproc_macro_derive functions must return TokenStream rather than Result to\nconform to the procedural macro API. We've simplified this example by\nusing unwrap; in production code, you should provide more specific error\nmessages about what went wrong by using panic! or expect.\n\nNow that we have the code to turn the annotated Rust code from a\nTokenStream into a DeriveInput instance, let\u2019s generate the code that imple-\nments the HelloMacro trait on the annotated type, as shown in Listing 19-33.\n\nfn imp] hello _macro(ast: &syn::DeriveInput) -> TokenStream {\nlet name = &ast.ident;\nlet gen = quote! {\nimpl HelloMacro for #name {\nfn hello _macro() {\nprintln!(\"Hello, Macro! My name is {}\", stringify!(#name));\n}\n\n}\niH\ngen.into()\n}\n\nlisting 19-33: Implementing the HelloMacro trait using the parsed Rust code\n\nWe get an Ident struct instance containing the name (identifier) of the\nannotated type using ast. ident. The struct in Listing 19-32 shows that when\nwe run the imp] _hello_macro function on the code in Listing 19-30, the ident we\nget will have the ident field with a value of \"Pancakes\". Thus, the name variable\nin Listing 19-33 will contain an Ident struct instance that, when printed, will\nbe the string \"Pancakes\", the name of the struct in Listing 19-30.\n\nThe quote! macro lets us define the Rust code that we want to return.\nThe compiler expects something different to the direct result of the quote!\nmacro\u2019s execution, so we need to convert it to a TokenStream. We do this by\ncalling the into method, which consumes this intermediate representation\nand returns a value of the required TokenStream type.\n\nThe quote! macro also provides some very cool templating mechanics:\nwe can enter #name, and quote! will replace it with the value in the variable\n\nname. You can even do some repetition similar to the way regular macros\nwork. Check out the quote crate\u2019s docs at https://docs.rs/quote for a thorough\nintroduction.\n\nWe want our procedural macro to generate an implementation of our\nHelloMacro trait for the type the user annotated, which we can get by using\n#name. The trait implementation has one function, hello_macro, whose body\ncontains the functionality we want to provide: printing Hello, Macro! My name\nis and then the name of the annotated type.\n\nThe stringify! macro used here is built into Rust. It takes a Rust expres-\nsion, such as 1 + 2, and at compile time turns the expression into a string\nliteral, such as \"1 + 2\". This is different than format! or println!, macros\nwhich evaluate the expression and then turn the result into a String. There\nis a possibility that the #name input might be an expression to print literally,\nso we use stringify!. Using stringify! also saves an allocation by converting\n#name to a string literal at compile time.\n\nAt this point, cargo build should complete successfully in both hello_macro\nand hello_macro_derive. Let\u2019s hook up these crates to the code in Listing 19-30\nto see the procedural macro in action! Create a new binary project in your\nprojects directory using cargo new pancakes. We need to add hello_macro and\nhello_macro_derive as dependencies in the pancakes crate\u2019s Cargo.toml. If\nyou're publishing your versions of hello_macro and hello_macro_derive to\nAttps://crates.io/, they would be regular dependencies; if not, you can specify\nthem as path dependencies as follows:\n\n[dependencies]\nhello_macro = { path = \"../hello_ macro\" }\nhello_macro_derive = { path = \"../hello_macro/hello macro _derive\" }\n\nPut the code in Listing 19-30 into src/main.rs, and run cargo run: it\nshould print Hello, Macro! My name is Pancakes! The implementation of\nthe HelloMacro trait from the procedural macro was included without the\npancakes crate needing to implement it; the #[derive(HelloMacro)] added the\ntrait implementation.\n\nNext, let\u2019s explore how the other kinds of procedural macros differ\nfrom custom derive macros.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 19.3,
                        "section_name": "Attribute-like macros",
                        "section_path": "./screenshots-images-2/chapter_19/section_30",
                        "images": [
                            "./screenshots-images-2/chapter_19/section_30/a1fe49ce-b999-4148-b1c9-cada7e27c04b.png",
                            "./screenshots-images-2/chapter_19/section_30/1d20dd11-6571-4eea-9020-aa75fea83345.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Attribute-like macros\n\nAttribute-like macros are similar to custom derive macros, but instead of\ngenerating code for the derive attribute, they allow you to create new attri-\nbutes. They're also more flexible: derive only works for structs and enums;\nattributes can be applied to other items as well, such as functions. Here\u2019s an\nexample of using an attribute-like macro: say you have an attribute named\nroute that annotates functions when using a web application framework:\n\n#[route(GET, \"/\")]\nfn index() {\n\nThis #[route] attribute would be defined by the framework as a procedural\nmacro. The signature of the macro definition function would look like this:\n\n#[proc_macro_attribute]\npub fn route(attr: TokenStream, item: TokenStream) -> TokenStream {\n\nHere, we have two parameters of type TokenStream. The first is for the\ncontents of the attribute: the GET, \"/\" part. The second is the body of the\nitem the attribute is attached to: in this case, fn index() {} and the rest of\nthe function\u2019s body.\n\nOther than that, attribute-like macros work the same way as custom\nderive macros: you create a crate with the proc-macro crate type and imple-\nment a function that generates the code you want!\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 19.31,
                        "section_name": "Function-like macros",
                        "section_path": "./screenshots-images-2/chapter_19/section_31",
                        "images": [
                            "./screenshots-images-2/chapter_19/section_31/1484b4f9-1eac-4de1-a3e2-d3af011f98f4.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Function-like macros\n\nFunction-like macros define macros that look like function calls. Similarly\nto macro_rules! macros, they\u2019re more flexible than functions; for example,\nthey can take an unknown number of arguments. However, macro_rules!\nmacros can be defined only using the match-like syntax we discussed in\n\u201cDeclarative Macros with macro_rules! for General Metaprogramming\u201d on\npage 446. Function-like macros take a TokenStream parameter and their\ndefinition manipulates that TokenStream using Rust code as the other two\ntypes of procedural macros do. An example of a function-like macro is an\nsql! macro that might be called like so:\n\nlet sql = sql!(SELECT * FROM posts WHERE id=1);\n\nThis macro would parse the SQL statement inside it and check that\nit\u2019s syntactically correct, which is much more complex processing than a\nmacro_rules! macro can do. The sql! macro would be defined like this:\n\n#[proc_macro]\npub fn sql(input: TokenStream) -> TokenStream {\n\nThis definition is similar to the custom derive macro\u2019s signature: we\nreceive the tokens that are inside the parentheses and return the code we\nwanted to generate.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 19.32,
                        "section_name": "Summary",
                        "section_path": "./screenshots-images-2/chapter_19/section_32",
                        "images": [
                            "./screenshots-images-2/chapter_19/section_32/21288ba5-ea13-4ddb-9c67-5c1164b0d522.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Summary\n\nWhew! Now you have some features of Rust in your toolbox that you won't\nuse often, but you'll know they're available in very particular circumstances.\nWe've introduced several complex topics so that when you encounter them\nin error message suggestions or in other peoples\u2019 code, you'll be able to rec-\nognize these concepts and syntax. Use this chapter as a reference to guide\nyou to solutions.\n\nNext, we'll put everything we've discussed throughout the book into\npractice and do one more project!\n",
                        "extracted-code": ""
                    }
                ]
            },
            {
                "chapter_id": 20,
                "chapter_name": "FINAL PROJECT: BUILDINGA\nMULTITHREADED WEB SERVER",
                "chapter_path": "./screenshots-images-2/chapter_20",
                "sections": [
                    {
                        "section_id": 20.1,
                        "section_name": "FINAL PROJECT: BUILDINGA\nMULTITHREADED WEB SERVER",
                        "section_path": "./screenshots-images-2/chapter_20/section_1",
                        "images": [
                            "./screenshots-images-2/chapter_20/section_1/20838127-8ec2-4d39-8e3e-6a54c4fb6b88.png",
                            "./screenshots-images-2/chapter_20/section_1/9b854f8f-4dca-498a-9eb9-d9633431eeca.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "It\u2019s been a long journey, but we\u2019ve reached\nthe end of the book. In this chapter, we\u2019ll\nbuild one more project together to demon-\n\nstrate some of the concepts we covered in the\nfinal chapters, as well as recap some earlier lessons.\n\nFor our final project, we'll make a web server that says \u201cHello!\u201d and\nlooks like Figure 20-1 in a web browser.\n\nHello! x\n\n> \u00a9 127.0.0.1:8080\n\nHello!\n\nHi from Rust\n\nFigure 20-1: Our final shared project\n\nHere is the plan to build the web server:\n\nLearn a bit about TCP and HTTP.\nListen for TCP connections on a socket.\n\nParse a small number of HTTP requests.\n\nPON\n\nCreate a proper HTTP response.\n\no\n\nImprove the throughput of our server with a thread pool.\n\nBut before we get started, we should mention one detail: the method\nwe'll use won't be the best way to build a web server with Rust. A number of\nproduction-ready crates are available on hitps://crates.io/ that provide more\ncomplete web server and thread pool implementations than we'll build.\n\nHowever, our intention in this chapter is to help you learn, not to take\nthe easy route. Because Rust is a systems programming language, we can\nchoose the level of abstraction we want to work with and can go to a lower\nlevel than is possible or practical in other languages. We'll write the basic\nHTTP server and thread pool manually so you can learn the general ideas\nand techniques behind the crates you might use in the future.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 20.2,
                        "section_name": "Building a Single-Threaded Web Server",
                        "section_path": "./screenshots-images-2/chapter_20/section_2",
                        "images": [
                            "./screenshots-images-2/chapter_20/section_2/d9adee62-5ca0-41f2-b5a1-2c4921cf3115.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Building a Single-Threaded Web Server\n\nWe'll start by getting a single-threaded web server working. Before we\nbegin, let\u2019s look at a quick overview of the protocols involved in building\nweb servers. The details of these protocols are beyond the scope of this\nbook, but a brief overview will give you the information you need.\n\nThe two main protocols involved in web servers are the Hypertext Transfer\nProtocol (HTTP) and the Transmission Control Protocol (TCP). Both protocols are\nrequest-response protocols, meaning that a client initiates requests and a server\nlistens to the requests and provides a response to the client. The contents of\nthose requests and responses are defined by the protocols.\n\nTCP is the lower-level protocol that describes the details of how infor-\nmation gets from one server to another but doesn\u2019t specify what that informa-\ntion is. HTTP builds on top of TCP by defining the contents of the requests\nand responses. It\u2019s technically possible to use HTTP with other protocols, but\nin the vast majority of cases, HTTP sends its data over TCP. We'll work with\nthe raw bytes of TCP and HTTP requests and responses.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 20.3,
                        "section_name": "Listening to the TCP Connection",
                        "section_path": "./screenshots-images-2/chapter_20/section_3",
                        "images": [
                            "./screenshots-images-2/chapter_20/section_3/155cb93c-7708-4a5a-b192-6223e857aea0.png",
                            "./screenshots-images-2/chapter_20/section_3/4f64fc05-88b3-4a52-84c4-05fc0d973a95.png",
                            "./screenshots-images-2/chapter_20/section_3/1982f37e-a323-4025-9327-ecf12ef62eb2.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Listening to the TCP Connection\nOur web server needs to listen to a TCP connection, so that\u2019s the first part\n\nwe'll work on. The standard library offers a std: :net module that lets us do\nthis. Let\u2019s make a new project in the usual fashion:\n\n$ cargo new hello\nCreated binary (application) \u201chello\u201d project\n$ cd hello\n\nsrc/main.rs\n\nNow enter the code in Listing 20-1 in sr\u00a2/main.rs to start. This code will\nlisten at the address 127.0.0.1:7878 for incoming TCP streams. When it gets\nan incoming stream, it will print Connection established! .\n\nuse std::net::TcpListener;\n\nfn main() {\n@ let listener = TcpListener::bind(\"127.0.0.1:7878\") .unwrap();\n\n\u00a9 for stream in listener.incoming() {\n\u00a9 let stream = stream.unwrap();\n\n\u00a9 println! (\"Connection established!\");\n}\n}\n\nListing 20-1: Listening for incoming streams and printing a message when we receive a\nstream\n\nUsing TcpListener, we can listen for TCP connections at the address\n127.0.0.1:7878 @. In the address, the section before the colon is an IP\naddress representing your computer (this is the same on every computer\nand doesn\u2019t represent the authors\u2019 computer specifically), and 7878 is the\nport. We've chosen this port for two reasons: HTTP is normally accepted\non this port, and 7878 is rust typed on a telephone.\n\nThe bind function in this scenario works like the new function in that it\nwill return a new TcpListener instance. The reason the function is called bind\nis that in networking, connecting to a port to listen to is known as \u201cbinding\nto a port.\u201d\n\nThe bind function returns a Result<T, E>, which indicates that bind-\ning might fail. For example, connecting to port 80 requires administrator\nprivileges (nonadministrators can listen only on ports higher than 1024),\nso if we tried to connect to port 80 without being an administrator, binding\nwouldn't work. As another example, binding wouldn't work if we ran two\ninstances of our program and so had two programs listening to the same\nport. Because we're writing a basic server just for learning purposes, we\nwon't worry about handling these kinds of errors; instead, we use unwrap to\nstop the program if errors happen.\n\nThe incoming method on TcpListener returns an iterator that gives us\na sequence of streams @ (more specifically, streams of type TcpStream). A\nsingle stream represents an open connection between the client and the\nserver. A connection is the name for the full request and response process\nin which a client connects to the server, the server generates a response,\nand the server closes the connection. As such, TcpStream will read from itself\nto see what the client sent and then allow us to write our response to the\nstream. Overall, this for loop will process each connection in turn and pro-\nduce a series of streams for us to handle.\n\nFor now, our handling of the stream consists of calling unwrap to termi-\nnate our program if the stream has any errors \u00ae; if there aren't any errors,\nthe program prints a message @. We'll add more functionality for the\n\nsuccess case in the next listing. The reason we might receive errors from\nthe incoming method when a client connects to the server is that we're not\nactually iterating over connections. Instead, we're iterating over connection\nattempts. The connection might not be successful for a number of reasons,\nmany of them operating system specific. For example, many operating sys-\ntems have a limit to the number of simultaneous open connections they\ncan support; new connection attempts beyond that number will produce\nan error until some of the open connections are closed.\n\nLet\u2019s try running this code! Invoke cargo run in the terminal and then\nload 127.0.0.1:7878 in a web browser. The browser should show an error\nmessage like \u201cConnection reset,\u201d because the server isn\u2019t currently sending\nback any data. But when you look at your terminal, you should see several\nmessages that were printed when the browser connected to the server!\n\nRunning ~target/debug/hello\u201d\nConnection established!\nConnection established!\nConnection established!\n\nSometimes, you'll see multiple messages printed for one browser request;\nthe reason might be that the browser is making a request for the page as well\nas a request for other resources, like the favicon.ico icon that appears in the\nbrowser tab.\n\nIt could also be that the browser is trying to connect to the server\nmultiple times because the server isn\u2019t responding with any data. When\nstream goes out of scope and is dropped at the end of the loop, the connec-\ntion is closed as part of the drop implementation. Browsers sometimes deal\nwith closed connections by retrying, because the problem might be tem-\nporary. The important factor is that we've successfully gotten a handle to\na TCP connection!\n\nRemember to stop the program by pressing CTRL-C when you're done\nrunning a particular version of the code. Then restart cargo run after you've\nmade each set of code changes to make sure you're running the newest code.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 20.4,
                        "section_name": "Reading the Request",
                        "section_path": "./screenshots-images-2/chapter_20/section_4",
                        "images": [
                            "./screenshots-images-2/chapter_20/section_4/cf008fe7-5246-4fd1-aedb-b21c339f58e8.png",
                            "./screenshots-images-2/chapter_20/section_4/8d4cce21-cd33-4b6d-a05c-70f4b341ff7c.png",
                            "./screenshots-images-2/chapter_20/section_4/9195957e-c1b5-4ade-b2da-64b4abf889e7.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nReading the Request\n\nLet\u2019s implement the functionality to read the request from the browser! To\nseparate the concerns of first getting a connection and then taking some\naction with the connection, we'll start a new function for processing con-\nnections. In this new handle_connection function, we'll read data from the\nTCP stream and print it so we can see the data being sent from the browser.\nChange the code to look like Listing 20-2.\n\nuse std: :io::prelude::*;\nuse std::net::TcpStream;\nuse std::net::TcpListener;\n\nmain\n\n-unwrap();\n\n\ntener.\n\n@ handle_connection(stream) ;\n}\n\nfn handle_connection(@mut stream: TcpStream) {\n\u00a9 let mut buffer = [0; 512];\n\n\u00a9 stream.read(&mut buffer) .unwrap();\n\n@ println!(\"Request: {}\", String::from_utf8_lossy(&buffer[..]));\n}\n\nListing 20-2: Reading from the TcpStream and printing the data\n\nWe bring std: :io::prelude into scope to get access to certain traits that\nlet us read from and write to the stream \u00ae. In the for loop in the main func-\ntion, instead of printing a message that says we made a connection, we now\ncall the new handle_connection function and pass the stream to it \u00ae.\n\nIn the handle_connection function, we\u2019ve made the stream parameter\nmutable \u00ae. The reason is that the TepStream instance keeps track of what\ndata it returns to us internally. It might read more data than we asked for\nand save that data for the next time we ask for data. It therefore needs to be\nmut because its internal state might change; usually, we think of \u201creading\u201d as\nnot needing mutation, but in this case we need the mut keyword.\n\nNext, we need to actually read from the stream. We do this in two steps:\nFirst, we declare a buffer on the stack to hold the data that is read in \u00a9.\nWe've made the buffer 512 bytes, which is big enough to hold the data of a\nbasic request and sufficient for our purposes in this chapter. If we wanted to\nhandle requests of an arbitrary size, buffer management would need to be\nmore complicated; we'll keep it simple for now. We pass the buffer to stream\n-read, which will read bytes from the TepStream and put them in the buffer @.\n\nSecond, we convert the bytes in the buffer to a string and print that\nstring \u00ae. The String: : from_utf8_lossy function takes a &[u8] and produces a\nString from it. The \u201clossy\u201d part of the name indicates the behavior of this\nfunction when it sees an invalid UTF-8 sequence: it will replace the invalid\nsequence with @, the U+FFFD REPLACEMENT CHARACTER. You might see replacement\ncharacters for characters in the buffer that aren't filled by request data.\n\nLet\u2019s try this code! Start the program and make a request in a web\nbrowser again. Note that we'll still get an error page in the browser, but\nour program\u2019s output in the terminal will now look similar to this:\n\n$ cargo run\nCompiling hello v0.1.0 (file:///projects/hello)\nFinished dev [unoptimized + debuginfo] target(s) in 0.42 secs\nRunning \u201ctarget/debug/hello\u201d\nRequest: GET / HTTP/1.1\nHost: 127.0.0.1:7878\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:52.0) Gecko/20100101\n\nFirefox/52.0\n\nAccept: text/html, application/xhtml+xml, application/xml ;q=0.9,*/*;q=0.8\nAccept-Language: en-US,en;q=0.5\n\nAccept-Encoding: gzip, deflate\n\nConnection: keep-alive\n\nUpgrade-Insecure-Requests: 1\n\n9999999090909 99 999909090 909090009009000\n\nDepending on your browser, you might get slightly different output. Now\nthat we're printing the request data, we can see why we get multiple connec-\ntions from one browser request by looking at the path after Request: GET. If\nthe repeated connections are all requesting /, we know the browser is trying\nto fetch / repeatedly because it\u2019s not getting a response from our program.\n\nLet's break down this request data to understand what the browser is\nasking of our program.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 20.5,
                        "section_name": "A Coser Look at an HTTP Request",
                        "section_path": "./screenshots-images-2/chapter_20/section_5",
                        "images": [
                            "./screenshots-images-2/chapter_20/section_5/6f0a19fc-089e-4a7d-b3ff-216f57fc51be.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "A Coser Look at an HTTP Request\nHTTP is a text-based protocol, and a request takes this format:\nMethod Request-URI HTTP-Version CRLF\n\nheaders CRLF\nmessage-body\n\nThe first line is the request line that holds information about what the\nclient is requesting. The first part of the request line indicates the method\nbeing used, such as GET or POST, which describes how the client is making\nthis request. Our client used a GET request.\n\nThe next part of the request line is /, which indicates the Uniform Resource\nIdentifier (URI) the client is requesting: a URI is almost, but not quite, the\nsame as a Uniform Resource Locator (URL). The difference between URIs and\nURLs isn\u2019t important for our purposes in this chapter, but the HTTP spec\nuses the term URI, so we can just mentally substitute URL for URI here.\n\nThe last part is the HTTP version the client uses, and then the request\nline ends in a CRLF sequence. (CRLF stands for carriage return and line feed,\nwhich are terms from the days of typewriters!) The CRLF sequence can\nalso be written as \\r\\n, where \\r is a carriage return and \\n is a line feed.\nThe CRLF sequence separates the request line from the rest of the request\ndata. Note that when the CRLF is printed, we see a new line start rather\nthan \\r\\n.\n\nLooking at the request line data we received from running our program\nso far, we see that GET is the method, /is the request URI, and HTTP/1.1 is the\nversion.\n\nAfter the request line, the remaining lines starting from Host: onward\nare headers. GET requests have no body.\n\nTry making a request from a different browser or asking for a different\naddress, such as 127.0.0.1:7878/test, to see how the request data changes.\n\nNow that we know what the browser is asking for, let's send back\nsome data!\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 20.6,
                        "section_name": "Writing a Response",
                        "section_path": "./screenshots-images-2/chapter_20/section_6",
                        "images": [
                            "./screenshots-images-2/chapter_20/section_6/9b06350c-ec89-42c5-ad0a-eb81bb9419c7.png",
                            "./screenshots-images-2/chapter_20/section_6/34b4751a-c134-4f31-aa33-515a50f5ee37.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nWriting a Response\n\nNow we'll implement sending data in response to a client request. Responses\nhave the following format:\n\nHTTP-Version Status-Code Reason-Phrase CRLF\nheaders CRLF\nmessage-body\n\nThe first line is a status line that contains the HTTP version used in the\nresponse, a numeric status code that summarizes the result of the request,\nand a reason phrase that provides a text description of the status code. After\nthe CRLF sequence are any headers, another CRLF sequence, and the body\nof the response.\n\nHere is an example response that uses HTTP version 1.1, has a status\ncode of 200, an 0K reason phrase, no headers, and no body:\n\nHTTP/1.1 200 OK\\r\\n\\r\\n\n\nThe status code 200 is the standard success response. The text is a tiny\nsuccessful HTTP response. Let's write this to the stream as our response\nto a successful request! From the handle_connection function, remove the\nprintln! that was printing the request data and replace it with the code in\nListing 20-3.\n\nfn handle _connection(mut stream: TcpStream\n\nlet mut buffer 0; 512);\nstream.read(&mut buffer) .unwrap();\n@ let response = \u201cHTTP/1.1 200 OK\\r\\n\\r\\n\";\n\n\u00a9 stream.write(response.as_bytes()@\u00ae).unwrap();\n\u00a9 stream.flush().unwrap();\n\nListing 20-3: Writing a tiny successful HTTP response to the stream\n\nThe first new line defines the response variable that holds the success\nmessage\u2019s data \u00ae. Then we call as_bytes on our response to convert the string\ndata to bytes \u00ae. The write method on stream takes a &[u8] and sends those\nbytes directly down the connection \u00ae.\n\nBecause the write operation could fail, we use unwrap on any error result\nas before. Again, in a real application you would add error handling here.\nFinally, flush will wait and prevent the program from continuing until all\nthe bytes are written to the connection @; TcpStream contains an internal\nbuffer to minimize calls to the underlying operating system.\n\nWith these changes, let\u2019s run our code and make a request. We're\nno longer printing any data to the terminal, so we won't see any output\n\nother than the output from Cargo. When you load 127.0.0.1:7878 in a web\nbrowser, you should get a blank page instead of an error. You've just hand-\ncoded an HTTP request and response!\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 20.7,
                        "section_name": "Returning Real HTML",
                        "section_path": "./screenshots-images-2/chapter_20/section_7",
                        "images": [
                            "./screenshots-images-2/chapter_20/section_7/942e790e-c18c-4fe1-bef5-f5887eec7190.png",
                            "./screenshots-images-2/chapter_20/section_7/d4859d61-6565-482b-849b-d179cd22aad7.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "hello. html\n\nsrc/main.rs\n\nReturning Real HTML\n\nLet\u2019s implement the functionality for returning more than a blank page.\nCreate a new file, hello.html, in the root of your project directory, not in the\nsrc directory. You can input any HTML you want; Listing 20-4 shows one\npossibility.\n\n<IDOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<title>Hello!</title>\n</head>\n<body>\n<h1>Hello!</hi>\n<p>Hi from Rust</p>\n</body>\n</html>\n\nListing 20-4: A sample HTML file to return in a response\n\nThis is a minimal HTML5 document with a heading and some text. To\nreturn this from the server when a request is received, we'll modify handle\n_connection as shown in Listing 20-5 to read the HTML file, add it to the\nresponse as a body, and send it.\n\nuse std::fs;\n\n-snip--\n\nn handle _conr\nlet\n\nlet contents = fs::read_to_string(\"hello. html\") .unwrap();\n\n\u00a9 let response = format! (\"HTTP/1.1 200 OK\\r\\n\\r\\n{}\", contents);\n\nbytes()).unwrap();\n\nListing 20-5: Sending the contents of hello.html as the body of the response\n\nWe've added a line at the top to bring the standard library\u2019s filesystem\nmodule into scope \u00ae. The code for reading the contents of a file to a string\nshould look familiar; we used it in Chapter 12 when we read the contents of\na file for our I/O project in Listing 12-4 on page 237.\n\nNext, we use format! to add the file\u2019s contents as the body of the success\nresponse \u00ae.\n\nRun this code with cargo run and load 127.0.0.1:7878 in your browser;\nyou should see your HTML rendered!\n\nCurrently, we\u2019re ignoring the request data in buffer and just sending\nback the contents of the HTML file unconditionally. That means if you try\nrequesting 127.0.0.1:7878/something-else in your browser, you'll still get back\nthis same HTML response. Our server is very limited and is not what most\nweb servers do. We want to customize our responses depending on the\nrequest and only send back the HTML file for a well-formed request to /.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 20.8,
                        "section_name": "Validating the Request and Selectively Responding",
                        "section_path": "./screenshots-images-2/chapter_20/section_8",
                        "images": [
                            "./screenshots-images-2/chapter_20/section_8/f25a8267-b1d6-420f-9e71-f9ab3cff9164.png",
                            "./screenshots-images-2/chapter_20/section_8/a8fe0355-e2dd-49a4-958b-29c4cc3ac107.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nValidating the Request and Selectively Responding\n\nRight now, our web server will return the HTML in the file no matter what\nthe client requested. Let's add functionality to check that the browser is\nrequesting / before returning the HTML file and return an error if the\nbrowser requests anything else. For this we need to modify handle_connection,\nas shown in Listing 20-6. This new code checks the content of the request\nreceived against what we know a request for / looks like and adds if and\nelse blocks to treat requests differently.\n\nsnip\n\nlet mut buf\n\nstream.read(&mut buffer) .unwrap()\n\n@ let get = b\"GET / HTTP/1.1\\r\\n\";\n\n\u00a9 if buffer.starts_with(get) {\nlet contents = fs::read to string(\"hello.html\").unwrap();\n\nlet response format! (\"HTTP/1.1 200 OK\\r\\n\\r\\n contents) ;\n\nytes()).unwrap()\n\n).unwrap();\n\n// some other request\n\nListing 20-6: Matching the request and handling requests to / differently than other requests\n\nFirst, we hardcode the data corresponding to the / request into the get\nvariable \u00ae. Because we're reading raw bytes into the buffer, we transform\nget into a byte string by adding the b\"\" byte string syntax at the start of the\ncontent data. Then we check whether buffer starts with the bytes in get \u00ae. If it\ndoes, it means we've received a well-formed request to /, which is the success\ncase we'll handle in the if block that returns the contents of our HTML file.\n\nIf buffer does not start with the bytes in get, it means we've received\nsome other request. We'll add code to the else block \u00a9 in a moment to\nrespond to all other requests.\n\nsrc/main.rs\n\n404. html\n\nRun this code now and request 127.0.0.1:7878; you should get the\nHTML in hello.html. If you make any other request, such as 127.0.0.1:7878/\nsomething-else, you'll get a connection error like those you saw when running\nthe code in Listings 20-1 and 20-2.\n\nNow let\u2019s add the code in Listing 20-7 to the else block to return a\nresponse with the status code 404, which signals that the content for the\nrequest was not found. We'll also return some HTML for a page to render\nin the browser indicating the response to the end user.\n\nsnip\nSnip\n\n} else {\n@ let status_line = \"HTTP/1.1 404 NOT FOUND\\r\\n\\r\\n\";\n\u00a9 let contents = fs::read_to_string(\"404.html\").unwrap() ;\n\nlet response = format!(\"{}{}\", status_line, contents);\n\nstream.write(response.as_bytes()).unwrap();\nstream. flush().unwrap() ;\n}\n\nListing 20-7: Responding with status code 404 and an error page if anything other than /\nwas requested\n\nHere, our response has a status line with status code 404 and the rea-\nson phrase NOT FOUND \u00ae. We\u2019re still not returning headers, and the body of\nthe response will be the HTML in the file 404.html \u00ae. You'll need to create\na 404.html file next to hello.html for the error page; again feel free to use any\nHTML you want or use the example HTML in Listing 20-8.\n\n<IDOCTYPE html>\n<html lang=\"en\">\n<head>\n\n<meta charset=\"utf-8\">\n<title>Hello!</title>\n</head>\n<body>\n<h1>Oops!</h1>\n<p>Sorry, I don't know what you're asking for.</p>\n</body>\n</html>\n\nListing 20-8: Sample content for the page to send back with any 404 response\n\nWith these changes, run your server again. Requesting 127.0.0.1:7878\nshould return the contents of hello.html, and any other request, like\n127.0.0.1:7878/foo, should return the error HTML from 404.html.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 20.9,
                        "section_name": "A Touch of Refactoring",
                        "section_path": "./screenshots-images-2/chapter_20/section_9",
                        "images": [
                            "./screenshots-images-2/chapter_20/section_9/0803a447-c5cc-41dc-93e5-d840155b1fcf.png",
                            "./screenshots-images-2/chapter_20/section_9/3edd86da-796c-4963-bc7c-105554e2e3eb.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "A Touch of Refactoring\n\nAt the moment, the if and else blocks have a lot of repetition: they're both\nreading files and writing the contents of the files to the stream. The only\n\nsrc/main.rs\n\ndifferences are the status line and the filename. Let\u2019s make the code more\nconcise by pulling out those differences into separate if and else lines that\nwill assign the values of the status line and the filename to variables; we can\nthen use those variables unconditionally in the code to read the file and\nwrite the response. Listing 20-9 shows the resulting code after replacing the\nlarge if and else blocks.\n\nnection(mut stream: TcpStream\n\nlet (status_line, filename) = if buffer.starts_with(get) {\n(\"HTTP/1.1 200 OK\\r\\n\\r\\n\", \u201chello. html\")\n\n} else {\n(\"HTTP/1.1 404 NOT FOUND\\r\\n\\r\\n\", \"404.htmL\")\n\nhs\n\nlet contents = fs::read_to_string(filename) .unwrap() ;\n\nListing 20-9: Refactoring the if and else blocks to contain only the code that differs\nbetween the two cases\n\nNow the if and else blocks only return the appropriate values for the\nstatus line and filename in a tuple; we then use destructuring to assign these\ntwo values to status_line and filename using a pattern in the let statement, as\ndiscussed in Chapter 18.\n\nThe previously duplicated code is now outside the if and else blocks\nand uses the status_line and filename variables. This makes it easier to see\nthe difference between the two cases, and it means we have only one place\nto update the code if we want to change how the file reading and response\nwriting work. The behavior of the code in Listing 20-9 will be the same as\nthat in Listing 20-8.\n\nAwesome! We now have a simple web server in approximately 40 lines of\nRust code that responds to one request with a page of content and responds\nto all other requests with a 404 response.\n\nCurrently, our server runs in a single thread, meaning it can only serve\none request at a time. Let\u2019s examine how that can be a problem by simulat-\ning some slow requests. Then we'll fix it so our server can handle multiple\nrequests at once.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 20.1,
                        "section_name": "Turning Our Single-Threaded Server into\na Multithreaded Server",
                        "section_path": "./screenshots-images-2/chapter_20/section_10",
                        "images": [
                            "./screenshots-images-2/chapter_20/section_10/91a1b3d1-6c35-4603-87b2-fba986202feb.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Turning Our Single-Threaded Server into\na Multithreaded Server\n\nRight now, the server will process each request in turn, meaning it won't\nprocess a second connection until the first is finished processing. If the\nserver received more and more requests, this serial execution would be less\nand less optimal. If the server receives a request that takes a long time to pro-\ncess, subsequent requests will have to wait until the long request is finished,\neven if the new requests can be processed quickly. We'll need to fix this, but\nfirst, we'll look at the problem in action.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 20.11,
                        "section_name": "Simulating a Slow Request in the Current Server Implementation",
                        "section_path": "./screenshots-images-2/chapter_20/section_11",
                        "images": [
                            "./screenshots-images-2/chapter_20/section_11/98ca693d-4727-4ca9-8956-8c8722a8faeb.png",
                            "./screenshots-images-2/chapter_20/section_11/4d051d57-1197-4894-a2a1-34295005b625.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/main.rs\n\nSimulating a Slow Request in the Current Server Implementation\n\nWe'll look at how a slow-processing request can affect other requests made\nto our current server implementation. Listing 20-10 implements handling a\nrequest to /sleep with a simulated slow response that will cause the server to\nsleep for 5 seconds before responding.\n\nuse std:: thread;\nuse std::time::Duration;\n\n@ let sleep = b\"GET /sleep HTTP/1.1\\r\\n\";\n\nn\", \u201chello. html\")\n\n\u00a9 } else if buffer.starts with(sleep) {\n\u00a9 thread: :sleep(Duration: : from_secs(5));\n\u00a9 (\u201cHTTP/1.1 200 OK\\r\\n\\r\\n\", \u201chello.html\")\n\n} else\n\nTTP/1.1 404 NOT FOUND\\r\\n\\z \u00bb \"404.htm1\"\n\n}\n\nListing 20-10: Simulating a slow request by recognizing /sleep and sleeping for 5 seconds\n\nThis code is a bit messy, but it\u2019s good enough for simulation purposes.\nWe created a second request sleep \u00ae, whose data our server recognizes. We\nadded an else if after the if block to check for the request to /sleep \u00a9. When\nthat request is received, the server will sleep for 5 seconds \u00a9 before rendering\nthe successful HTML page \u00ae.\n\nYou can see how primitive our server is: real libraries would handle the\nrecognition of multiple requests in a much less verbose way!\n\nStart the server using cargo run. Then open two browser windows: one\nfor http://127.0.0.1:7878 and the other for http://127.0.0.1:7878/sleep. If you\n\nenter the / URI a few times, as before, you'll see it respond quickly. But if\nyou enter /sleep and then load /, you'll see that / waits until sleep has slept\nfor its full 5 seconds before loading.\n\nThere are multiple ways we could change how our web server works to\navoid having more requests back up behind a slow request; the one we'll\nimplement is a thread pool.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 20.12,
                        "section_name": "Improving Throughput with a Thread Pool",
                        "section_path": "./screenshots-images-2/chapter_20/section_12",
                        "images": [
                            "./screenshots-images-2/chapter_20/section_12/24753391-cc12-40b8-b4f6-3aa8ef773cc7.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Improving Throughput with a Thread Pool\n\nA thread pool is a group of spawned threads that are waiting and ready to\nhandle a task. When the program receives a new task, it assigns one of the\nthreads in the pool to the task, and that thread will process the task. The\nremaining threads in the pool are available to handle any other tasks that\ncome in while the first thread is processing. When the first thread is done\nprocessing its task, it\u2019s returned to the pool of idle threads, ready to handle\na new task. A thread pool allows you to process connections concurrently,\nincreasing the throughput of your server.\n\nWe'll limit the number of threads in the pool to a small number to\nprotect us from Denial of Service (DoS) attacks; if we had our program\ncreate a new thread for each request as it came in, someone making 10 mil-\nlion requests to our server could create havoc by using up all our server's\nresources and grinding the processing of requests to a halt.\n\nRather than spawning unlimited threads, we'll have a fixed number of\nthreads waiting in the pool. As requests come in, they'll be sent to the pool\nfor processing. The pool will maintain a queue of incoming requests. Each\nof the threads in the pool will pop off a request from this queue, handle\nthe request, and then ask the queue for another request. With this design,\nwe can process N requests concurrently, where Nis the number of threads.\nIf each thread is responding to a long-running request, subsequent requests\ncan still back up in the queue, but we've increased the number of long-\nrunning requests we can handle before reaching that point.\n\nThis technique is just one of many ways to improve the throughput of\na web server. Other options you might explore are the fork/join model and\nthe single-threaded async I/O model. If you're interested in this topic, you\ncan read more about other solutions and try to implement them in Rust;\nwith a low-level language like Rust, all of these options are possible.\n\nBefore we begin implementing a thread pool, let\u2019s talk about what\nusing the pool should look like. When you're trying to design code, writing\nthe client interface first can help guide your design. Write the API of the\ncode so it\u2019s structured in the way you want to call it; then implement the\nfunctionality within that structure rather than implementing the function-\nality and then designing the public API.\n\nSimilar to how we used test-driven development in the project in\nChapter 12, we'll use compiler-driven development here. We'll write the\ncode that calls the functions we want, and then we'll look at errors from the\ncompiler to determine what we should change next to get the code to work.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 20.13,
                        "section_name": "Code Structure If We Could Spawn a Thread for Each Request",
                        "section_path": "./screenshots-images-2/chapter_20/section_13",
                        "images": [
                            "./screenshots-images-2/chapter_20/section_13/0849b482-2f00-4d01-a894-1853f1dec796.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "c/main.rs\n\nCode Structure If We Could Spawn a Thread for Each Request\n\nFirst, let's explore how our code might look if it did create a new thread for\nevery connection. As mentioned earlier, this isn\u2019t our final plan due to the\nproblems with potentially spawning an unlimited number of threads, but it\nis a starting point. Listing 20-11 shows the changes to make to main to spawn\nanew thread to handle each stream within the for loop.\n\nfn main\n\nlet\n\nthread: :spawn(|| {\n\nys\n\n}\n\nListing 20-11: Spawning a new thread for each stream\n\nAs you learned in Chapter 16, thread: : spawn will create a new thread\nand then run the code in the closure in the new thread. If you run this\ncode and load /sleep in your browser, then /in two more browser tabs, you'll\nindeed see that the requests to / don\u2019t have to wait for /sleep to finish. But as\nwe mentioned, this will eventually overwhelm the system because you'd be\nmaking new threads without any limit.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 20.14,
                        "section_name": "Creating a Similar Interface for a Finite Number of Threads",
                        "section_path": "./screenshots-images-2/chapter_20/section_14",
                        "images": [
                            "./screenshots-images-2/chapter_20/section_14/07747f3d-ebc3-49f2-9024-f17e327abf84.png",
                            "./screenshots-images-2/chapter_20/section_14/3d4f9d88-f019-4d26-a2a4-05b64bab2e9e.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "\u00a2/main.rs\n\nCreating a Similar Interface for a Finite Number of Threads\n\nWe want our thread pool to work in a similar, familiar way so that switch-\ning from threads to a thread pool doesn\u2019t require large changes to the\ncode that uses our API. Listing 20-12 shows the hypothetical interface for\na ThreadPool struct we want to use instead of thread: : spawn.\n\nlet listener Tepli\n\n@ let pool = ThreadPool : :new(4); 7\n\n@ pool.execute(|| { ;\n\u00bb; 1andle_connection(stream) ;\n}\nListing 20-12: Our ideal ThreadPool interface\n\nWe use ThreadPool: :new to create a new thread pool with a configurable\nnumber of threads, in this case four @. Then, in the for loop, pool.execute\n\nhas a similar interface as thread: :spawn in that it takes a closure the pool\nshould run for each stream \u00ae. We need to implement pool.execute so it takes\nthe closure and gives it to a thread in the pool to run. This code won't yet\ncompile, but we'll try so the compiler can guide us in how to fix it.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 20.15,
                        "section_name": "Building the ThreadPool Struct Using Compiler-Driven Development",
                        "section_path": "./screenshots-images-2/chapter_20/section_15",
                        "images": [
                            "./screenshots-images-2/chapter_20/section_15/b5e40bf3-9724-4f96-81c5-4b146cb51477.png",
                            "./screenshots-images-2/chapter_20/section_15/4aa9863f-6035-4a49-b275-ac2dac43915e.png",
                            "./screenshots-images-2/chapter_20/section_15/8cb4e93d-b8da-4be6-a192-a49faad2a7e7.png",
                            "./screenshots-images-2/chapter_20/section_15/071d2e10-d8f7-4ac4-9191-9f1a7a4cb01d.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/lib.rs\n\nsrc/bin/main.rs\n\nBuilding the ThreadPool Struct Using Compiler-Driven Development\n\nMake the changes in Listing 20-12 to src/main.rs, and then let\u2019s use the\ncompiler errors from cargo check to drive our development. Here is the first\nerror we get:\n\n$ cargo check\nCompiling hello v0.1.0 (file:///projects/hello)\n\nerror[E0433]: failed to resolve. Use of undeclared type or module ~ThreadPool*\n--> src\\main.rs:10:16\n\n|\n10 | let pool = ThreadPool: :new(4);\n\n| AAADARAAMAAMAAN Use of undeclared type or module\n*ThreadPool\u201d\n\nerror: aborting due to previous error\n\nGreat! This error tells us we need a ThreadPool type or module, so we'll\nbuild one now. Our ThreadPool implementation will be independent of the\nkind of work our web server is doing. So, let\u2019s switch the hello crate from a\nbinary crate to a library crate to hold our ThreadPool implementation. After\nwe change to a library crate, we could also use the separate thread pool\nlibrary for any work we want to do using a thread pool, not just for serving\nweb requests.\n\nCreate a sr\u00a2/lib.rs that contains the following, which is the simplest defi-\nnition of a ThreadPool struct that we can have for now:\n\npub struct ThreadPool;\n\nThen create a new directory, src/bin, and move the binary crate rooted\nin sr\u00a2/main.rs into src/bin/main.rs. Doing so will make the library crate the\nprimary crate in the hello directory; we can still run the binary in sr\u00a2/bin/\nmain.rs using cargo run. After moving the main.rs file, edit it to bring the\nlibrary crate in and bring ThreadPool into scope by adding the following\ncode to the top of sr\u00a2/bin/main.rs:\n\nuse hello: :ThreadPool;\n\nThis code still won't work, but let\u2019s check it again to get the next error\nthat we need to address:\n\n$ cargo check\n\nCompiling hello v0.1.0 (file:///projects/hello)\nerror[E0599]: no function or associated item named \u201cnew found for type\n\u201chello: :ThreadPool\u201d in the current scope\n\nsrc/lib.rs\n\n--> src/bin/main.rs:13:16\n\n|\n13 | let pool = ThreadPool: :new(4);\n\n| AAAAAAAAAAADAAN Function or associated item not found in\n\u201chello: :ThreadPool\u201d\n\nThis error indicates that next we need to create an associated function\nnamed new for ThreadPool. We also know that new needs to have one parameter\nthat can accept 4 as an argument and should return a ThreadPool instance.\nLet's implement the simplest new function that will have those characteristics:\n\npub struct ThreadPool;\n\nimpl ThreadPool {\npub fn new(size: usize) -> ThreadPool {\nThreadPool\n}\n\nWe chose usize as the type of the size parameter, because we know that\na negative number of threads doesn\u2019t make any sense. We also know we'll\nuse this 4 as the number of elements in a collection of threads, which is\nwhat the usize type is for, as discussed in \u201cInteger Types\u201d on page 36.\n\nLet\u2019s check the code again:\n\n$ cargo check\nCompiling hello v0.1.0 (file:///projects/hello)\nwarning: unused variable: \u201csize\u201d\n--> sre/lib.rs:4:16\n|\n\n4| pub fn new(size: usize) -> ThreadPool {\n| AAAA\n|\n= note: #[warn(unused_variables)] on by default\n\nnote: to avoid this warning, consider using ~_size\u2019 instead\n\nerror[E0599]: no method named \u201cexecute\u201d found for type ~hello::ThreadPool\u201d in\nthe current scope\n--> src/bin/main.rs:18:14\n\n|\n18 | pool.execute(|| {\n\n| AARAAAA\n\nNow we get a warning and an error. Ignoring the warning for a moment,\nthe error occurs because we don\u2019t have an execute method on ThreadPool.\nRecall from \u201cCreating a Similar Interface for a Finite Number of Threads\u201d on\npage 470 that we decided our thread pool should have an interface similar\nto thread: : spawn. In addition, we'll implement the execute function so it takes\nthe closure it\u2019s given and gives it to an idle thread in the pool to run.\n\nWe'll define the execute method on ThreadPool to take a closure as a\nparameter. Recall from \u201cStoring Closures Using Generic Parameters and\n\nsrc/lib.rs\n\nthe Fn Traits\u201d on page 270 that we can take closures as parameters with\nthree different traits: Fn, FnMut, and FnOnce. We need to decide which kind\n\nof closure to use here. We know we'll end up doing something similar to\nthe standard library thread: : spawn implementation, so we can look at what\nbounds the signature of thread: :spawn has on its parameter. The documenta-\ntion shows us the following:\n\npub fn spawn<F, T>(f: F) -> JoinHandle<T>\nwhere\nF: FnOnce() -> T + Send + \u2018static,\nT: Send + \u2018static\n\nThe F type parameter is the one we're concerned with here; the T type\nparameter is related to the return value, and we're not concerned with that.\nWe can see that spawn uses FnOnce as the trait bound on F. This is probably\nwhat we want as well, because we'll eventually pass the argument we get\nin execute to spawn. We can be further confident that FnOnce is the trait we\nwant to use because the thread for running a request will only execute that\nrequest\u2019s closure one time, which matches the Once in FnOnce.\n\nThe F type parameter also has the trait bound Send and the lifetime\nbound \u2018static, which are useful in our situation: we need Send to transfer\nthe closure from one thread to another and \u2018static because we don\u2019t know\nhow long the thread will take to execute. Let\u2019s create an execute method on\nThreadPool that will take a generic parameter of type F with these bounds:\n\nimpl Th\n\nIf\n\npub fn execute<F>(&self, f: F)\nwhere\nF: FnOnce()@ + Send + \u2018static\n\nWe still use the () after Fn0nce \u00ae because this FnOnce represents a closure\nthat takes no parameters and doesn\u2019t return a value. Just like function defi-\nnitions, the return type can be omitted from the signature, but even if we\nhave no parameters, we still need the parentheses.\n\nAgain, this is the simplest implementation of the execute method: it does\nnothing, but we're trying only to make our code compile. Let's check it again:\n\n$ cargo check\n\nCompiling hello v0.1.0 (file:///projects/hello)\nwarning: unused variable: \u201csize\u201d\n--> src/lib.rs:4:16\n\n4 pub fn new(size: usize) -> ThreadPool {\n\n| AAA\n\nnote: #[warn(unused_variables)] on by default\nnote: to avoid this warning, consider using ~_size\u2019 instead\n\nwarning: unused variable: ~f\n--> sre/lib.rs:8:30\n\n|\n8 | pub fn execute<F>(&self, f: F)\nrN\n\n= note: to avoid this warning, consider using ~_f> instead\n\nWe're receiving only warnings now, which means it compiles! But note\nthat if you try cargo run and make a request in the browser, you'll see the\nerrors in the browser that we saw at the beginning of the chapter. Our\nlibrary isn\u2019t actually calling the closure passed to execute yet!\n\nA saying you might hear about languages with strict compilers, such as Haskell and\nRust, is \u201cIf the code compiles, it works.\u201d But this saying is not universally true. Our\nproject compiles, but it does absolutely nothing! If we were building a real, complete\nproject, this would be a good time to start writing unit tests to check that the code com-\npiles and has the behavior we want.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 20.16,
                        "section_name": "Validating the Number of Threads in new",
                        "section_path": "./screenshots-images-2/chapter_20/section_16",
                        "images": [
                            "./screenshots-images-2/chapter_20/section_16/3d4987f6-7015-46ec-9d91-421b96169d72.png",
                            "./screenshots-images-2/chapter_20/section_16/e780b8ce-f176-4370-ae87-c3e134322eb6.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/lib.rs\n\nValidating the Number of Threads in new\n\nWe'll continue to get warnings because we aren\u2019t doing anything with the\nparameters to new and execute. Let\u2019s implement the bodies of these func-\ntions with the behavior we want. To start, let\u2019s think about new. Earlier, we\nchose an unsigned type for the size parameter, because a pool with a nega-\ntive number of threads makes no sense. However, a pool with zero threads\nalso makes no sense, yet zero is a perfectly valid usize. We'll add code to\ncheck that size is greater than zero before we return a ThreadPool instance\nand have the program panic if it receives a zero by using the assert! macro,\nas shown in Listing 20-13.\n\nimp] ThreadPool {\n/// Create a new ThreadPool.\nMi\n/// The size is the number of threads in the pool.\n\u2018i\n\u00a9 /// # Panics\nMi\n/// The \u201cnew\u201d function will panic if the size is zero.\n\n@ assert!(size > 0);\n\nListing 20-13: Implementing ThreadPool: :new to panic if size is zero\n\nWe've added some documentation for our ThreadPool with doc com-\nments. Note that we followed good documentation practices by adding\na section that calls out the situations in which our function can panic @,\nas discussed in Chapter 14. Try running cargo doc --open and clicking the\nThreadPool struct to see what the generated docs for new look like!\n\nInstead of adding the assert! macro as we've done here @, we could\nmake new return a Result as we did with Config: :new in the I/O project in\nListing 12-9 on page 245. But we've decided in this case that trying to\ncreate a thread pool without any threads should be an unrecoverable\nerror. If you're feeling ambitious, try to write a version of new with the\nfollowing signature to compare both versions:\n\npub fn new(size: usize) -> Result<ThreadPool, PoolCreationError> {\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 20.17,
                        "section_name": "Creating Space to Store the Threads",
                        "section_path": "./screenshots-images-2/chapter_20/section_17",
                        "images": [
                            "./screenshots-images-2/chapter_20/section_17/33a92258-dcd3-4f5f-bf4a-7f1110aea567.png",
                            "./screenshots-images-2/chapter_20/section_17/008c47ef-faa5-45e8-aa8a-a7d973d502d0.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/lib.rs\n\nCreating Space to Store the Threads\n\nNow that we have a way to know we have a valid number of threads to store in\nthe pool, we can create those threads and store them in the ThreadPool struct\nbefore returning it. But how do we \u201cstore\u201d a thread? Let\u2019s take another look at\nthe thread: : spawn signature:\n\npub fn spawn<F, T>(f: F) -> JoinHandle<T>\nwhere\nF: FnOnce() -> T + Send + \u2018static,\nT: Send + \u2018static\n\nThe spawn function returns a JoinHandle<T>, where T is the type that the\nclosure returns. Let's try using JoinHandle too and see what happens. In our\ncase, the closures we're passing to the thread pool will handle the connec-\ntion and not return anything, so T will be the unit type ().\n\nThe code in Listing 20-14 will compile but doesn\u2019t create any\nthreads yet. We've changed the definition of ThreadPool to hold a vector\nof thread: :JoinHandle<()> instances, initialized the vector with a capacity\nof size, set up a for loop that will run some code to create the threads,\nand returned a ThreadPool instance containing them.\n\n@ use std: :thread;\n\npub struct ThreadPool {\n@ threads: Vec<thread::JoinHandle<()>>,\n}\n\nimpl ThreadPool {\n\npub fn new(size: usize > ThreadPool {\n\nassert! (size > 0);\n\u00a9 let mut threads = Vec::with_capacity(size);\n\nfor _ in 0..size {\n// create some threads and store them in the vector\n\n}\n\nThreadPool {\nthreads\n}\n\n--snip--\n\n}\n\nListing 20-14: Creating a vector for ThreadPool to hold the threads\n\nWe've brought std: : thread into scope in the library crate @, because we're\nusing thread: : JoinHandle as the type of the items in the vector in ThreadPool \u00ae.\n\nOnce a valid size is received, our ThreadPool creates a new vector that can\nhold size items \u00a9. We haven't used the with_capacity function in this book\nyet, which performs the same task as Vec: :new but with an important differ-\nence: it preallocates space in the vector. Because we know we need to store\nsize elements in the vector, doing this allocation up front is slightly more\nefficient than using Vec: :new, which resizes itself as elements are inserted.\n\nWhen you run cargo check again, you'll get a few more warnings, but it\nshould succeed.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 20.18,
                        "section_name": "A Worker Struct Responsible for Sending Code from the ThreadPool to a Thread",
                        "section_path": "./screenshots-images-2/chapter_20/section_18",
                        "images": [
                            "./screenshots-images-2/chapter_20/section_18/53e2dc23-c646-45bf-90f5-37cb61b0100b.png",
                            "./screenshots-images-2/chapter_20/section_18/305e02f7-abfe-4aaa-88ad-9fe5fddfadde.png",
                            "./screenshots-images-2/chapter_20/section_18/460bfd7f-df67-4626-82b4-aa7763416ee3.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "A Worker Struct Responsible for Sending Code from the ThreadPool to a Thread\n\nWe left a comment in the for loop in Listing 20-14 regarding the creation\n\nof threads. Here, we'll look at how we actually create threads. The standard\nlibrary provides thread: : spawn as a way to create threads, and thread: : spawn\nexpects to get some code the thread should run as soon as the thread is\ncreated. However, in our case, we want to create the threads and have them\nwait for code that we'll send later. The standard library's implementation of\nthreads doesn\u2019t include any way to do that; we have to implement it manually.\n\nWe'll implement this behavior by introducing a new data structure\nbetween the ThreadPool and the threads that will manage this new behavior.\nWe'll call this data structure Worker, which is a common term in pooling\nimplementations. Think of people working in the kitchen at a restaurant:\nthe workers wait until orders come in from customers, and then they're\nresponsible for taking those orders and filling them.\n\nInstead of storing a vector of JoinHandle<()> instances in the thread\npool, we'll store instances of the Worker struct. Each Worker will store a single\nJoinHandle<()> instance. Then we'll implement a method on Worker that will\ntake a closure of code to run and send it to the already running thread for\nexecution. We'll also give each worker an id so we can distinguish between\nthe different workers in the pool when logging or debugging.\n\nLet\u2019s make the following changes to what happens when we create a\nThreadPool. We'll implement the code that sends the closure to the thread\nafter we have Worker set up in this way:\n\n1. Define a Worker struct that holds an id and a JoinHandle<()>.\n2. Change ThreadPool to hold a vector of Worker instances.\n\n3. Define a Worker: :new function that takes an id number and returns a\nWorker instance that holds the id and a thread spawned with an empty\nclosure.\n\n4. In ThreadPool: :new, use the for loop counter to generate an id, create a\nnew Worker with that id, and store the worker in the vector.\n\nIf you're up for a challenge, try implementing these changes on your\nown before looking at the code in Listing 20-15.\n\nReady? Here is Listing 20-15 with one way to make the preceding\nmodifications.\n\nsrc/lib.rs\n\n:: thread;\n\npub struct ThreadPool {\n\n\u00a9 workers: Vec<Worker>,\n\nlet mut workers = Vec::with_capacity(size);\n\n\u00a9 for id in 0..size {\n\u00a9 workers.push(Worker: :new(id));\n\nThreadPool {\nworkers\n\n\u00a9 struct Worker {\nid: usize,\nthread: thread: :JoinHandle<()>,\n}\n\nimpl Worker {\n\u00a9 fn new(id: usize) -> Worker {\n\u00ae let thread = thread::spawn(|| {});\n\nWorker {\n\n@ id,\n\n@ thread,\n}\n\n}\n\nListing 20-15: Modifying ThreadPool to hold Worker instances instead of holding threads\ndirectly\n\nWe've changed the name of the field on ThreadPool from threads to\nworkers because it\u2019s now holding Worker instances instead of JoinHandle<()>\ninstances @. We use the counter in the for loop @ as an argument to\nWorker: :new, and we store each new Worker in the vector named workers \u00a9.\n\nExternal code (like our server in src/bin/main.rs) doesn\u2019t need to know\nthe implementation details regarding using a Worker struct within ThreadPool,\nso we make the Worker struct \u00a9 and its new function @ private. The Worker: :new\nfunction uses the id we give it @ and stores a JoinHandle<()> instance @ that is\ncreated by spawning a new thread using an empty closure \u00a9.\n\nThis code will compile and will store the number of worker instances we\nspecified as an argument to ThreadPool: :new. But we're still not processing\nthe closure that we get in execute. Let's look at how to do that next.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 20.19,
                        "section_name": "Sending Requests to Threads via Channels",
                        "section_path": "./screenshots-images-2/chapter_20/section_19",
                        "images": [
                            "./screenshots-images-2/chapter_20/section_19/75c0b451-0b6b-4f38-a687-49ac0ba23989.png",
                            "./screenshots-images-2/chapter_20/section_19/f0e3fa8b-57fb-4999-9209-59eaf19d69db.png",
                            "./screenshots-images-2/chapter_20/section_19/53a0f7b4-fb6c-4e2c-9b25-9ae28276094c.png",
                            "./screenshots-images-2/chapter_20/section_19/0867cfd9-f32f-4978-93cc-13f33b80965d.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/lib.rs\n\nSending Requests to Threads via Channels\n\nNow we'll tackle the problem that the closures given to thread: : spawn do\nabsolutely nothing. Currently, we get the closure we want to execute in the\nexecute method. But we need to give thread: :spawn a closure to run when we\ncreate each Worker during the creation of the ThreadPool.\n\nWe want the Worker structs that we just created to fetch code to run from\na queue held in the ThreadPool and send that code to its thread to run.\n\nIn Chapter 16, you learned about channels\u2014a simple way to communi-\ncate between two threads\u2014which would be perfect for this use case. We'll\nuse a channel to function as the queue of jobs, and execute will send a job\nfrom the ThreadPool to the Worker instances, which will send the job to its\nthread. Here is the plan:\n\n1. The ThreadPool will create a channel and hold on to the sending side of\nthe channel.\n\n2. Each Worker will hold on to the receiving side of the channel.\n\n3. We'll create a new Job struct that will hold the closures we want to send\ndown the channel.\n\n4. The execute method will send the job it wants to execute down the send-\ning side of the channel.\n\n5. In its thread, the Worker will loop over its receiving side of the channel\nand execute the closures of any jobs it receives.\n\nLet\u2019s start by creating a channel in ThreadPool::new and holding the\nsending side in the ThreadPool instance, as shown in Listing 20-16. The Job\nstruct doesn\u2019t hold anything for now but will be the type of item we're send-\ning down the channel.\n\nsnip\n\nuse std::sync::mpsc;\n\nworkers: Vec rker\n\nsender: mpsc: :Sender<Job>,\n\nstruct Job;\n\nimpl ThreadPool {\n// --snip--\npub fn new(size: usize) -> ThreadPool {\nassert! (size > 0);\n\n@ let (sender, receiver) = mpsc::channel();\nlet mut workers = Vec::with_capacity(size);\n\nfor id in 0..size {\nworkers .push(Worker: :new(id)\n\n}\n\nThreadPool {\nworkers,\n@ sender,\n\n}\n\n/ --snip--\n\nListing 20-16: Modifying ThreadPool to store the sending end of a channel that sends Job\ninstances\n\nIn ThreadPool: :new, we create our new channel @ and have the pool hold\nthe sending end \u00ae. This will successfully compile, still with warnings.\n\nLet's try passing a receiving end of the channel into each worker as the\nthread pool creates the channel. We know we want to use the receiving end\nin the thread that the workers spawn, so we'll reference the receiver param-\neter in the closure. The code in Listing 20-17 won't quite compile yet.\n\nsrc/lib.rs imp] ThreadPool {\n\n--snip--\n\npub fn new(s usize) -> ThreadPool {\n\nassert! (size > 0);\n\nlet (sender, receiver) = mpsc::channel();\nlet mut workers = Vec::with_capacity(size);\nfor id in 0..size {\n\n\u00a9 workers.push(Worker::new(id, receiver));\n}\n\nThreadPool {\n\nworkers,\nsender,\n\n3\nim\n\nsrc/lib.rs\n\nimpl Worker {\nfn new(id: usize, receiver: mpsc::Receiver<Job>) -> Worker {\nlet thread = thread::spawn(|| {\n@ receiver;\n\nys\n\nWorker {\n\n}\n\nListing 20-17: Passing the receiving end of the channel to the workers\n\nWe've made some small and straightforward changes: we pass the\nreceiving end of the channel into Worker: :new @, and then we use it inside\nthe closure \u00ae.\n\nWhen we try to check this code, we get this error:\n\n$ cargo check\n\nCompiling hello v0.1.0 (file:///projects/hello)\nerror[E0382]: use of moved value: ~receiver\u2122\n\n--> src/lib.rs:27:42\n\n|\n27 | workers.push(Worker::new(id, receiver));\n| aaananne value moved here in\n\nprevious iteration of loop\n\n= note: move occurs because \u201creceiver\u201d has type \u201cstd::sync::mpsc::Receiver<\nJob>~, which does not implement the \u201cCopy\u201d trait\n\nThe code is trying to pass receiver to multiple Worker instances. This won't\nwork, as you'll recall from Chapter 16: the channel implementation that Rust\nprovides is multiple producer, single consumer. This means we can\u2019t just clone\nthe consuming end of the channel to fix this code. Even if we could, that is\nnot the technique we would want to use; instead, we want to distribute the\njobs across threads by sharing the single receiver among all the workers.\n\nAdditionally, taking a job off the channel queue involves mutating the\nreceiver, so the threads need a safe way to share and modify receiver; other-\nwise, we might get race conditions (as covered in Chapter 16).\n\nRecall the thread-safe smart pointers discussed in Chapter 16: to share\nownership across multiple threads and allow the threads to mutate the value,\nwe need to use Arc<Mutex<T>>. The Arc type will let multiple workers own\nthe receiver, and Mutex will ensure that only one worker gets a job from the\nreceiver at a time. Listing 20-18 shows the changes we need to make.\n\nuse std::sync::Arc;\nuse std::sync::Mutex;\n\nsnip\n\nimp] ThreadPool {\n\nsnip\n\npub fn new(size: usize) -> Thread!\n\nassert! (size > 0);\n\nlet (sender, receiver) = mpsc::channel();\n\n@ let receiver = Arc::new(Mutex: :new(receiver));\n\nlet mut workers = Vec::with_capac\n\nfor id in 0..size {\nworkers.push(Worker::new(id, Arc: :clone(&receiver)@)) ;\n}\n\nThreadPool {\nworkers,\n\nsender,\n\nimp] Worker {\nfn new(id: usize, receiver: Arc<Mutex<mpsc: :Receiver<Job>>>) -> Worker {\n--snip--\n\n}\n\nListing 20-18: Sharing the receiving end of the channel among the workers using Arc and\nMutex\n\nIn ThreadPool: :new, we put the receiving end of the channel in an Arc\nand a Mutex @. For each new worker, we clone the Arc to bump the reference\ncount so the workers can share ownership of the receiving end \u00ae.\n\nWith these changes, the code compiles! We're getting there!\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 20.2,
                        "section_name": "Implementing the execute Method",
                        "section_path": "./screenshots-images-2/chapter_20/section_20",
                        "images": [
                            "./screenshots-images-2/chapter_20/section_20/ab3358a4-ec22-4680-94d3-a37719fb43c3.png",
                            "./screenshots-images-2/chapter_20/section_20/ac1246d9-2ba6-4373-af6c-58cdd3b81ecb.png",
                            "./screenshots-images-2/chapter_20/section_20/19f117f3-47d5-44a9-9378-6fa387621094.png",
                            "./screenshots-images-2/chapter_20/section_20/6eb7d98b-cbbb-4de3-9048-084c3f6ce8f9.png",
                            "./screenshots-images-2/chapter_20/section_20/9d3a8de0-8361-4fb0-baef-b6287c2c8438.png",
                            "./screenshots-images-2/chapter_20/section_20/7af64987-8bb8-47df-b903-0b082e8111d1.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/lib.rs\n\n * had ~~ ball\n\nImplementing the execute Method\n\nLet's finally implement the execute method on ThreadPool. We'll also change\nJob from a struct to a type alias for a trait object that holds the type of closure\nthat execute receives. As discussed in \u201cCreating Type Synonyms with Type\nAliases\u201d on page 438, type aliases allow us to make long types shorter.\nLook at Listing 20-19.\n\ntype Job = Box<FnOnce() + Send + \u2018static>;\n\nimpl ThreadPool {\n\n-snip--\nf\n\nsrc/lib.rs\n\nF: FnOnce() + Send + \u2018static\n{\n@ let job = Box: :new(f);\n\n\u00a9 self.sender.send(job).unwrap();\n\nListing 20-19: Creating a Job type alias for a Box that holds each closure and then sending\nthe job down the channel\n\nAfter creating a new Job instance using the closure we get in execute @,\nwe send that job down the sending end of the channel \u00ae. We're calling\nunwrap on send for the case that sending fails. This might happen if, for\nexample, we stop all our threads from executing, meaning the receiving\nend has stopped receiving new messages. At the moment, we can\u2019t stop our\nthreads from executing: our threads continue executing as long as the pool\nexists. The reason we use unwrap is that we know the failure case won't hap-\npen, but the compiler doesn\u2019t know that.\n\nBut we're not quite done yet! In the worker, our closure being passed to\nthread: : spawn still only references the receiving end of the channel. Instead,\nwe need the closure to loop forever, asking the receiving end of the chan-\nnel for a job and running the job when it gets one. Let's make the change\nshown in Listing 20-20 to Worker: :new.\n\n--snip--\n\nimpl Worker {\nfn new(id: usiz\nlet thread\n\nloop {\n\nlet job = receiver. lock()@.unwrap()@. recv()@.unwrap()@;\n\nreceiver: Arc<Mutex<mpsc: :Receiver<Job>>>) -> Worker {\nthread::spawn(move || {\n\nprintln!(\"Worker {} got a job; executing.\", id);\n(*job)()5\n3\n\nWorker {\n\n}\n\nListing 20-20: Receiving and executing the jobs in the worker's thread\n\nHere, we first call lock on the receiver to acquire the mutex 0, and\nthen we call unwrap to panic on any errors \u00ae. Acquiring a lock might fail\nif the mutex is in a poisoned state, which can happen if some other thread\npanicked while holding the lock rather than releasing the lock. In this situ-\nation, calling unwrap to have this thread panic is the correct action to take.\nFeel free to change this unwrap to an expect with an error message that is\nmeaningful to you.\n\nIf we get the lock on the mutex, we call recv to receive a Job from the\nchannel \u00ae. A final unwrap moves past any errors here as well @, which might\noccur if the thread holding the sending side of the channel has shut down,\nsimilar to how the send method returns Err if the receiving side shuts down.\n\nThe call to recv blocks, so if there is no job yet, the current thread will\nwait until a job becomes available. The Mutex<T> ensures that only one Worker\nthread at a time is trying to request a job.\n\nTheoretically, this code should compile. Unfortunately, the Rust compiler\nisn\u2019t perfect yet, and we get this error:\n\nerror[E0161]: cannot move a value of type std::ops::FnOnce() +\nstd::marker::Send: the size of std::ops::FnOnce() + std::marker::Send cannot\nbe statically determined\n\n--> src/lib.rs:63:17\n\n|\n63 | (*job) ()5\n\n| AAAAAA\n\nThis error is fairly cryptic because the problem is fairly cryptic. To call\na FnOnce closure that is stored in a Box<T> (which is what our Job type alias is),\nthe closure needs to move itself out of the Box<T> because the closure takes\nownership of self when we call it. In general, Rust doesn\u2019t allow us to move\na value out of a Box<T> because Rust doesn\u2019t know how big the value inside\nthe Box<T> will be: recall in Chapter 15 that we used Box<T> precisely because\nwe had something of an unknown size that we wanted to store in a Box<T> to\nget a value of a known size.\n\nAs you saw in Listing 17-15 on page 385, we can write methods that\nuse the syntax self: Box<Self>, which allows the method to take ownership\nof a Self value stored in a Box<T>. That\u2019s exactly what we want to do here, but\nunfortunately Rust won't let us: the part of Rust that implements behavior\nwhen a closure is called isn\u2019t implemented using self: Box<Self>. So Rust\ndoesn\u2019t yet understand that it could use self: Box<Self> in this situation to\ntake ownership of the closure and move the closure out of the Box<T>.\n\nRust is still a work in progress with places where the compiler could be\nimproved, but in the future, the code in Listing 20-20 should work just fine.\nPeople just like you are working to fix this and other issues! After you've fin-\nished this book, we would love for you to join in.\n\nBut for now, let\u2019s work around this problem using a handy trick. We\ncan tell Rust explicitly that in this case we can take ownership of the value\ninside the Box<T> using self: Box<Self>; then, once we have ownership of\nthe closure, we can call it. This involves defining a new trait FnBox with the\nmethod call_box that will use self: Box<Self> in its signature, defining FnBox\n\nsrc/lib.rs\n\nfor any type that implements FnOnce(), changing our type alias to use the\nnew trait, and changing Worker to use the call_box method. These changes\nare shown in Listing 20-21.\n\ntrait FnBox {\n\u00a9 fn call_box(self: Box<Self>);\n}\nimpl<F: FnOnce()> FnBox for F {\nfn call_box(self: Box<F>) {\n@ (*self)()\n}\n\n}\n\ntype Job = Box<FnBox + Send + \u2018static>;\n\n--snip--\nimpl Worker {\nfn new(id: receiver: Arc<Mutex<mpsc: :Receiver<Job>>>) -> Worker {\nlet t = thread: :spawn(move {\nloop {\nlet job = receiver. lock().unwrap().recv().unwrap();\nprintln!(\"Worker {} got a job; executing.\", id);\n@ job.call_box();\nWorker {\n\nthread,\n\n}\n\nListing 20-21: Adding a new trait FnBox to work around the current limitations of\nBox<FnOnce()>\n\nFirst, we create a new trait named FnBox @. This trait has the one\nmethod call_box @, which is similar to the call methods on the other Fn*\ntraits except that it takes self: Box<Self> to take ownership of self and move\nthe value out of the Box<T>.\n\nNext, we implement the FnBox trait for any type F that implements the\nFnOnce() trait \u00a9. Effectively, this means that any FnOnce() closures can use\nour call_box method. The implementation of call_box uses (*self)() to move\nthe closure out of the Box<T> and call the closure 8.\n\nWe now need our Job type alias to be a Box of anything that implements\nour new trait FnBox @. This will allow us to use call_box in Worker when we\nget a Job value instead of invoking the closure directly \u00ae. Implementing the\n\nFnBox trait for any FnOnce() closure means we don't have to change anything\nabout the actual values we\u2019re sending down the channel. Now Rust is able to\nrecognize that what we want to do is fine.\n\nThis trick is very sneaky and complicated. Don\u2019t worry if it doesn\u2019t make\nperfect sense; someday, it will be completely unnecessary.\n\nWith the implementation of this trick, our thread pool is in a working\nstate! Give it a cargo run and make some requests:\n\n$ cargo run\n\nCompiling hello v0.1.0 (file:///projects/hello)\nwarning: field is never used: \u201cworkers\u201d\n--> src/lib.rs:7:5\n\n|\nworkers: Vec<Worker>,\n\n| AAAAAAAARARAAAAAAAAA\n\n7\n\nnote: #[warn(dead_code)] on by default\n\nwarning: field is never used: \u201cid\n--> src/lib.rs:61:5\n|\n\n61 | id: usize,\n| ARAAAAAAA\n|\n= note: #[warn(dead_code)] on by default\n\nwarning: field is never used: ~thread~\n--> src/lib.rs:62:5\n|\n\n62 | thread: thread: :JoinHandle<()>,\n\n| AA RAR AAR ARAARAARAABARARRARBARA\n|\n= note: #[warn(dead_code)] on by default\n\nFinished dev [unoptimized + debuginfo] target(s) in 0.99 secs\n\nRunning ~target/debug/hello\u201d\nWorker 0 got a job; executing.\nWorker 2 got a job; executing.\nWorker 1 got a job; executing.\nWorker 3 got a job; executing.\nWorker 0 got a job; executing.\nWorker 2 got a job; executing.\nWorker 1 got a job; executing.\nWorker 3 got a job; executing.\nWorker 0 got a job; executing.\nWorker 2 got a job; executing.\n\nSuccess! We now have a thread pool that executes connections asyn-\nchronously. There are never more than four threads created, so our system\nwon't get overloaded if the server receives a lot of requests. If we make a\nrequest to /sleep, the server will be able to serve other requests by having\nanother thread run them.\n\n[NOTE | If you open /sleep in multiple browser windows simultaneously, they might load one\n\nsrc/lib.rs\n\nat a time in 5 second intervals. Some web browsers execute multiple instances of the\nsame request sequentially for caching reasons. This limitation is not caused by our\nweb server.\n\nAfter learning about the while let loop in Chapter 18, you might be won-\ndering why we didn\u2019t write the worker thread code as shown in Listing 20-22.\n\n-snip--\nf\n\nimp1 Worker {\n\nfn new receiver: Arc<Mutex<mpsc: :Receiver<Job>>>) -> Worker {\n\nle thread: : spawn(move\n\n: while let Ok(job) = receiver. lock() .unwrap().recv() {\n\nprintln!(\"Worker {} got a job; executing.\", id);\n\nWorker {\n\n}\n\nListing 20-22: An alternative implementation of Worker: :new using while let\n\nThis code compiles and runs but doesn\u2019t result in the desired threading\nbehavior: a slow request will still cause other requests to wait to be processed.\nThe reason is somewhat subtle: the Mutex struct has no public unlock method\nbecause the ownership of the lock is based on the lifetime of the MutexGuard<T>\nwithin the LockResult<MutexGuard<T>> that the lock method returns. At compile\ntime, the borrow checker can then enforce the rule that a resource guarded\nby a Mutex cannot be accessed unless we hold the lock. But this implementa-\ntion can also result in the lock being held longer than intended if we don\u2019t\nthink carefully about the lifetime of the MutexGuard<T>. Because the values in\nthe while expression remain in scope for the duration of the block, the lock\nremains held for the duration of the call to job.call_box(), meaning other\nworkers cannot receive jobs.\n\nBy using loop instead and acquiring the lock and a job within the block\nrather than outside it, the MutexGuard returned from the lock method is\ndropped as soon as the let job statement ends. This ensures that the lock is\nheld during the call to recy, but it is released before the call to job.call_box(),\nallowing multiple requests to be serviced concurrently.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 20.21,
                        "section_name": "Graceful Shutdown and Cleanup",
                        "section_path": "./screenshots-images-2/chapter_20/section_21",
                        "images": [
                            "./screenshots-images-2/chapter_20/section_21/2215c846-57f1-4d80-9f31-0ebb4f530187.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Graceful Shutdown and Cleanup\n\nThe code in Listing 20-21 is responding to requests asynchronously through\nthe use of a thread pool, as we intended. We get some warnings about the\nworkers, id, and thread fields that we're not using in a direct way that reminds\nus we're not cleaning up anything. When we use the less elegant CTRL-C\nmethod to halt the main thread, all other threads are stopped immediately\nas well, even if they're in the middle of serving a request.\n\nNow we'll implement the Drop trait to call join on each of the threads in\nthe pool so they can finish the requests they're working on before closing.\nThen we'll implement a way to tell the threads they should stop accept-\ning new requests and shut down. To see this code in action, we'll modify\nour server to accept only two requests before gracefully shutting down its\nthread pool.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 20.22,
                        "section_name": "Implementing the Drop Trait on ThreadPool",
                        "section_path": "./screenshots-images-2/chapter_20/section_22",
                        "images": [
                            "./screenshots-images-2/chapter_20/section_22/91e8a3aa-8d57-46af-ac99-96239659ba51.png",
                            "./screenshots-images-2/chapter_20/section_22/57731ffc-f509-421f-8d0b-980e3e2c940d.png",
                            "./screenshots-images-2/chapter_20/section_22/278cc2c3-d5eb-4bae-9c76-8de59413200b.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/lib.rs\n\nImplementing the Drop Trait on ThreadPool\n\nLet\u2019s start with implementing Drop on our thread pool. When the pool is\ndropped, our threads should all join to make sure they finish their work.\nListing 20-23 shows a first attempt at a Drop implementation; this code won't\nquite work yet.\n\nimpl Drop for ThreadPool {\nfn drop(&mut self) {\n@ for worker in &mut self.workers {\n\u00a9 println! (\"Shutting down worker {}\", worker.id);\n\n\u00a9 worker. thread. join().unwrap();\n}\n\n}\n\nListing 20-23: Joining each thread when the thread pool goes out of scope\n\nFirst, we loop through each of the thread pool workers @. We use &mut\nfor this because self is a mutable reference, and we also need to be able\nto mutate worker. For each worker, we print a message saying that this par-\nticular worker is shutting down \u00ae, and then we call join on that worker's\nthread \u00a9. If the call to join fails, we use unwrap to make Rust panic and go\ninto an ungraceful shutdown.\n\nHere is the error we get when we compile this code:\n\nerror[E0507]: cannot move out of borrowed content\n--> src/lib.rs:65:13\n\n|\n65 | worker. thread. join().unwrap();\n| aa64* cannot move out of borrowed content\n\nThe error tells us we can\u2019t call join because we only have a mutable\nborrow of each worker and join takes ownership of its argument. To solve\nthis issue, we need to move the thread out of the Worker instance that owns\n\nthread so join can consume the thread. We did this in Listing 17-15 on\npage 385: if Worker holds an Option<thread: : JoinHandle<()> instead, we can\ncall the take method on the Option to move the value out of the Some variant\nand leave a None variant in its place. In other words, a Worker that is running\nwill have a Some variant in thread, and when we want to clean up a Worker,\nwe'll replace Some with None so the Worker doesn\u2019t have a thread to run.\n\nSo we know we want to update the definition of Worker like this:\n\nsrc/lib.rs struct Worker {\n\nid: us\n\nthread: Option<thread: : JoinHandle<()>>,\n\nNow let\u2019s lean on the compiler to find the other places that need to\nchange. Checking this code, we get two errors:\n\nerror[E0599]: no method named ~ join\u2019 found for type ~std::option: :Option<std::\nthread: :JoinHandle<()>>~ in the current scope\n--> src/lib.rs:65:27\n|\n65 | worker.thread. join().unwrap();\n| AAA\n\nerror[E0308]: mismatched types\n--> src/lib.rs:89:13\n|\n89 | thread,\n\n| ARARAA\n| |\n| expected enum \u201cstd::option::Option\u2019, found struct\n\u201cstd: :thread: :JoinHandle\u201d\n| help: try using a variant of the expected type:\n~ Some (thread) ~\n|\n= note: expected type ~std::option::Option<std: : thread: : JoinHandle<()>>~\nfound type \u201cstd: :thread: : JoinHandle<_>~\n\nLet\u2019s address the second error, which points to the code at the end of\nWorker: :new; we need to wrap the thread value in Some when we create a new\nWorker. Make the following changes to fix this error:\n\nsrc/lib.rs imp] Worker {\nfn new(id\n\n>>>) -> Worker {\n\neceiver: Arc<Mutex<mpsc: :Recei\n\nWorker {\n\nthread: Some(thread),\n\nThe first error is in our Drop implementation. We mentioned earlier that\nwe intended to call take on the Option value to move thread out of worker. The\nfollowing changes will do so:\n\nsrc/lib.rs impl D\n\np(&mut s\nfor worker ir\n\nprintln!(\"S\n\nf.workers {\n\nhutting down worker {}\", worker.id);\n\n\u00a9 if let Some(thread) = worker.thread.take() {\n\u00a9 thread. join().unwrap();\n\nAs discussed in Chapter 17, the take method on Option takes the Some\nvariant out and leaves None in its place. We're using if let to destructure the\nSome and get the thread @; then we call join on the thread \u00ae. If a worker's\nthread is already None, we know that worker has already had its thread\ncleaned up, so nothing happens in that case.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 20.23,
                        "section_name": "Signaling to the Threads to Stop Listening for Jobs",
                        "section_path": "./screenshots-images-2/chapter_20/section_23",
                        "images": [
                            "./screenshots-images-2/chapter_20/section_23/4fb7aa56-b5fe-4d6c-8817-6c3642909b38.png",
                            "./screenshots-images-2/chapter_20/section_23/330e7a62-e0f6-4514-9f86-3fd7e0c743e5.png",
                            "./screenshots-images-2/chapter_20/section_23/6eaf6f6d-c153-4e00-9d31-97ba6950eb12.png",
                            "./screenshots-images-2/chapter_20/section_23/8e0e6abb-3c7c-4d6c-8eff-e17e331e0b79.png",
                            "./screenshots-images-2/chapter_20/section_23/13ade568-9618-40aa-8f89-74fdbc77121d.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "src/lib.rs\n\nsrc/lib.rs\n\nSignaling to the Threads to Stop Listening for Jobs\n\nWith all the changes we\u2019ve made, our code compiles without any warn-\nings. But the bad news is that this code doesn\u2019t function the way we want it\nto yet. The key is the logic in the closures run by the threads of the Worker\ninstances: at the moment, we call join, but that won\u2019t shut down the threads\nbecause they loop forever looking for jobs. If we try to drop our ThreadPool\nwith our current implementation of drop, the main thread will block forever\nwaiting for the first thread to finish.\n\nTo fix this problem, we'll modify the threads so they listen for either a Job\nto run or a signal that they should stop listening and exit the infinite loop.\nInstead of Job instances, our channel will send one of these two enum variants.\n\nenum Message {\nNewJob(Job) ,\nTerminate,\n\nThis Message enum will either be a NewJob variant that holds the Job the\nthread should run, or it will be a Terminate variant that will cause the thread\nto exit its loop and stop.\n\nWe need to adjust the channel to use values of type Message rather than\ntype Job, as shown in Listing 20-24.\n\nyu truct ThreadPoo.\n\n@ sender: mpsc::Sender<Message>,\n\npub fn execute<F>(&self, f: F)\nwhere\n\nF: FnOnce() + Send + \u2018static\n\net job = Box: :new(f);\n\n\u00a9 self.sender.send(Message: :NewJob(job)).unwrap();\n}\n\nimp] Worker {\n\u00a9 fn new(id: usize, receiver: Arc<Mutex<mpsc: :Receiver<Message>>>) -> Worker {\n\npawn(move | |{\n\net thread = thread\n\nloop {\n\n\u00a9 let message = receiver.lock().unwrap().recv().unwrap();\n\nmatch message {\n\u00a9 Message: :NewJob(job) => {\nprintln! (\"Worker {} got a job; executing.\", id);\n\n@ job.call_box();\n\n,\n@ Message: :Terminate => {\nprintln!(\"Worker {} was told to terminate.\", id);\n\n\u00ae break;\nhb\n\n}\n3\n\nWorker {\nid,\n\nthread: Some(thread),\n\n}\n\nListing 20-24: Sending and receiving Message values and exiting the loop if a Worker\nreceives Message: : Terminate\n\nTo incorporate the Message enum, we need to change Job to Message in\ntwo places: the definition of ThreadPool @ and the signature of Worker: :new \u00a9.\nThe execute method of ThreadPool needs to send jobs wrapped in the\nMessage: :NewJob variant @. Then, in Worker: :new where a Message is received\n\nsrc/lib.rs\n\nfrom the channel 9, the job will be processed @ if the NewJob variant is\nreceived \u00a9, and the thread will break out of the loop @ if the Terminate\nvariant is received @.\n\nWith these changes, the code will compile and continue to function in\nthe same way as it did after Listing 20-21. But we'll get a warning because\nwe aren\u2019t creating any messages of the Terminate variety. Let\u2019s fix this warn-\ning by changing our Drop implementation to look like Listing 20-25.\n\nimpl Drop f\n\nprintln! (\"Sending terminate message to all workers.\");\n\nfor _ in &mut self.workers {\n\u00a9 self.sender.send(Message: : Terminate) .unwrap();\n\n}\nprintln!(\"Shutting down all workers.\");\n\nfor worker in &mut self.workers {\n\nprintln!(\"Shutting down worker {}\", worker. id);\n\nlet Some(thread) = worker. thread.take() {\n\n@ thread. join().unwrap();\n\nListing 20-25: Sending Message: : Terminate to the workers before calling join on each\nworker thread\n\nWe're now iterating over the workers twice: once to send one Terminate\nmessage for each worker \u00ae and once to call join on each worker's thread \u00ae.\nIf we tried to send a message and join immediately in the same loop, we\ncouldn't guarantee that the worker in the current iteration would be the\none to get the message from the channel.\n\nTo better understand why we need two separate loops, imagine a sce-\nnario with two workers. If we used a single loop to iterate through each\nworker, on the first iteration, a terminate message would be sent down the\nchannel and join called on the first worker's thread. If that first worker was\nbusy processing a request at that moment, the second worker would pick up\nthe terminate message from the channel and shut down. We would be left\nwaiting on the first worker to shut down, but it never would because the sec-\nond thread picked up the terminate message. Deadlock!\n\nTo prevent this scenario, we first put all of our Terminate messages on the\nchannel in one loop; then we join on all the threads in another loop. Each\nworker will stop receiving requests on the channel once it gets a terminate\nmessage. So, we can be sure that if we send the same number of terminate\nmessages as there are workers, each worker will receive a terminate message\nbefore join is called on its thread.\n\nsrc/bin/main.rs\n\nTo see this code in action, let\u2019s modify main to accept only two requests\nbefore gracefully shutting down the server, as shown in Listing 20-26.\n\nn main(\n\nlet listener = TcpListener: :bind(\"127.0.0.1:7878\") .unwrap() ;\n\nlet pool = ThreadPool: :new(4) ;\n\nfor stream in listener. incoming().take(2) {\n\nlet stream = stream.unwrap();\n\npool.execute(\n\nhandle_connection(stream) ;\n\nprintln! (\"Shutting down.\");\n}\n\nListing 20-26: Shut down the server after serving two requests by exiting the loop\n\nYou wouldn't want a real-world web server to shut down after serving\nonly two requests. This code just demonstrates that the graceful shutdown\nand cleanup is in working order.\n\nThe take method is defined in the Iterator trait and limits the iteration\nto the first two items at most. The ThreadPoo] will go out of scope at the end\nof main, and the drop implementation will run.\n\nStart the server with cargo run, and make three requests. The third request\nshould error, and in your terminal you should see output similar to this:\n\n$ cargo run\nCompiling hello v0.1.0 (file:///projects/hello)\nFinished dev [unoptimized + debuginfo] target(s) in 1.0 secs\n\nRunning ~target/debug/hello\u201d\n\nWorker 0 got a job; executing.\n\nWorker 3 got a job; executing.\n\nShutting down.\n\nSending terminate message to all workers.\n\nShutting down all workers.\n\nShutting down worker 0\n\nWorker 1 was told to terminate.\n\nWorker 2 was told to terminate.\n\nWorker 0 was told to terminate.\n\nWorker 3 was told to terminate.\n\nShutting down worker 1\n\nShutting down worker 2\n\nShutting down worker 3\n\nYou might see a different ordering of workers and messages printed.\n\nWe can see how this code works from the messages: workers 0 and 3\ngot the first two requests, and then on the third request, the server stopped\naccepting connections. When the ThreadPool goes out of scope at the end\nof main, its Drop implementation kicks in, and the pool tells all workers to\n\nterminate. The workers each print a message when they see the terminate\nmessage, and then the thread pool calls join to shut down each worker\nthread.\n\nNotice one interesting aspect of this particular execution: the ThreadPool\nsent the terminate messages down the channel, and before any worker\nreceived the messages, we tried to join worker 0. Worker 0 had not yet\nreceived the terminate message, so the main thread blocked waiting for\nworker 0 to finish. In the meantime, each of the workers received the ter-\nmination messages. When worker 0 finished, the main thread waited for\nthe rest of the workers to finish. At that point, they had all received the\ntermination message and were able to shut down.\n\nCongrats! We\u2019ve now completed our project; we have a basic web server\nthat uses a thread pool to respond asynchronously. We're able to perform a\ngraceful shutdown of the server, which cleans up all the threads in the pool.\nSee hitps://www.nostarch.com/Rust2018/to download the full code for this\nchapter for reference.\n\nWe could do more here! If you want to continue enhancing this project,\nhere are some ideas:\n\ne Add more documentation to ThreadPool and its public methods.\n\ne Add tests of the library\u2019s functionality.\n\ne Change calls to unwrap to more robust error handling.\n\ne Use ThreadPool to perform some task other than serving web requests.\n\ne Finda thread pool crate on https://crates.io/ and implement a similar\nweb server using the crate instead. Then compare its API and robust-\nness to the thread pool we implemented.\n",
                        "extracted-code": ""
                    },
                    {
                        "section_id": 20.24,
                        "section_name": "Summary",
                        "section_path": "./screenshots-images-2/chapter_20/section_24",
                        "images": [
                            "./screenshots-images-2/chapter_20/section_24/b2880900-7a7d-48bf-a914-aa453f6fe65e.png"
                        ],
                        "code_images": [],
                        "status": "images tested ok",
                        "errors": [],
                        "extracted-text": "Summary\n\nWell done! You've made it to the end of the book! We want to thank you\nfor joining us on this tour of Rust. You\u2019re now ready to implement your\nown Rust projects and help with other peoples\u2019 projects. Keep in mind that\nthere is a welcoming community of other Rustaceans who would love to\nhelp you with any challenges you encounter on your Rust journey.\n",
                        "extracted-code": ""
                    }
                ]
            }
        ]
    }
}