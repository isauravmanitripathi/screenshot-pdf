{
    "chapters": [
        {
            "chapter_name": "High-Speed Scientific\nComputing Using\nNumPy",
            "chapter_path": "./screenshots-images-2/chapter_1",
            "sections": [
                {
                    "section_name": "High-Speed Scientific\nComputing Using\nNumPy",
                    "section_path": "./screenshots-images-2/chapter_1/section_1",
                    "images": [
                        "./screenshots-images-2/chapter_1/section_1/0913fd9e-7a24-4609-b608-5387eb8d3244.png"
                    ],
                    "code_images": [],
                    "status": "images tested ok",
                    "errors": [],
                    "extracted-text": "This chapter introduces us to NumPy, a high-speed Python library for matrix calculations.\nMost data science/algorithmic trading libraries are built upon NumPy's functionality\nand conventions.\n\nIn this chapter, we are going to cover the following key topics:\n\nIntroduction to NumPy\n\nCreating NumPy n-dimensional arrays (ndarrays)\nData types used with NumPy arrays\n\nIndexing of ndarrays\n\nBasic ndarray operations\n\nFile operations on ndarrays\n",
                    "extracted-code": ""
                },
                {
                    "section_name": "Introduction to NumPy",
                    "section_path": "./screenshots-images-2/chapter_1/section_2",
                    "images": [
                        "./screenshots-images-2/chapter_1/section_2/fc9e5ea7-af24-45d8-9f0d-528de6976955.png"
                    ],
                    "code_images": [],
                    "status": "images tested ok",
                    "errors": [],
                    "extracted-text": "Multidimensional heterogeneous arrays can be represented in Python using lists. A list is a\n1D array, a list of lists is a 2D array, a list of lists of lists is a 3D array, and so on. However,\nthis solution is complex, difficult to use, and extremely slow.\n\nOne of the primary design goals of the NumPy Python library was to introduce\nhigh-performant and scalable structured arrays and vectorized computations.\n\nMost data structures and operations in NumPy are implemented in C/C++, which\nguarantees their superior speed.\n",
                    "extracted-code": ""
                },
                {
                    "section_name": "Creating NumPy ndarrays",
                    "section_path": "./screenshots-images-2/chapter_1/section_3",
                    "images": [
                        "./screenshots-images-2/chapter_1/section_3/12c74dc2-2a38-48a7-9fbb-1f5728b3dc8f.png"
                    ],
                    "code_images": [],
                    "status": "images tested ok",
                    "errors": [],
                    "extracted-text": "An ndarray is an extremely high-performant and space-efficient data structure for\nmultidimensional arrays.\n\nFirst, we need to import the NumPy library, as follows:\nimport numpy as np\n\nNext, we will start creating a 1D ndarray.\n",
                    "extracted-code": ""
                },
                {
                    "section_name": "Creating 1D ndarrays",
                    "section_path": "./screenshots-images-2/chapter_1/section_4",
                    "images": [
                        "./screenshots-images-2/chapter_1/section_4/d9a7dbf6-50d6-41c6-bafa-1bb9ae766880.png",
                        "./screenshots-images-2/chapter_1/section_4/3ccd1705-063c-4788-8441-256b4d38db6a.png"
                    ],
                    "code_images": [],
                    "status": "images tested ok",
                    "errors": [],
                    "extracted-text": "The following line of code creates a 1D ndarray:\n\narr1D = np.array([1.1, 2.2, 3.3, 4.4, 5.5]);\narr1D\n\nThis will give the following output:\narray([1.1, 2.2, 3.3, 4.4, 5.5])\nLet's inspect the type of the array with the following code:\n\ntype (arr1D)\n\nThis shows that the array is a NumPy ndarray, as can be seen here:\nnumpy.ndarray\n\nWe can easily create ndarrays of two dimensions or more.\n",
                    "extracted-code": ""
                },
                {
                    "section_name": "Creating 2D ndarrays",
                    "section_path": "./screenshots-images-2/chapter_1/section_5",
                    "images": [
                        "./screenshots-images-2/chapter_1/section_5/8491b2f5-22aa-46ac-922b-222d3e892d23.png"
                    ],
                    "code_images": [],
                    "status": "images tested ok",
                    "errors": [],
                    "extracted-text": "To create a 2D ndarray, use the following code:\n\narr2D = np.array([[1, 2], [3, 4]]);\narr2D\n\nThe result has two rows and each row has two values, so it is a 2 x 2 ndarray, as illustrated\nin the following code snippet:\n\narray([[1, 2],\n(3, 4]])\n",
                    "extracted-code": ""
                },
                {
                    "section_name": "Creating any-dimension ndarrays",
                    "section_path": "./screenshots-images-2/chapter_1/section_6",
                    "images": [
                        "./screenshots-images-2/chapter_1/section_6/4c25c1bc-b379-4638-832b-4e894fb9d4c6.png",
                        "./screenshots-images-2/chapter_1/section_6/f1dddcb8-71d5-417b-9def-da966b552593.png"
                    ],
                    "code_images": [],
                    "status": "images tested ok",
                    "errors": [],
                    "extracted-text": "An ndarray can construct arrays with arbitrary dimensions. The following code creates an\nndarray of 2 x 2 x 2 x 2 dimensions:\n\narr4D = np.array(range(16)).reshape((2, 2, 2, 2));\narr4D\n\nThe representation of the array is shown here:\n\narray([[[[ 0, 1],\n[ 2, 3]],\n[[ 4, 5],\n[6, 7]]l,\n((f 8, 91],\n{[10, 11]],\n[[12, 13],\n[14, 15]]]])\n\nNumPy ndarrays have a shape attribute that describes the ndarray's dimensions, as\nshown in the following code snippet:\n\narr1D.shape\n\nThe following snippet shows that arr1D is a one-dimensional array with five elements:\n(5,)\n\nWe can inspect the shape attribute on arr2D with the following code:\narr2D.shape\n\nAs expected, the output describes it as being a 2 x 2 ndarray, as we can see here:\n(2, 2)\n\nIn practice, there are certain matrices that are more frequently used, such as a matrix\nof Os, a matrix of 1s, an identity matrix, a matrix containing a range of numbers, or a\nrandom matrix. NumPy provides support for generating these frequently used ndarrays\nwith one command.\n",
                    "extracted-code": ""
                },
                {
                    "section_name": "Creating an ndarray with np.zerosv(...)",
                    "section_path": "./screenshots-images-2/chapter_1/section_7",
                    "images": [
                        "./screenshots-images-2/chapter_1/section_7/0d14eb20-40c1-4003-b334-05f6396555b7.png"
                    ],
                    "code_images": [],
                    "status": "images tested ok",
                    "errors": [],
                    "extracted-text": "The np.zeros(...) method creates an ndarray populated with all 0s, as illustrated in\nthe following code snippet:\n\nnp.zeros (shape= (2,5) )\n\nThe output is all 0s, with dimensions being 2 x 5, as illustrated in the following\ncode snippet:\n\narray([[0., 0., 0., 0., 0.],\n[0., 0., 0., 0., 0.]])\n",
                    "extracted-code": ""
                },
                {
                    "section_name": "Creating an ndarray with np.ones(...)",
                    "section_path": "./screenshots-images-2/chapter_1/section_8",
                    "images": [
                        "./screenshots-images-2/chapter_1/section_8/2cabbabe-ff3a-4e44-9922-fb1a19be7479.png"
                    ],
                    "code_images": [],
                    "status": "images tested ok",
                    "errors": [],
                    "extracted-text": "np.ones(...) is similar, but each value is assigned a value of 1 instead of 0. The\nmethod is shown in the following code snippet:\n\nnp.ones (shape=(2, 2) )\n\nThe result is a 2 x 2 ndarray with every value set to 1, as illustrated in the following\ncode snippet:\n\narray([[1., 1.],\n[1., 1.1])\n",
                    "extracted-code": ""
                },
                {
                    "section_name": "Creating an ndarray with np.identity(...)",
                    "section_path": "./screenshots-images-2/chapter_1/section_9",
                    "images": [
                        "./screenshots-images-2/chapter_1/section_9/6cc12db7-d2d7-4061-9683-86d2fa145fcb.png"
                    ],
                    "code_images": [],
                    "status": "images tested ok",
                    "errors": [],
                    "extracted-text": "Often in matrix operations we need to create an identity matrix, which is available in the\nnp.identity(...) method, as illustrated in the following code snippet:\n\nnp.identity (3)\n\nThis creates a 3 x 3 identity matrix with 1s on the diagonals and 0s everywhere else, as\nillustrated in the following code snippet:\n\narray([[1., 0., 0.],\n[0., 1., 0.],\n[o., 0., 1-11)\n",
                    "extracted-code": ""
                },
                {
                    "section_name": "Creating an ndarray with np.arange(...)",
                    "section_path": "./screenshots-images-2/chapter_1/section_10",
                    "images": [
                        "./screenshots-images-2/chapter_1/section_10/b916d308-e3ee-41d2-90dc-d8ee476309ee.png"
                    ],
                    "code_images": [],
                    "status": "images tested ok",
                    "errors": [],
                    "extracted-text": "np.arange(...) is the NumPy equivalent of the Python range (...) method. This\ngenerates values with a start value, end value, and increment, except this returns NumPy\nndarrays instead, as shown here:\n\nnp.arange (5)\nThe ndarray returned is shown here:\narray([0, 1, 2, 3, 4])\n\nBy default, values start at 0 and increment by 1.\n",
                    "extracted-code": ""
                },
                {
                    "section_name": "Creating an ndarray with np.random.randn(...)",
                    "section_path": "./screenshots-images-2/chapter_1/section_11",
                    "images": [
                        "./screenshots-images-2/chapter_1/section_11/b855f7ee-1422-4827-ab83-2c51a999c8e9.png"
                    ],
                    "code_images": [],
                    "status": "images tested ok",
                    "errors": [],
                    "extracted-text": "np.random.randn (...) generates an ndarray of specified dimensions, with each\nelement populated with random values drawn from a standard normal distribution\n(mean=0, std=1), as illustrated here:\n\nnp.random. randn (2,2)\n\nThe output is a 2 x 2 ndarray with random values, as illustrated in the following\ncode snippet:\n\narray([[ 0.57370365, -1.22229931],\n[-1.25539335, 1.11372387]])\n",
                    "extracted-code": ""
                },
                {
                    "section_name": "Data types used with NumPy ndarrays",
                    "section_path": "./screenshots-images-2/chapter_1/section_12",
                    "images": [
                        "./screenshots-images-2/chapter_1/section_12/91288dba-bdc9-4702-87b0-e54576baffbe.png"
                    ],
                    "code_images": [],
                    "status": "images tested ok",
                    "errors": [],
                    "extracted-text": "NumPy ndarrays are homogenous\u2014that is, each element in an ndarray has the same\n\ndata type. This is different from Python lists, which can have elements with different data\ntypes (heterogenous).\n\nThe np.array(...) method accepts an explicit dtype= parameter that lets us specify\nthe data type that the ndarray should use. Common data types used are np. int 32,\nnp.float\u00e94,np.float128, and np.bool. Note that np. float128 is not\nsupported on Windows.\n\nThe primary reason why you should be conscious about the various numeric types for\nndarrays is the memory usage\u2014the more precision the data type provides, the larger\nmemory requirements it has. For certain operations, a smaller data type may be just enough.\n",
                    "extracted-code": ""
                },
                {
                    "section_name": "Creating a numpy.float64 array",
                    "section_path": "./screenshots-images-2/chapter_1/section_13",
                    "images": [
                        "./screenshots-images-2/chapter_1/section_13/0dc0ca43-e710-4ef6-87ff-538df5d0ca48.png"
                    ],
                    "code_images": [],
                    "status": "images tested ok",
                    "errors": [],
                    "extracted-text": "To create a 128-bit floating-values array, use the following code:\nnp.array([-1, 0, 1], dtype=np.float64)\nThe output is shown here:\n\narray([-1., 0., 1.], dtype=float64)\n",
                    "extracted-code": ""
                },
                {
                    "section_name": "Creating a numpy.bool array",
                    "section_path": "./screenshots-images-2/chapter_1/section_14",
                    "images": [
                        "./screenshots-images-2/chapter_1/section_14/8733815e-e47c-47d3-bcb4-0fa1769de779.png"
                    ],
                    "code_images": [],
                    "status": "images tested ok",
                    "errors": [],
                    "extracted-text": "We can create an ndarray by converting specified values to the target type. In the following\ncode example, we see that even though integer data values were provided, the resulting\nndarray has dt ype as bool, since the data type was specified to be np. bool:\n\nnp.array([-1, 0, 1], dtype=np.bool)\nThe values are shown here:\narray([ True, False, True] )\n\nWe observe that the integer values (-1, 0, 1) were converted to bool values (True,\nFalse, True). 0 gets converted to False, and all other values get converted to True.\n",
                    "extracted-code": ""
                },
                {
                    "section_name": "ndarrays' dtype attribute",
                    "section_path": "./screenshots-images-2/chapter_1/section_15",
                    "images": [
                        "./screenshots-images-2/chapter_1/section_15/bc5ee00f-407e-4ef0-90ce-95b6e48248e9.png"
                    ],
                    "code_images": [],
                    "status": "images tested ok",
                    "errors": [],
                    "extracted-text": "ndarrays have a dt ype attribute to inspect the data type, as shown here:\narr1D.dtype\nThe output is a NumPy dtype object with a float64 value, as illustrated here:\n\ndtype('floate\u00e94')\n",
                    "extracted-code": ""
                },
                {
                    "section_name": "Converting underlying data types of ndarray with\nnumpy.ndarrays.astype(...)",
                    "section_path": "./screenshots-images-2/chapter_1/section_16",
                    "images": [
                        "./screenshots-images-2/chapter_1/section_16/79e0ec9e-cc0f-4702-a61a-c50b75097625.png"
                    ],
                    "code_images": [],
                    "status": "images tested ok",
                    "errors": [],
                    "extracted-text": "We can easily convert the underlying data type of an ndarray to any other compatible\ndata type with the numpy .ndarrays.astype(...) method. For example, to convert\narr1D from np. float64 to np. int\u00e94, we use the following code:\n\narrlD.astype (np.int64) .dtype\nThis reflects the new data type, as follows:\ndtype('int6\u00e94')\n\nWhen numpy.ndarray.astype(...) converts to a narrower data type, it will\ntruncate the values, as follows:\n\narr1D.astype (np. int64)\nThis converts arr1D to the following integer-valued ndarray:\narray([1, 2, 3, 4, 5])\n\nThe original floating values (1.1, 2.2, ...) are converted to their truncated integer values\n(1, 2, ...).\n",
                    "extracted-code": ""
                },
                {
                    "section_name": "Indexing of ndarrays",
                    "section_path": "./screenshots-images-2/chapter_1/section_17",
                    "images": [
                        "./screenshots-images-2/chapter_1/section_17/990e4343-d462-477a-a181-1a38f5f0fb76.png"
                    ],
                    "code_images": [],
                    "status": "images tested ok",
                    "errors": [],
                    "extracted-text": "Array indexing refers to the way of accessing a particular array element or elements. In\nNumPy, all ndarray indices are zero-based\u2014that is, the first item of an array has index 0.\nNegative indices are understood as counting from the end of the array.\n",
                    "extracted-code": ""
                },
                {
                    "section_name": "Direct access to an ndarray's element",
                    "section_path": "./screenshots-images-2/chapter_1/section_18",
                    "images": [
                        "./screenshots-images-2/chapter_1/section_18/151f3cf1-fbcf-44de-8e71-52f2c2034582.png",
                        "./screenshots-images-2/chapter_1/section_18/fca6d7ff-9c70-4778-998f-df65e622a3a4.png"
                    ],
                    "code_images": [],
                    "status": "images tested ok",
                    "errors": [],
                    "extracted-text": "Direct access to a single ndarray's element is one of the most used forms of access.\n\nThe following code builds a 3 x 3 random-valued ndarray for our use:\n\narr = np.random.randn (3,3) ;\narr\n\nThe arr ndarray has the following elements:\n\narray ([[-0.04113926, -0.273338 , -1.05294723],\n[ 1.65004669, -0.09589629, 0.15586867],\n[ 0.39533427, 1.47193681, 0.32148741]])\n\nWe can index the first element with integer index 0, as follows:\narr [0]\n\nThis gives us the first row of the arr ndarray, as follows:\narray ([-0.04113926, -0.273338 , -1.05294723])\n\nWe can access the element at the second column of the first row by using the\nfollowing code:\n\narr[0] [1]\nThe result is shown here:\n-0.2733379996693689\n\nndarrays also support an alternative notation to perform the same operation, as\nillustrated here:\n\narr[0, 1]\nIt accesses the same element as before, as can be seen here:\n-0.2733379996693689\n\nThe numpy.ndarray[index_0, index_1, .. index_n] notation is especially\nmore concise and useful when accessing ndarrays with very large dimensions.\n\nNegative indices start from the end of the ndarray, as illustrated here:\narr[-1]\nThis returns the last row of the ndarray, as follows:\n\narray ([0.39533427, 1.47193681, 0.32148741])\n",
                    "extracted-code": ""
                },
                {
                    "section_name": "ndarray slicing",
                    "section_path": "./screenshots-images-2/chapter_1/section_19",
                    "images": [
                        "./screenshots-images-2/chapter_1/section_19/922ebabb-8ab2-4135-b723-635633ee858d.png"
                    ],
                    "code_images": [],
                    "status": "images tested ok",
                    "errors": [],
                    "extracted-text": "While single ndarray access is useful, for bulk processing we require access to multiple\nelements of the array at once (for example, if the ndarray contains all daily prices of an\nasset, we might want to process only all Mondays' prices).\n\nSlicing allows access to multiple ndarray records in one command. Slicing ndarrays also\nworks similarly to slicing of Python lists.\n\nThe basic slice syntax is i:j:k, where i is the index of the first record we want to include, j is\nthe stopping index, and k is the step.\n",
                    "extracted-code": ""
                },
                {
                    "section_name": "Accessing all ndarray elements after the first one",
                    "section_path": "./screenshots-images-2/chapter_1/section_20",
                    "images": [
                        "./screenshots-images-2/chapter_1/section_20/a05eaf41-f740-425f-aaf7-187dd9854e80.png"
                    ],
                    "code_images": [],
                    "status": "images tested ok",
                    "errors": [],
                    "extracted-text": "To access all elements after the first one, we can use the following code:\narr[1:]\nThis returns all the rows after the first one, as illustrated in the following code snippet:\n\narray([[ 1.65004669, -0.09589629, 0.15586867],\n[ 0.39533427, 1.47193681, 0.32148741]])\n",
                    "extracted-code": ""
                },
                {
                    "section_name": "Fetching all rows, starting from row 2 and columns 1 and 2",
                    "section_path": "./screenshots-images-2/chapter_1/section_21",
                    "images": [
                        "./screenshots-images-2/chapter_1/section_21/6c73fe68-dd8d-4013-ba37-c8f22664411d.png"
                    ],
                    "code_images": [],
                    "status": "images tested ok",
                    "errors": [],
                    "extracted-text": "Similarly, to fetch all rows starting from the second one, and columns up to but not\nincluding the third one, run the following code:\n\narr[1:, :2]\nThis is a 2 x 2 ndarray as expected, as can be seen here:\n\narray([[ 1.65004669, -0.09589629],\n[ 0.39533427, 1.47193681]])\n",
                    "extracted-code": ""
                },
                {
                    "section_name": "Slicing with negative indices",
                    "section_path": "./screenshots-images-2/chapter_1/section_22",
                    "images": [
                        "./screenshots-images-2/chapter_1/section_22/8f089149-70db-41d4-ada1-efee85f63d3a.png"
                    ],
                    "code_images": [],
                    "status": "images tested ok",
                    "errors": [],
                    "extracted-text": "More complex slicing notation that mixes positive and negative index ranges is also\npossible, as follows:\n\narr[1:2, -2:-1]\n\nThis is a less intuitive way of finding the slice of an element at the second row and at the\nsecond column, as illustrated here:\n\narray ([[-0.09589629]])\n",
                    "extracted-code": ""
                },
                {
                    "section_name": "Slicing with no indices",
                    "section_path": "./screenshots-images-2/chapter_1/section_23",
                    "images": [
                        "./screenshots-images-2/chapter_1/section_23/9a38cc6e-61ec-45c2-9984-612cf3d3b631.png"
                    ],
                    "code_images": [],
                    "status": "images tested ok",
                    "errors": [],
                    "extracted-text": "Slicing with no indices yields the entire row/column. The following code generates a slice\ncontaining all elements on the third row:\n\narr[:] [2]\nThe output is shown here:\narray ([0.39533427, 1.47193681, 0.32148741])\nThe following code generates a slice of the original arr ndarray:\narr[:] [:]\n\nThe output is shown here:\n\narray ([[-0.04113926, -0.273338 , -1.05294723],\n[ 1.65004669, -0.09589629, 0.15586867],\n[ 0.39533427, 1.47193681, 0.32148741]])\n\nom oat\n\n",
                    "extracted-code": ""
                },
                {
                    "section_name": "Setting values of a slice to 0",
                    "section_path": "./screenshots-images-2/chapter_1/section_24",
                    "images": [
                        "./screenshots-images-2/chapter_1/section_24/249c23c4-3878-4116-9a4d-e5598d5a6509.png",
                        "./screenshots-images-2/chapter_1/section_24/1affe76d-7f3e-4ad1-a2db-72eb8c27ea3c.png",
                        "./screenshots-images-2/chapter_1/section_24/5884f850-656d-4392-8cbe-8accf671e05a.png"
                    ],
                    "code_images": [],
                    "status": "images tested ok",
                    "errors": [],
                    "extracted-text": "-\n\nFrequently, we will need to set certain values of an ndarray to a given value.\n\nLet's generate a slice containing the second row of arr and assign it to a new variable,\narr1, as follows:\n\narrl = arr[1:2];\narrl\n\narr1 now contains the last row, as shown in the following code snippet:\narray([[ 1.65004669, -0.09589629, 0.15586867]]\nNow, let's set every element of arr1 to the value 0, as follows:\n\narrl1[:] = 0;\narrl\n\nAs expected, arr1 now contains all 0s, as illustrated here:\narray([[0., 0., 0.]])\n\nNow, let's re-inspect our original arr ndarray, as follows:\narr\n\nThe output is shown here:\n\narray ([[-0.04113926, -0.273338 , -1.05294723],\n[ 0. , 0. 7 Oo ],\n[ 0.39533427, 1.47193681, 0.32148741]])\n\nWe see that our operation on the arr1 slice also changed the original arr ndarray. This\nbrings us to the most important point: ndarray slices are views into the original ndarrays,\nnot copies.\n\nIt is important to remember this when working with ndarrays so that we do not\ninadvertently change something we did not mean to. This design is purely for efficiency\nreasons, since copying large ndarrays incurs large overheads.\n\nTo create a copy of an ndarray, we explicitly call the numpy.ndarray.copy(...)\nmethod, as follows:\n\narr_copy = arr.copy()\nNow, let's change some values in the arr_copy ndarray, as follows:\n\narr_copy[1:2] = 1;\narr_copy\n\nWe can see the change in arr_copy in the following code snippet:\n\narray ([[-0.04113926, -0.273338 , -1.05294723],\nI i. , i. , i. 1,\n[ 0.39533427, 1.47193681, 0.32148741]])\n\nLet's inspect the original arr ndarray as well, as follows:\narr\nThe output is shown here:\n\narray ([[-0.04113926, -0.273338 , -1.05294723],\n[ 0. , 0. 7 Oo 1,\n[ 0.39533427, 1.47193681, 0.32148741]])\n\nWe see that the original ndarray is unchanged since arr_copy is a copy of arr and nota\nreference/view to it.\n",
                    "extracted-code": ""
                },
                {
                    "section_name": "Boolean indexing",
                    "section_path": "./screenshots-images-2/chapter_1/section_25",
                    "images": [
                        "./screenshots-images-2/chapter_1/section_25/f56f6551-a4fa-498c-b3be-1e12a4ecb7d5.png",
                        "./screenshots-images-2/chapter_1/section_25/69e87433-7e12-4d3c-a5a7-f5d7b89407dd.png"
                    ],
                    "code_images": [],
                    "status": "images tested ok",
                    "errors": [],
                    "extracted-text": "NumPy provides multiple ways of indexing ndarrays. NumPy arrays can be indexed by\nusing conditions that evaluate to True or False. Let's start by regenerating an arr\nndarray, as follows:\n\narr = np.random.randn (3,3) ;\n\narr\nThis is a 3 x 3 ndarray with random values, as can be seen in the following code snippet:\n\narray ([[-0.50566069, -0.52115534, 0.0757591 J,\n[ 1.67500165, -0.99280199, 0.80878346],\n[ 0.56937775, 0.36614928, -0.02532004]])\n\nLet's revisit the output of running the following code, which is really just calling the\nnp.less(...) universal function (ufunc)\u2014that is, the result of the following code is\nidentical to calling thenp.less(arr, 0)) method:\n\narr < 0\n\nThis generates another ndarray of True and False values, where True means the\ncorresponding element in arr was negative and False means the corresponding element\nin arr was not negative, as illustrated in the following code snippet:\n\narray([[ True, True, False],\n[False, True, False],\n[False, False, True]])\n\nWe can use that array as an index to arr to find the actual negative elements, as follows:\narr[(arr < 0)]\n\nAs expected, this fetches the following negative values:\narray ([-0.50566069, -0.52115534, -0.99280199, -0.02532004])\n\nWe can combine multiple conditions with & (and) and | (or) operators. Python's & and |\nBoolean operators do not work on ndarrays since they are for scalars. An example of a &\noperator is shown here:\n\n(arr > -1) & (arr < 1)\n\nThis generates an ndarray with the value True, where the elements are between -1 and 1\nand False otherwise, as illustrated in the following code snippet:\n\narray([[ True, True, True],\n[False, True, True],\n[ True, True, True]])\n\nAs we saw before, we can use that Boolean array to index arr and find the actual\nelements, as follows:\n\narr[((arr > -1) & (arr < 1))]\nThe following output is an array of elements that satisfied the condition:\n\narray ([-0.50566069, -0.52115534, 0.0757591 , -0.99280199,\n0.80878346,\n\n0.56937775, 0.36614928, -0.02532004] )\n",
                    "extracted-code": ""
                },
                {
                    "section_name": "Indexing with arrays",
                    "section_path": "./screenshots-images-2/chapter_1/section_26",
                    "images": [
                        "./screenshots-images-2/chapter_1/section_26/be43c3b8-1e2c-475e-ac46-039a991ebb21.png"
                    ],
                    "code_images": [],
                    "status": "images tested ok",
                    "errors": [],
                    "extracted-text": "ndarray indexing also allows us to directly pass lists of indices of interest. Let's first\ngenerate an ndarray of random values to use, as follows:\n\narr\nThe output is shown here:\n\narray ([[-0.50566069, -0.52115534, 0.0757591 J,\n[ 1.67500165, -0.99280199, 0.80878346],\n[ 0.56937775, 0.36614928, -0.02532004]])\n\nWe can select the first and third rows, using the following code:\narr[[0, 2]]\nThe output is a 2 x 3 ndarray containing the two rows, as illustrated here:\n\narray ([[-0.50566069, -0.52115534, 0.0757591 J,\n[ 0.56937775, 0.36614928, -0.02532004]])\n\nWe can combine row and column indexing using arrays, as follows:\narr[[0, 2], [1]]\n\nThe preceding code gives us the second column of the first and third rows, as follows:\narray ([-0.52115534, 0.36614928])\n\nWe can also change the order of the indices passed, and this is reflected in the output. The\nfollowing code picks out the third row followed by the first row, in that order:\n\narr[[2, 0]]\n\nThe output reflects the two rows in the order we expected (third row first; first row\nsecond), as illustrated in the following code snippet:\n\narray([[ 0.56937775, 0.36614928, -0.02532004],\n[-0.50566069, -0.52115534, 0.0757591 ]])\n\nNow that we have learned how to create ndarrays and about the various ways to retrieve\nthe values of their elements, let's discuss the most common ndarray operations.\n",
                    "extracted-code": ""
                },
                {
                    "section_name": "Basic ndarray operations",
                    "section_path": "./screenshots-images-2/chapter_1/section_27",
                    "images": [
                        "./screenshots-images-2/chapter_1/section_27/491b01be-94f6-42e2-88a6-ac837b45779f.png"
                    ],
                    "code_images": [],
                    "status": "images tested ok",
                    "errors": [],
                    "extracted-text": "In the following examples, we will use an arr2D ndarray, as illustrated here:\narr2D\nThis is a 2 x 2 ndarray with values from 1 to 4, as shown here:\n\narray([[1, 2],\n(3, 4]])\n",
                    "extracted-code": ""
                },
                {
                    "section_name": "Scalar multiplication with an ndarray",
                    "section_path": "./screenshots-images-2/chapter_1/section_28",
                    "images": [
                        "./screenshots-images-2/chapter_1/section_28/e016de88-f95f-4b96-a7fd-ed873e188282.png"
                    ],
                    "code_images": [],
                    "status": "images tested ok",
                    "errors": [],
                    "extracted-text": "Scalar multiplication with an ndarray has the effect of multiplying each element of the\nndarray, as illustrated here:\n\narr2D * 4\nThe output is shown here:\n\narray([[ 4, 8],\n[12, 16]])\n",
                    "extracted-code": ""
                },
                {
                    "section_name": "Linear combinations of ndarrays",
                    "section_path": "./screenshots-images-2/chapter_1/section_29",
                    "images": [
                        "./screenshots-images-2/chapter_1/section_29/4e66f2df-3b6f-439a-829d-02b13863ee57.png"
                    ],
                    "code_images": [],
                    "status": "images tested ok",
                    "errors": [],
                    "extracted-text": "The following operation is a combination of scalar and ndarray operations, as well as\noperations between ndarrays:\n\n2*arr2D + 3*arr2D\nThe output is what we would expect, as can be seen here:\n\narray([[ 5, 10],\n[15, 20]])\n",
                    "extracted-code": ""
                },
                {
                    "section_name": "Exponentiation of ndarrays",
                    "section_path": "./screenshots-images-2/chapter_1/section_30",
                    "images": [
                        "./screenshots-images-2/chapter_1/section_30/d919f4e0-f210-473c-b9f5-cd8409303a25.png",
                        "./screenshots-images-2/chapter_1/section_30/2ad6ccc3-c931-45c0-87df-19741b315161.png"
                    ],
                    "code_images": [],
                    "status": "images tested ok",
                    "errors": [],
                    "extracted-text": "We can raise each element of the ndarray to a certain power, as illustrated here:\n\narr2D ** 2\n\nThe output is shown here:\n",
                    "extracted-code": ""
                },
                {
                    "section_name": "Addition of an ndarray with a scalar",
                    "section_path": "./screenshots-images-2/chapter_1/section_31",
                    "images": [
                        "./screenshots-images-2/chapter_1/section_31/3a96d301-e964-4f97-8961-e1be8a729223.png"
                    ],
                    "code_images": [],
                    "status": "images tested ok",
                    "errors": [],
                    "extracted-text": "Addition of an ndarray with a scalar works similarly, as illustrated here:\narr2D + 10\nThe output is shown here:\n\narray([[11, 12],\n[13, 14]])\n",
                    "extracted-code": ""
                },
                {
                    "section_name": "Transposing a matrix",
                    "section_path": "./screenshots-images-2/chapter_1/section_32",
                    "images": [
                        "./screenshots-images-2/chapter_1/section_32/a90e03b3-abac-4455-aa50-40c51f47142f.png"
                    ],
                    "code_images": [],
                    "status": "images tested ok",
                    "errors": [],
                    "extracted-text": "Finding the transpose of a matrix, which is a common operation, is possible in NumPy\nwith the numpy.ndarray.transpose(...) method, as illustrated in the following\ncode snippet:\n\narr2D.transpose ()\nThis transposes the ndarray and outputs it, as follows:\n\narray([[1, 3],\n[2, 4]])\n",
                    "extracted-code": ""
                },
                {
                    "section_name": "Changing the layout of an ndarray",
                    "section_path": "./screenshots-images-2/chapter_1/section_33",
                    "images": [
                        "./screenshots-images-2/chapter_1/section_33/6cc85cc7-770d-4ff2-b3aa-8e493a545d8d.png",
                        "./screenshots-images-2/chapter_1/section_33/06f2d216-f111-43fb-979e-d18fd7a819d1.png"
                    ],
                    "code_images": [],
                    "status": "images tested ok",
                    "errors": [],
                    "extracted-text": "The np .ndarray.reshape(...) method allows us to change the layout (shape) of\nthe ndarray without changing its data to a compatible shape.\n\nFor instance, to reshape arr2D from 2 x 2 to 4x 1, we use the following code:\n\narr2D.reshape((4, 1))\n\nThe new reshaped 4 x 1 ndarray is displayed here:\n\narray([[1],\n(21,\n(31,\n[4]])\n\nThe following code example combines np. random. randn(. .\n\nreshape(...) to create a3 x 3 ndarray of random values:\n\narr = np.random.randn(9) .reshape((3,3));\narr\n\nThe generated 3 x 3 ndarray is shown here:\n\narray([[ 0.24344963, -0.53183761, 1.08906941],\n[-1.71144547, -0.03195253, 0.82675183],\n\n.) andnp.ndarray.\n\n[-2.24987291, 2.60439882, -0.09449784]])\n",
                    "extracted-code": ""
                },
                {
                    "section_name": "Finding the minimum value in an ndarray",
                    "section_path": "./screenshots-images-2/chapter_1/section_34",
                    "images": [
                        "./screenshots-images-2/chapter_1/section_34/c940536c-1513-43fd-9061-e23fc10defd4.png"
                    ],
                    "code_images": [],
                    "status": "images tested ok",
                    "errors": [],
                    "extracted-text": "To find the minimum value in an ndarray, we use the following command:\nnp.min (arr)\nThe result is shown here:\n\n-2.249872908111852\n",
                    "extracted-code": ""
                },
                {
                    "section_name": "Calculating the absolute value",
                    "section_path": "./screenshots-images-2/chapter_1/section_35",
                    "images": [
                        "./screenshots-images-2/chapter_1/section_35/2031f71a-cb4a-4706-b677-4ed2e54d1913.png"
                    ],
                    "code_images": [],
                    "status": "images tested ok",
                    "errors": [],
                    "extracted-text": "The np.abs(...) method, shown here, calculates the absolute value of an ndarray:\nnp.abs (arr)\nThe output ndarray is shown here:\n\narray ([[0.24344963, 0.53183761, 1.08906941],\n[1.71144547, 0.03195253, 0.82675183],\n[2.24987291, 2.60439882, 0.09449784]])\n",
                    "extracted-code": ""
                },
                {
                    "section_name": "Calculating the mean of an ndarray",
                    "section_path": "./screenshots-images-2/chapter_1/section_36",
                    "images": [
                        "./screenshots-images-2/chapter_1/section_36/8a2a913a-10ea-4936-a15e-965f61f02ba6.png"
                    ],
                    "code_images": [],
                    "status": "images tested ok",
                    "errors": [],
                    "extracted-text": "The np.mean(...) method, shown here, calculates the mean of all elements in\nthe ndarray:\n\nnp.mean (arr)\n\nThe mean of the elements of arr is shown here:\n0.01600703714906236\n\nWe can find the mean along the columns by specifying the axis= parameter, as follows:\nnp.mean(arr, axis=0)\n\nThis returns the following array, containing the mean for each column:\narray ([-1.23928958, 0.68020289, 0.6071078 ])\n\nSimilarly, we can find the mean along the rows by running the following code:\nnp.mean(arr, axis=1)\n\nThat returns the following array, containing the mean for each row:\n\narray([ 0.26689381, -0.30554872, 0.08667602])\n",
                    "extracted-code": ""
                },
                {
                    "section_name": "Finding the index of the maximum value in an ndarray",
                    "section_path": "./screenshots-images-2/chapter_1/section_37",
                    "images": [
                        "./screenshots-images-2/chapter_1/section_37/4a322d95-e4f1-4e97-abfd-d8d357606bc3.png",
                        "./screenshots-images-2/chapter_1/section_37/1cd0fa92-0bc9-46cd-bd3d-698fec6703af.png"
                    ],
                    "code_images": [],
                    "status": "images tested ok",
                    "errors": [],
                    "extracted-text": "Often, we're interested in finding where in an array its largest value is. The\nnp.argmax(...) method finds the location of the maximum value in the ndarray,\nas follows:\n\nnp.argmax (arr)\n\nThis returns the following value, to represent the location of the maximum value\n(2.60439882):\n\n7\n\nThe np .argmax(...) method also accepts the axis= parameter to perform the\noperation row-wise or column-wise, as illustrated here:\n\nnp.argmax(arr, axis=1)\n\nThis finds the location of the maximum value on each row, as follows:\n\narray([2, 2, 1], dtype=int64)\n",
                    "extracted-code": ""
                },
                {
                    "section_name": "Calculating the cumulative sum of elements of an\nndarray",
                    "section_path": "./screenshots-images-2/chapter_1/section_38",
                    "images": [
                        "./screenshots-images-2/chapter_1/section_38/d8d657e1-ebb3-4847-b2f0-e31898bd6883.png"
                    ],
                    "code_images": [],
                    "status": "images tested ok",
                    "errors": [],
                    "extracted-text": "To calculate the running total, NumPy provides the np. cumsum(...) method. The\nnp.cumsum(...) method, illustrated here, finds the cumulative sum of elements in\nthe ndarray:\n\nnp.cumsum(arr)\nThe output provides the cumulative sum after each additional element, as follows:\n\narray([ 0.24344963, -0.28838798, 0.80068144, -0.91076403,\n-0.94271656,\n-0.11596474, -2.36583764, 0.23856117, 0.14406333])\n\nNotice the difference between a cumulative sum and a sum. A cumulative sum is an array\nof a running total, whereas a sum is a single number.\n\nApplying the axis= parameter to the cumsum method works similarly, as illustrated in\nthe following code snippet:\n\nnp.cumsum(arr, axis=1)\nThis goes row-wise and generates the following array output:\n\narray([[ 0.24344963, -0.28838798, 0.80068144],\n[-1.71144547, -1.743398 , -0.91664617],\n[-2.24987291, 0.35452591, 0.26002807]])\n",
                    "extracted-code": ""
                },
                {
                    "section_name": "Finding NaNs in an ndarray",
                    "section_path": "./screenshots-images-2/chapter_1/section_39",
                    "images": [
                        "./screenshots-images-2/chapter_1/section_39/21c0d022-4949-4c1d-afed-533fade47cd7.png",
                        "./screenshots-images-2/chapter_1/section_39/73a432b6-207c-4a0b-92e4-8169b25d4132.png"
                    ],
                    "code_images": [],
                    "status": "images tested ok",
                    "errors": [],
                    "extracted-text": "Missing or unknown values are often represented in NumPy using a Not a Number\n(NaN) value. For many numerical methods, these must be removed or replaced with\nan interpolation.\n\nFirst, let's set the second row to np .nan, as follows:\n\narr[1, :] = np.nan;\narr\n\nThe new ndarray has the NaN values, as illustrated in the following code snippet:\n\narray([[ 0.64296696, -1.35386668, -0.63063743],\n[ nan, nan, nan],\n[-0.19093967, -0.93260398, -1.58520989]])\n\nThe np.isnan(...) ufunc finds if values in an ndarray are NaNs, as follows:\nnp.isnan (arr)\n\nThe output is an ndarray with a True value where NaNs exist and a False value where\nNaNs do not exist, as illustrated in the following code snippet:\n\narray([[False, False, False],\n[ True, True, True],\n[False, False, False]])\n",
                    "extracted-code": ""
                },
                {
                    "section_name": "Finding the truth values of x1>x2 of two ndarrays",
                    "section_path": "./screenshots-images-2/chapter_1/section_40",
                    "images": [
                        "./screenshots-images-2/chapter_1/section_40/4c064468-f04e-4af5-86fd-84dfb7088ec6.png",
                        "./screenshots-images-2/chapter_1/section_40/a4f94549-2f54-411e-a639-f6845993e973.png"
                    ],
                    "code_images": [],
                    "status": "images tested ok",
                    "errors": [],
                    "extracted-text": "Boolean ndarrays are an efficient way of obtaining indices for values of interest. Using\nBoolean ndarrays is far more performant than looping over the matrix elements one by one.\n\nLet's build another arr1 ndarray with random values, as follows:\n\narrl = np.random.randn (9) .reshape((3,3));\narrl\n\nThe result is a 3 x 3 ndarray, as illustrated in the following code snippet:\n\narray([[ 0.32102068, -0.51877544, -1.28267292],\n[-1.34842617, 0.61170993, -0.5561239 J,\n[ 1.41138027, -2.4951374 , 1.30766648]]\n\nSimilarly, let's build another arr2 ndarray, as follows:\n\narr2 = np.random.randn(9) .reshape((3,3));\narr2\n\nThe output is shown here:\n\narray([[ 0.33189432, 0.82416396, -0.17453351],\n[-1.59689203, -0.42352094, 0.22643589],\n[-1.80766151, 0.26201455, -0.08469759]]\n\nThenp.greater(...) function is a binary ufunc that generates a True value when\nthe left-hand-side value in the ndarray is greater than the right-hand-side value in the\nndarray. This function can be seen here:\n\nnp.greater(arrl, arr2)\n\nThe output is an ndarray of True and False values as described previously, as we can\nsee here:\n\narray([[False, False, False],\n[ True, True, False],\n[ True, False, True]])\n\nThe > infix operator, shown in the following snippet, is a shorthand of\nnumpy.greater(...):\n\narrl > arr2\nThe output is the same, as we can see here:\n\narray([[False, False, False],\n[ True, True, False],\n[ True, False, True]])\n",
                    "extracted-code": ""
                },
                {
                    "section_name": "any and all Boolean operations on ndarrays",
                    "section_path": "./screenshots-images-2/chapter_1/section_41",
                    "images": [
                        "./screenshots-images-2/chapter_1/section_41/2f148e09-20bb-4019-9dc7-3447a22608ea.png",
                        "./screenshots-images-2/chapter_1/section_41/0d5521c6-7b88-4a5f-9dfc-4ad0dfac366f.png"
                    ],
                    "code_images": [],
                    "status": "images tested ok",
                    "errors": [],
                    "extracted-text": "In addition to relational operators, NumPy supports additional methods for testing\nconditions on matrices\u2019 values.\n\nThe following code generates an ndarray containing True for elements that satisfy the\ncondition, and False otherwise:\n\narr_bool = (arr > -0.5) & (arr < 0.5);\narr_bool\n\nThe output is shown here:\n\narray([[False, False, True],\n[False, False, False],\n[False, True, True]])\n\nThe following numpy .ndarray.any(...) method returns True if any element is\nTrue and otherwise returns False:\n\narr_bool.any()\nHere, we have at least one element that is True, so the output is True, as shown here:\nTrue\n\nAgain, it accepts the common axis= parameter and behaves as expected, as we can\nsee here:\n\narr_bool.any(axis=1)\nAnd the operation performed row-wise yields, as follows:\narray([True, False, True] )\n\nThe following numpy.ndarray.all(...) method returns True when all elements\nare True, and False otherwise:\n\narr_bool.all1()\nThis returns the following, since not all elements are True:\nFalse\nIt also accepts the axis= parameter, as follows:\narr_bool.all(axis=1)\nAgain, each row has at least one False value, so the output is False, as shown here:\n\narray([False, False, False] )\n",
                    "extracted-code": ""
                },
                {
                    "section_name": "Sorting ndarrays",
                    "section_path": "./screenshots-images-2/chapter_1/section_42",
                    "images": [
                        "./screenshots-images-2/chapter_1/section_42/f948f83e-a66c-4408-8c31-2994a08ec97a.png",
                        "./screenshots-images-2/chapter_1/section_42/c365bb51-f803-47c1-9f88-eab265f63a2a.png",
                        "./screenshots-images-2/chapter_1/section_42/ecbecc8e-bc6f-4fce-98df-d3a3240ed441.png"
                    ],
                    "code_images": [],
                    "status": "images tested ok",
                    "errors": [],
                    "extracted-text": "Finding an element in a sorted ndarray is faster than processing all elements of the ndarray.\n\nLet's generate a 1D random array, as follows:\n\narr1D = np.random.randn(10) ;\n\narr1D\n\nThe ndarray contains the following data:\n\narray([ 1.14322028, 1.61792721, -1.01446969, 1.26988026,\n-0.20110113,\n\n-0.28283051, 0.73009565, -0.68766388, 0.27276319,\n-0.7135162 ])\n\nThenp.sort(...) method is pretty straightforward, as can be seen here:\nnp.sort (arr1D)\nThe output is shown here:\n\narray ([-1.01446969, -0.7135162 , -0.68766388, -0.28283051,\n-0.20110113,\n\n0.27276319, 0.73009565, 1.14322028, 1.26988026,\n1.61792721] )\n\nLet's inspect the original ndarray to see if it was modified by the numpy. sort (.. .)\noperation, as follows:\n\narr1D\nThe following output shows that the original array is unchanged:\n\narray([ 1.14322028, 1.61792721, -1.01446969, 1.26988026,\n-0.20110113,\n\n-0.28283051, 0.73009565, -0.68766388, 0.27276319,\n-0.7135162 ])\n\nThe following np.argsort (...) method creates an array of indices that represent the\nlocation of each element in a sorted array:\n\nnp.argsort (arr1D)\nThe output of this operation generates the following array:\narray([2, 9, 7, 5, 4, 8, 6, 0, 3, 1])\n\nNumPy ndarrays have the numpy.ndarray.sort (...) method as well, which sorts\narrays in place. This method is illustrated in the following code snippet:\n\narr1D.sort ()\n\nnp.argsort (arr1D)\n\nAfter the call to sort (), we callnumpy.argsort (...) to make sure the array was\nsorted, and this yields the following array that confirms that behavior:\n\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n",
                    "extracted-code": ""
                },
                {
                    "section_name": "Searching within ndarrays",
                    "section_path": "./screenshots-images-2/chapter_1/section_43",
                    "images": [
                        "./screenshots-images-2/chapter_1/section_43/e8fbc1c4-f4c3-497f-84ed-1aecc0ac6085.png",
                        "./screenshots-images-2/chapter_1/section_43/488e9702-baed-44b8-96ae-51628055678b.png"
                    ],
                    "code_images": [],
                    "status": "images tested ok",
                    "errors": [],
                    "extracted-text": "Finding indices of elements where a certain condition is met is a fundamental operation\non an ndarray.\n\nFirst, we start with an ndarray with consecutive values, as illustrated here:\n\narrl = np.array(range(1, 11));\narrl\n\nThis creates the following ndarray:\narray([ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nWe create a second ndarray based on the first one, except this time the values in the\nsecond one are multiplied by 1000, as illustrated in the following code snippet:\n\narr2 = arrl * 1000;\n\narr2\nThen, we know arr2 contains the following data:\n\narray([ 1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000,\n9000,\n\n10000] )\nWe define another ndarray that contains 10 True and False values randomly, as follows:\n\ncond = np.random.randn(10) > 0;\ncond\n\nThe values in the cond ndarray are shown here:\n\narray([False, False, True, False, False, True, True, True,\nFalse, True] )\n\nThe np.where (...) method allows us to select values from one ndarray or another,\ndepending on the condition being True or False. The following code will generate an\nndarray with a value picked from arr1 when the corresponding element in the cond\narray is True; otherwise, the value is picked from arr2:\n\nnp.where(cond, arrl, arr2)\nThe returned array is shown here:\n\narray([1000, 2000, 3, 4000, 5000, 6, 7, 8, 9000,\n10])\n",
                    "extracted-code": ""
                },
                {
                    "section_name": "File operations with text files",
                    "section_path": "./screenshots-images-2/chapter_1/section_44",
                    "images": [
                        "./screenshots-images-2/chapter_1/section_44/d9cae5ab-878e-404c-b522-113e11e446bf.png",
                        "./screenshots-images-2/chapter_1/section_44/5e22fe06-77cd-4b2b-a219-32f3d3cf8c58.png"
                    ],
                    "code_images": [],
                    "status": "images tested ok",
                    "errors": [],
                    "extracted-text": "The key advantages of text files are that they are human-readable and compatible with any\ncustom software.\n\nLet's start with the following random array:\narr\nThis array contains the following data:\n\narray ([[-0.50566069, -0.52115534, 0.0757591 ],\n[ 1.67500165, -0.99280199, 0.80878346],\n[ 0.56937775, 0.36614928, -0.02532004]])\n\nThe numpy.savetxt (...) method saves the ndarray to disk in text format.\n\nThe following example uses a fmt ='%0.21\u00a3' format string and specifies a\ncomma delimiter:\n\nnp.savetxt ('arr.csv', arr, fmt='%0.21f', delimiter=',')\nLet's inspect the arr . csv file written out to disk in the current directory, as follows:\n\ntcat arr.csv\n\nThe comma-separated values (CSV) file contains the following data:\n\n-0.51,-0.52,0.08\n1.68,-0.99,0.81\n0.57,0.37,-0.03\n\nThe numpy.loadtxt (...) method loads an ndarray from text file to memory. Here,\nwe explicitly specify the delimiter=', ' parameter, as follows:\n\narr_new = np.loadtxt('arr.csv', delimiter=',')j;\n\narr_new\nAnd the ndarray read in from the text file contains the following data:\n\narray([[-0.51, -0.52, 0.08],\n[ 1.68, -0.99, 0.81],\n[ 0.57, 0.37, -0.03]])\n",
                    "extracted-code": ""
                },
                {
                    "section_name": "File operations with binary files",
                    "section_path": "./screenshots-images-2/chapter_1/section_45",
                    "images": [
                        "./screenshots-images-2/chapter_1/section_45/cff5182b-3dea-4796-981e-5e5a40eeee03.png",
                        "./screenshots-images-2/chapter_1/section_45/2b5bbd6c-66c3-4764-be57-33b3b6f889b1.png"
                    ],
                    "code_images": [],
                    "status": "images tested ok",
                    "errors": [],
                    "extracted-text": "Binary files are far more efficient for computer processing\u2014they save and load more quickly\nand are smaller than text files. However, their format may not be supported by other software.\n\nThe numpy.save(...) method stores ndarrays in a binary format, as illustrated in the\nfollowing code snippet:\n\nnp.save('arr', arr)\n!cat arr.npy\n\nThe output of the arr . npy file is shown here:\n\n@NUMPYEV{'descr': '<f8', 'fortran_order': False, \u2018shape\u2019: (3, 3), }\nOOO? O? OO (fIONOOIOO O O 100 ' [/cOOOOOU\n\nThe numpy.save(...) method automatically assigns the . npy extension to binary\nfiles it creates.\n\nThe numpy.1load(...) method, shown in the following code snippet, is used for\nreading binary files:\n\narr_new = np.load('arr.npy');\n\narr_new\n\nThe newly read-in ndarray is shown here:\n\narray([[-0.50566069, -0.52115534, 0.0757591 J,\n[ 1.67500165, -0.99280199, 0.80878346],\n[ 0.56937775, 0.36614928, -0.02532004]])\n\nAnother advantage of having binary file formats is that data can be stored with extreme\nprecision, especially when dealing with floating values, which is not always possible with\ntext files since there is some loss of precision in certain cases.\n\nLet's check if the old arr ndarray and the newly read-in arr_new array match exactly, by\nrunning the following code:\n\narr == arr_new\n\nThis will generate the following array, containing True if the elements are equal and\nFalse otherwise:\n\narray([[ True, True, True],\n[ True, True, True],\n[ True, True, True]])\n\nSo, we see that each element matches exactly.\n",
                    "extracted-code": ""
                },
                {
                    "section_name": "Summary",
                    "section_path": "./screenshots-images-2/chapter_1/section_46",
                    "images": [
                        "./screenshots-images-2/chapter_1/section_46/406f2805-aeff-40c1-ac41-880e38c5bb34.png"
                    ],
                    "code_images": [],
                    "status": "images tested ok",
                    "errors": [],
                    "extracted-text": "In this chapter, we have learned how to create matrices of any dimension in Python,\nhow to access the matrices\u2019 elements, how to calculate basic linear algebra operations on\nmatrices, and how to save and load matrices.\n\nWorking with NumPy matrices is a principal operation for any data analysis since vector\noperations are machine-optimized and thus are much faster than operations on Python\nlists\u2014usually between 5 and 100 times faster. Backtesting any algorithmic strategy\ntypically consists of processing enormous matrices, and then the speed difference can\ntranslate to hours or days of saved time.\n\nIn the next chapter, we introduce the second most important library for data analysis:\nPandas, built upon NumPy. NumPy provides support for data manipulations based\nupon DataFrames (a DataFrame is the Python version of an Excel worksheet\u2014that is, a\ntwo-dimensional data structure where each column has its own type).\n",
                    "extracted-code": ""
                }
            ]
        }
    ]
}